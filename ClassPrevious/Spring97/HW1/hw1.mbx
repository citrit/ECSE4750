From ???@??? Thu Feb 06 14:17:00 1997
Received: from jec331.its.rpi.edu (jec331.its.rpi.edu [128.113.10.81])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id NAA18854
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 13:51:21 -0500
From: Alexander Holmansky <kholma>
Received: (kholma@localhost) by jec331.its.rpi.edu (951211.SGI.8.6.12.PATCH1042/8.6.4) id NAA01224 for citrit@rpi.edu; Thu, 6 Feb 1997 13:51:19 -0500
Date: Thu, 6 Feb 1997 13:51:19 -0500
Message-Id: <199702061851.NAA01224@jec331.its.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: b0602449f8719146ad09eceea6a02428

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 13:49 EST by <kholma@rebecca.its.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/95/kholma/class/vis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  10396 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh12593; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X *  hw1.c 
X *
X *  Advanced Graphics & Visualization, Spring 1997
X *	Homework 1.
X *	
X *	Alexander Holmansky
X *
X *	This program draws solid cube, sphere, and teapot.
X *	It allows for camera point movement and independent rotation of the
X *	objects.
X *
X *	Some parts of this program are taken from simple3.c provided in class.
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
/* Geometry objects and the camera (view) */
#define	CUBE	1
#define	SPHERE	2
#define	TEAPOT	3
#define VIEW	4
X
/* Rotation axis */
#define	X	5
#define	Y	6
#define Z	7
X
/* Structure to hold object properties */
typedef struct {
X	float origin[3];		/* the center of a geometry object */
X	float orientation[3];	/* angular displacement from all axis */
X	float emmitted[4];		/* emmission material properties */
X	float ambdif[4];		/* ambient & diffuse material properties */
X	float specular[4];		/* specular material properties */
X	float shininess;		/* shininess of the material */
} objProp;
X
X
objProp	cubeProp;	/* holds the properties of the cube */
objProp sphereProp;	/* holds the properties of the sphere */
objProp teapotProp;	/* holds the properties of the teapot */
X
/* Color Values */
GLfloat pink[] = {0.3, 0.0, 0.0, 1.0};
GLfloat pinkish_red[] = {0.6, 0.0, 0.0, 1.0};
GLfloat red[] = {0.8, 0.0, 0.0, 1.0};
GLfloat white[] = {0.8, 0.8, 0.8, 1.0};
GLfloat yellow[] = {0.8, 0.5, 0.0, 1.0};
GLfloat lblue[] = {0.0, 0.0, 0.5, 1.0};
GLfloat blue[] = {0.0, 0.0, 0.8, 1.0};
GLfloat none[] = {0.0, 0.0, 0.0, 0.0};
X
X
int rotate = CUBE;	/* which object to rotate (initially cube) */
int axis = X;	/* axis of rotation */
X
/* Functions to load object matricies */
void loadCubeMatrix(int show) {
X	glPushMatrix();
X		glLoadIdentity();
X		glTranslatef(cubeProp.origin[0], 
X					 cubeProp.origin[1], cubeProp.origin[2]);
X		glMatrixMode(GL_MODELVIEW);
X		glRotatef(cubeProp.orientation[0], 1.0, 0.0, 0.0);
X		glRotatef(cubeProp.orientation[1], 0.0, 1.0, 0.0);
X		glRotatef(cubeProp.orientation[2], 0.0, 0.0, 1.0);
X		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, pink);
X		glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, pink);
X		glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, red);
X		glMaterialf(GL_FRONT, GL_SHININESS, cubeProp.shininess);
X		if (show) glutSolidCube(1.0);   /*  draw the cube       */
X	glPopMatrix();
} 
X
void loadSphereMatrix(int show) {
X	glPushMatrix();
X		glLoadIdentity();
X		glTranslatef(sphereProp.origin[0], 
X					 sphereProp.origin[1], sphereProp.origin[2]);
X		glMatrixMode(GL_MODELVIEW);
X		glRotatef(sphereProp.orientation[0], 1.0, 0.0, 0.0);
X		glRotatef(sphereProp.orientation[1], 0.0, 1.0, 0.0);
X		glRotatef(sphereProp.orientation[2], 0.0, 0.0, 1.0);
X		glMaterialfv(GL_FRONT, GL_AMBIENT, none);
X		glMaterialfv(GL_FRONT, GL_DIFFUSE, blue);
X		glMaterialfv(GL_FRONT, GL_SPECULAR, none);
X		glMaterialfv(GL_FRONT, GL_EMISSION, lblue);
X		glMaterialf(GL_FRONT, GL_SHININESS, sphereProp.shininess);
X		if (show) glutSolidSphere(1.0, 20, 20);   /*  draw the sphere  */
X	glPopMatrix();
}
X
void loadTeapotMatrix(int show) {
X	glPushMatrix();
X		glLoadIdentity();
X		glTranslatef(teapotProp.origin[0], 
X					 teapotProp.origin[1], teapotProp.origin[2]);
X		glMatrixMode(GL_MODELVIEW);
X		glRotatef(teapotProp.orientation[0], 1.0, 0.0, 0.0);
X		glRotatef(teapotProp.orientation[1], 0.0, 1.0, 0.0);
X		glRotatef(teapotProp.orientation[2], 0.0, 0.0, 1.0);
X		glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, yellow);
X		glMaterialfv(GL_FRONT, GL_SPECULAR, white);
X		glMaterialfv(GL_FRONT, GL_EMISSION, yellow);
X		glMaterialf(GL_FRONT, GL_SHININESS, teapotProp.shininess);
X		if (show) glutSolidTeapot(1.0);   /*  draw the teapot */
X	glPopMatrix();
}
X
X
/*
X *  Clear the screen.  
X *  Draw cube, sphere and teapot.
X */
void display(void)
{	
X	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X	
X	loadCubeMatrix(1);
X	
X	loadSphereMatrix(1);
X	
X	loadTeapotMatrix(1);
X		
X	glutSwapBuffers();
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.2, 0.2, 0.2, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.0, 0.0, 0.0, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X      glEnable(GL_DITHER);
}
X
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -8.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
X
/*
X * Keyboard handler
X * 
X * Increments/decrements displacement angle for a current object/camera
X * from the current axis.
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case '+':
X    	switch (rotate) {
X    		case CUBE:
X    			if (axis == X)
X    				cubeProp.orientation[0] += 15.0;
X    			else if (axis == Y) 
X      				cubeProp.orientation[1] += 15.0;
X      			else 
X      				cubeProp.orientation[2] += 15.0;
X      			break;
X      			
X      		case SPHERE:
X      			if (axis == X)
X      				sphereProp.orientation[0] += 15.0;
X      			else if (axis == Y)
X      				sphereProp.orientation[1] += 15.0;
X      			else
X      				sphereProp.orientation[2] += 15.0;
X      			break;
X      			
X      		case TEAPOT:
X      			if (axis == X)
X      				teapotProp.orientation[0] += 15.0;
X      			else if (axis == Y)
X      				teapotProp.orientation[1] += 15.0;
X      			else
X      				teapotProp.orientation[2] += 15.0;
X      			break;
X      			
X      		case VIEW:
X      			glMatrixMode(GL_PROJECTION);
X      			if (axis == X) 
X      				glRotatef(15.0, 1.0, 0.0, 0.0);
X      			else if (axis == Y)	
X      				glRotatef(15.0, 0.0, 1.0, 0.0);
X      			else
X      				glRotatef(15.0, 0.0, 0.0, 1.0);
X      			glMatrixMode (GL_MODELVIEW);
X      			break;
X      		
X      		}
X    break;
X      
X      
X    case '-':
X    	switch (rotate) {
X    		case CUBE:
X    			if (axis == X)
X    				cubeProp.orientation[0] -= 15.0;
X    			else if (axis == Y) 
X      				cubeProp.orientation[1] -= 15.0;
X      			else 
X      				cubeProp.orientation[2] -= 15.0;
X      			break;
X      			
X      		case SPHERE:
X      			if (axis == X)
X      				sphereProp.orientation[0] -= 15.0;
X      			else if (axis == Y)
X      				sphereProp.orientation[1] -= 15.0;
X      			else
X      				sphereProp.orientation[2] -= 15.0;
X      			break;
X      			
X      		case TEAPOT:
X      			if (axis == X)
X      				teapotProp.orientation[0] -= 15.0;
X      			else if (axis == Y)
X      				teapotProp.orientation[1] -= 15.0;
X      			else
X      				teapotProp.orientation[2] -= 15.0;
X      			break;
X      			
X      		case VIEW:
X      			glMatrixMode(GL_PROJECTION);
X      			if (axis == X) 
X      				glRotatef(-15.0, 1.0, 0.0, 0.0);
X      			else if (axis == Y)	
X      				glRotatef(-15.0, 0.0, 1.0, 0.0);
X      			else
X      				glRotatef(-15.0, 0.0, 0.0, 1.0);
X      			glMatrixMode (GL_MODELVIEW);
X      			break;
X      		
X      		}
X    break;
X      
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
X
X
/*
X *  Handle Menus
X */
void
SelectAction(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    }
}
X
X
void
SelectObject(int value)
{
X    switch (value) {
X    case 1:
X        rotate = CUBE;
X    	break;
X    
X    case 2:
X        rotate = SPHERE;
X    	break;
X   	
X   	case 3:
X        rotate = TEAPOT;
X    	break;
X    	
X    case 4:
X    	rotate = VIEW;
X    	break;
X    }
}
X
X
void
SelectAxis(int value)
{
X    switch (value) {
X    case 1:
X        axis = X;
X    	break;
X    
X    case 2:
X        axis = Y;
X    	break;
X   	
X   	case 3:
X        axis = Z;
X    	break;
X    }
}
X	
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X	/* Print instructions */
X	printf("Welcome!\n");
X	printf("Use left mouse button to select rotation axis.\n");
X	printf("Use middle mouse button to select an object or camera.\n");
X	printf("Use right mouse button or \"ESC\" to quit.\n");
X	printf("Use \"+\" and \"-\" keys to perform rotations.\n\n");
X	
X	/* Initialize properties of all 3 objects */
X	cubeProp.origin[0] = 0.0;
X	cubeProp.origin[1] =  0.0;
X	cubeProp.origin[2] =  0.0;
X	cubeProp.orientation[0] = 0.0;
X	cubeProp.orientation[1] = 0.0;
X	cubeProp.orientation[2] = 0.0;
X	cubeProp.shininess = 100.0;
X
X	
X	sphereProp.origin[0] = 2.0;
X	sphereProp.origin[1] = 0.0;
X	sphereProp.origin[2] = 0.0;
X	sphereProp.orientation[0] = 0.0;
X	sphereProp.orientation[1] = 0.0;
X	sphereProp.orientation[2] = 0.0;
X	sphereProp.shininess = 0.0;
X
X	teapotProp.origin[0] = -2.0;
X	teapotProp.origin[1] = 0.0;
X	teapotProp.origin[2] = 0.0;
X	teapotProp.orientation[0] = 0.0;
X	teapotProp.orientation[1] = 0.0;
X	teapotProp.orientation[2] = 0.0;
X	teapotProp.shininess = 10.0;
X	
X	/* Initialize GLUT & display window */
X	glutInit(&argc, argv);
X	glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X	glutCreateWindow (argv[0]);
X	myInit ();
X	glutKeyboardFunc(Key);
X	glutReshapeFunc (myReshape);
X	glutDisplayFunc(display);
X	
X	/* Create menu for major actions */
X	glutCreateMenu(SelectAction);
X	glutAddMenuEntry("Quit", 1);
X	glutAttachMenu(GLUT_RIGHT_BUTTON);	/* called by the right mouse button */
X	
X	/* Create menu to select the current object */
X	glutCreateMenu(SelectObject);
X	glutAddMenuEntry("Cube", 1);
X	glutAddMenuEntry("Sphere", 2);
X	glutAddMenuEntry("Teapot", 3);
X	glutAddMenuEntry("Camera", 4);
X	glutAttachMenu(GLUT_MIDDLE_BUTTON);	/* called by the middle mouse button */
X	
X	/* Create menu to select the current rotation axis */
X	glutCreateMenu(SelectAxis);
X	glutAddMenuEntry("Rotate X", 1);
X	glutAddMenuEntry("Rotate Y", 2);
X	glutAddMenuEntry("Rotate Z", 3);
X	glutAttachMenu(GLUT_LEFT_BUTTON);	/* called by the left mouse button */
X	
X	glutMainLoop();	/* enter main loop */
}
X
SHAR_EOF
  $shar_touch -am 0206134697 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
e41e2237f4905c3992ca394aa2aa8d88  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 10396 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '10396,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh12593
exit 0

From ???@??? Fri Feb 07 07:33:29 1997
Received: from cii3112-07.its.rpi.edu (griglb@cii3112-07.its.rpi.edu [128.113.109.157])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id VAA33144
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 21:31:50 -0500
From: Brian J Griglak <griglb>
Received: (griglb@localhost) by cii3112-07.its.rpi.edu (8.6.9/8.6.4) id VAA25022 for citrit@rpi.edu; Thu, 6 Feb 1997 21:31:46 -0500
Date: Thu, 6 Feb 1997 21:31:46 -0500
Message-Id: <199702070231.VAA25022@cii3112-07.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 0ecd0d7db983eeda5e4f6649bbfa05df

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 21:31 EST by <griglb@cii3112-07>.
# Source directory was `/afs/rpi.edu/home/87/griglb/graphics'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   4242 -rwx------ hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh19126; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X *  hw1.c 
X *
X *  Advanced Computer Graphics and Data Visualization
X *
X *  Brian J Griglak
X *
X *  6 February, 1997
X *
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
float eye[2], sphere[2], cube[2], teapot[2];
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void
display(void)
{
X    
X
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X    glColorMaterial(GL_FRONT, GL_SPECULAR);
X    glEnable(GL_COLOR_MATERIAL);
X
X    glPushMatrix();
X    glRotatef(eye[1], 1.0, 0.0, 0.0);
X    glRotatef(eye[0], 0.0, 1.0, 0.0);
X
X    glPushMatrix();
X    glTranslatef(2.0, 0.0, 0.0);
X    glRotatef(sphere[1], 1.0, 0.0, 0.0);
X    glRotatef(sphere[0], 0.0, 1.0, 0.0);
X    glColor3f(0.0, 0.0, 0.9);
X    glutSolidSphere(0.75, 20, 20);
X    glPopMatrix();
X
X    glPushMatrix();
X    glTranslatef(-2.0, 0.0, 0.0);
X    glRotatef(teapot[1], 1.0, 0.0, 0.0);
X    glRotatef(teapot[0], 0.0, 1.0, 0.0);
X    glColor3f(0.9, 0.9, 0.0);
X    glutSolidTeapot(0.75);
X    glPopMatrix();
X
X    glPushMatrix();
X    glRotatef(cube[1], 1.0, 0.0, 0.0);
X    glRotatef(cube[0], 0.0, 1.0, 0.0);
X    glColor3f(1.0, 0.0, 0.0);
X    glutSolidCube(1.0);
X    glPopMatrix();
X
/*    glDisable(GL_COLOR_MATERIAL);*/
X    glPopMatrix();
X    glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X /*     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'i': eye[1] += 15.0;
X              break;
X    case 'j': eye[0] += 15.0;
X              break;
X    case 'l': eye[0] -= 15.0;
X              break;
X    case 'k': eye[1] -= 15.0;
X              break;
X    case 'h': sphere[1] += 15.0;
X              break;
X    case 'b': sphere[0] += 15.0;
X              break;
X    case 'm': sphere[0] -= 15.0;
X              break;
X    case 'n': sphere[1] -= 15.0;
X              break;
X    case 'r': cube[1] += 15.0;
X              break;
X    case 'd': cube[0] += 15.0;
X              break;
X    case 'g': cube[0] -= 15.0;
X              break;
X    case 'f': cube[1] -= 15.0;
X              break;
X    case 's': teapot[1] += 15.0;
X              break;
X    case 'z': teapot[0] += 15.0;
X              break;
X    case 'c': teapot[0] -= 15.0;
X              break;
X    case 'x': teapot[1] -= 15.0;
X              break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      glutInitWindowSize(500, 200);
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Quit", 1);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206212897 'hw1.c' &&
  chmod 0700 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
820da136bf1b016ca0c2e0d0e0036453  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 4242 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '4242,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh19126
exit 0

From ???@??? Thu Feb 06 07:38:11 1997
Received: from cortez.sss.rpi.edu (parkec3@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id VAA36112
	for <citrit@rpi.edu>; Wed, 5 Feb 1997 21:15:33 -0500
From: Chris Parker <parkec3>
Received: (parkec3@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id VAA88186 for citrit@rpi.edu; Wed, 5 Feb 1997 21:15:31 -0500
Date: Wed, 5 Feb 1997 21:15:31 -0500
Message-Id: <199702060215.VAA88186@cortez.sss.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 187040e474774ff0b5efceb641684711

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-05 21:15 EST by <parkec3@cortez>.
# Source directory was `/afs/rpi.edu/home/89/parkec3/private/datavis'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   6133 -rw-r----- hw1.c
#    407 -rw------- makefile
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh68440; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
//	hw1.c
//	Chris Parker (041-88-3009)
//	parkerc@cs.rpi.edu
//
//	Homework 1 - Advanced Computer Graphics and Data Visualization
//
//	Assignment: to do something that looks vaguely like the UPN logo
//				and tweak it to do other cool things.
X
//	standard stuff I might need
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
X
//	windows required stuff
#ifdef _WIN32
#include <windows.h>
#endif
X
//	OpenGL required stuff
#include <GL/gl.h>
#include <GL/glut.h>
X
// defines for some useful constants
#define kRotateTeapot 2
#define kRotateCube 3
#define kRotateSphere 4
#define kRotateCamera 5
X
#define kIncrement 10
X
//	global stuff goes here
//	NOTE: if I was *really* going to do this,
//			I'd be making each of these a class, and just letting
//			each of the things know how to draw themselves.
//			For right now, though... that's overkill.
X
//	global state for cube
static GLfloat cubeColor[4] = { 0.85, 0.0, 0.0, 1.0 };	// Red at 100% opacity
GLfloat cubeUnits = 0;
int cubeRotX = 0;		// Degrees cube rotated (X axis)
int cubeRotY = 0;		// Degrees cube rotated (Y axis)
X
//	global state for sphere
static GLfloat sphereColor[4] = { 0.0, 0.0, 0.85, 1.0 };	// Blue at 100% opacity
GLfloat sphereUnits = 2.0;	// rel. to cube
int sphereRotX = 0;	// Degrees sphere rotated (X axis)
int sphereRotY = 0;	// Degrees sphere rotated (Y axis)
X
X
static GLfloat teapotColor[4] = { 0.85, 0.85, 0.0, 1.0 };	// Yellow at 100% opacity
GLfloat teapotUnits = -2.0;	// rel. to cube
int teapotRotX = 0;	// Degrees teapot rotated (X axis)
int teapotRotY = 0;	// Degrees teapot rotated (Y axis)
X
int whatToRotate = 5;
X
void myStuff( void ) {
X	static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
//	static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X	static float lightAmb[4] = {0.6, 0.6, 0.6, 1.0};
X	static float lightDiff[4] = {0.6, 0.6, 0.6, 1.0};
X	static float lightSpec[4] = {0.3, 0.3, 0.3, 1.0};
X
X	glEnable(GL_LIGHTING);
X	glEnable(GL_LIGHT0);
X	glEnable(GL_COLOR_MATERIAL);
X	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X	glDepthFunc( GL_LESS );
X	glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X	glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X	glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X	glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X	glEnable(GL_DEPTH_TEST);
}
X
void display( void ) {
X	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
X
X	glPushMatrix();
X
X	glPushMatrix();
X	// First, draw the cube
X	glMaterialf( GL_FRONT, GL_SHININESS, 1.0);
X	glColor4fv( cubeColor );
X	glRotatef( cubeRotX, 1.0, 0.0, 0.0 );
X	glRotatef( cubeRotY, 0.0, 1.0, 0.0 );
X	glutSolidCube( 0.75 );
X	glPopMatrix();
X
X	// then draw the sphere 2 units to the right
X	glPushMatrix();
X	glTranslatef( 2.0, 0.0, 0.0 );
X	glColor4fv( sphereColor );
X	glRotatef( sphereRotX, 1.0, 0.0, 0.0 );
X	glRotatef( sphereRotY, 0.0, 1.0, 0.0 );
X	glutSolidSphere( 0.5, 10, 10 );
X	glPopMatrix();
X	// 
X
X	// then draw the teapot 2 units to the left
X	glPushMatrix();
X	glTranslatef( -2.0, 0.0, 0.0 );
X	glMaterialf( GL_FRONT, GL_SHININESS, 1.0 );
X	glColor4fv( teapotColor );
X	glRotatef( teapotRotX, 1.0, 0.0, 0.0 );
X	glRotatef( teapotRotY, 0.0, 1.0, 1.0 );
X	glutSolidTeapot( 0.5 );
X	glPopMatrix();
X
X	glPopMatrix();
X	glutSwapBuffers();
}
X
void reshape( int x, int y ) {
X	glViewport( 0, 0, x, y );		// defines the viewport
X	glMatrixMode( GL_PROJECTION );	// which matrix are we tinkering with
X	glLoadIdentity();
X	gluPerspective( 45.0, 1.0*x/y, 1.0, 10.0 );
X	glTranslatef( 0.0, 0.0, -5.0 );	// back us up
X	glMatrixMode( GL_MODELVIEW );	// back to modelview matrix
}
X
// God, this got ugly in a hurry.  In a more ideal world, we'd
// set things like this up as part of the class - a key would
// generate an event to what was designated as the current object
// in the system.
void handleKey( unsigned char key, int x, int y ) {
X	switch( whatToRotate ) {
X	case kRotateTeapot:
X		switch( key ) {
X		case 'd':
X			teapotRotY = ( teapotRotY + kIncrement ) % 360;
X			break;
X		case 's':
X			teapotRotX = ( teapotRotX + kIncrement ) % 360;
X			break;
X		case 'a':
X			teapotRotY = ( teapotRotY - kIncrement ) % 360;
X			break;
X		case 'w':
X			teapotRotX = ( teapotRotX - kIncrement ) % 360;
X			break;
X		}
X		break;
X	case kRotateCube:
X		switch( key ) {
X		case 'd':
X			cubeRotY = ( cubeRotY + kIncrement ) % 360;
X			break;
X		case 's':
X			cubeRotX = ( cubeRotX + kIncrement ) % 360;
X			break;
X		case 'a':
X			cubeRotY = ( cubeRotY - kIncrement ) % 360;
X			break;
X		case 'w':
X			cubeRotX = ( cubeRotX - kIncrement ) % 360;
X			break;
X		}
X		break;
X	case kRotateSphere:
X		switch( key ) {
X		case 'd':
X			sphereRotY = ( sphereRotY + kIncrement ) % 360;
X			break;
X		case 's':
X			sphereRotX = ( sphereRotX + kIncrement ) % 360;
X			break;
X		case 'a':
X			sphereRotY = ( sphereRotY - kIncrement ) % 360;
X			break;
X		case 'w':
X			sphereRotX = ( sphereRotX - kIncrement ) % 360;
X			break;
X		}
X		break;
X	case kRotateCamera:
X	// Rotate the viewport
X	// w, a, s, d will rotate the model viewport
X		switch( key ) {
X		case 'w':
X			glMatrixMode( GL_MODELVIEW );
X			glRotatef( 15.0, 1.0, 0.0, 0.0 );
X			break;
X		case 'a':
X			glMatrixMode( GL_MODELVIEW );
X			glRotatef( 15.0, 0.0, 1.0, 0.0 );
X			break;
X		case 's':
X			glMatrixMode( GL_MODELVIEW );
X			glRotatef( -15.0, 1.0, 0.0, 0.0 );
X			break;
X		case 'd':
X			glMatrixMode( GL_MODELVIEW );
X			glRotatef( -15.0, 0.0, 1.0, 0.0 );
X			break;
X		default:
X			break;
X		}
X	}
X	glutPostRedisplay();
}
X
void Select( int value ) {
X	switch( value ) {
X	case 1:
X		exit( 0 );
X		break;
X	default:
X		whatToRotate = value;	// set a flag as to what to be rotating
X		break;
X	}
}
X
void main( int argc, char **argv ) {
X	glutInit( &argc, argv );
X	glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGBA );
X	glutInitWindowPosition( 200, 200 );
X	glutInitWindowSize( 600, 200 );
X	glutCreateWindow( argv[0] );
X	myStuff();		// do stuff here
X	glutKeyboardFunc( handleKey );
X	glutDisplayFunc( display );
X	glutReshapeFunc( reshape );
X	glutCreateMenu( Select );
X	glutAddMenuEntry( "Rotate teapot", 2 );
X	glutAddMenuEntry( "Rotate cube", 3 );
X	glutAddMenuEntry( "Rotate sphere", 4 );
X	glutAddMenuEntry( "Rotate camera", 5 );
X	glutAddMenuEntry( "Quit", 1 );
X	glutAttachMenu( GLUT_RIGHT_BUTTON );
X	glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0205211397 'hw1.c' &&
  chmod 0640 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
26a86cb333b86bf1f2fc467f5a0d27a3  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 6133 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '6133,' 'current size' "$shar_count!"
  fi
fi
# ============= makefile ==============
if test -f 'makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'makefile' '(file already exists)'
else
  $echo 'x -' extracting 'makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'makefile' &&
#
# Sample Makefile for building OpenGL programs on RCS IBM systems
#
# Specify a target below.
#
CC=gcc
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	-lMesaaux -lglut -lMesaGLU -lMesaGL -lMesatk  \
X	 -lXmu -lXt -lX11 -lm
X
CFLAGS= -Wall -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include
X
TARGET=somefile
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0205160497 'makefile' &&
  chmod 0600 'makefile' ||
  $echo 'restore of' 'makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'makefile:' 'MD5 check failed'
e2f628e2cbe25f5b66793d9478160ce7  makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'makefile'`"
    test 407 -eq "$shar_count" ||
    $echo 'makefile:' 'original size' '407,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh68440
exit 0

From ???@??? Fri Feb 07 07:33:17 1997
Received: from lib123.its.rpi.edu (dsouze@lib123.its.rpi.edu [128.113.68.129])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id SAA24326
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 18:41:06 -0500
From: "Elaine D'Souza" <dsouze>
Received: (dsouze@localhost) by lib123.its.rpi.edu (8.6.9/8.6.4) id SAA13654 for citrit@rpi.edu; Thu, 6 Feb 1997 18:41:05 -0500
Date: Thu, 6 Feb 1997 18:41:05 -0500
Message-Id: <199702062341.SAA13654@lib123.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: aeb1ee8214c35fded6fcedacef0c1d05

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 18:37 EST by <dsouze@lib123>.
# Source directory was `/afs/rpi.edu/home/98/dsouze/cg/cgHW'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  14399 -rw------- hw.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh17122; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw.c ==============
if test -f 'hw.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw.c' &&
X
/**********************************************************************
X *  Homwork1.c		by Elaine D'Souza
X *  This program is in fulfillment of specification provided Jan 30,'97.
X *  
X *    Use the right mouse button to activate the menu's and sub menus
X *	Menu options provided are as follows
X *		1> Rotate -> Teapot/Cube/Sphere
X *		2> Move   -> Teapot/Cube/Sphere
X *		3> Scale  -> Teapot/Cube/Sphere
X *		4> Transparency -> ON/OFF
X *		5> Display polygon mode -> Filled/Outline
X *
X *	In order to Rotate/Move the selected object use following keys:
X *	 	'f' : in Z-direction
X *		'g' : in Y-direction
X *	 	'h' : in X-direction
X *		'j' : in X-direction
X *		'k' : in Y-direction
X *		'l' : in Z-direction
X *
X *	In order to Scale the selected object use the following
X *	 keys:	'b' : (big)
X *		's' : (small)
X *
X *	In order to change the camera viewpoint use the following
X *	 keys:	'z' : in X-direction counterclockwise
X *		'x' : in Y-direction upwards
X *		'c' : in Y-direction downwards
X *		'v' : in X-direction clockwise
X *	 	'i' : go closer (increase)
X *		's' : move back (decrease)
X *
X **********************************************************************/
X /*********************************************************************
X *	The program uses the object material properties as well as
X *	lighting effects to obtain the desired object colors and
X *	the shinny as well as rough effect on the cube and sphere
X *	respectively.
X *
X *	In addition, with the help of the transformation functions
X *	the camera viewpoint and the individual orientation and position
X *	as manipulated. In specific:
X *	1> the camera can move closer or further away
X *	2> the camera can move about the X- and Y- axis
X *	3> the individual object may be rotated/moved/scaled
X *	   independent of the others
X *
X *********************************************************************/
X
#define TEAPOT 1
#define CUBE 2
#define SPHERE 3
#define ROTATE 1
#define MOVE 2
#define SCALE 3
#define Main_SCF 2.0
#define ON 1
#define OFF 0
X
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <GL/glut.h>
X
GLfloat WHITE[] = {1.0, 1.0, 1.0};
GLfloat RED[] = {1.0, 0.0, 0.0};
GLfloat BLUE[] = {0.0, 0.0, 1.0};
GLfloat YELLOW[] = {1.0, 1.0, 0.0};
GLfloat BLACK[] = {0.0, 0.0, 0.0};
X
struct POSITION {
X  float px, py, pz;
X  };
X  
struct OBJECT {
X  float scf;
X  struct POSITION posn, angle;
/*  struct POSITION rotn;*/
X  } teapot, cube, sphere;
X
int Select_obj, Opern, Trans_state;
float scf = Main_SCF*10;
X
X
/*  Initialize the program global variables.
X */
void pgm_init(void)
{
X    Select_obj=CUBE;	/* Select Cube as default object */
X	/* Init the teapot paramaters */
X    teapot.posn.px = -1.0;  teapot.posn.py = 0.0;   teapot.posn.pz = 0.0;
X    teapot.angle.px = 15.0; teapot.angle.py = 0.0;  teapot.angle.pz = 0.0;    
X	/* Init the cube paramaters */
X    cube.posn.px = 0.0;     cube.posn.py = 0.0;     cube.posn.pz = 0.0;
X    cube.angle.px = 45.0;   cube.angle.py = 0.0;    cube.angle.pz = 0.0;   
X	/* Init the sphere paramaters */
X    sphere.posn.px = 1.0;   sphere.posn.py = 0.0;   sphere.posn.pz = 0.0;
X    sphere.angle.px = 0.0;  sphere.angle.py = 0.0;  sphere.angle.pz = 0.0;
X
X    cube.scf = 5.0;  teapot.scf = 5.0;  sphere.scf = 5.0;
}
X
/*  Initialize material property and light source.
X */
void myinit(void)
{
X    GLfloat light_ambient0[] = {0.2, 0.2, 0.2, 1.0};
X    GLfloat light_diffuse0[] = {0.8, 0.8, 0.8, 1.0};
X    GLfloat light_specular0[] = {0.6, 0.6, 0.6, 1.0};
X    GLfloat light_position0[] = {0.0, 1.0, 0.0, 0.0};
X
X    GLfloat light_ambient1[] = {1.0, 0.0, 0.0, 1.0};
X    GLfloat light_diffuse1[] = {0.2, 0.2, 0.2, 1.0};
X    GLfloat light_specular1[] = {1.0, 0.0, 0.0, 1.0};
X    GLfloat light_position1[] = {-1.0, 1.0, 0.0, 0.0};
X
X    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient0);
X    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse0);
X    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular0);
X    glLightfv(GL_LIGHT0, GL_POSITION, light_position0);
X
X    glLightfv(GL_LIGHT1, GL_AMBIENT, light_ambient1);
X    glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse1);
X    glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular1);
X    glLightfv(GL_LIGHT1, GL_POSITION, light_position1);
X
glBlendFunc(GL_SRC_ALPHA, GL_ONE);
/*(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);*/        
X    glDepthFunc(GL_LESS);
X    glEnable(GL_DEPTH_TEST);
X    glEnable(GL_LIGHTING);
X    glEnable(GL_LIGHT0);
X
/*    glEnable(GL_LIGHT0 | GL_DEPTH_TEST | GL_LIGHTING);
*/
}
X
void set_teapot_properties()
{
X    GLfloat t_ambient[] = {0.4, 0.4, 0.0, 1.0};
X    GLfloat t_diffuse[] = {0.75, 0.61, 0.23, 1.0};
X    GLfloat t_specular[] = {0.63, 0.56, 0.37, 1.0};
X    GLfloat t_diffuse_transparent[] = {0.8, 0.8, 0.0, 0.25};
X    
X    if (Trans_state == OFF)  {
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, t_ambient);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, t_specular);
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, t_diffuse);
X      }
X    else {
X      glColor3fv(YELLOW);
X      glEnable(GL_BLEND);
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, t_diffuse_transparent);
X      };
}
X
void set_cube_properties()
{
X    GLfloat c_ambient[] = {0.6, 0.0, 0.0, 1.0};
X    GLfloat c_diffuse[] = {0.7, 0.2, 0.7, 1.0};
X    GLfloat c_specular[] = {0.83, 0.13, 0.13, 1.0};
X
X    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, c_ambient);
X    glMaterialfv(GL_FRONT, GL_DIFFUSE, c_diffuse);
X    glMaterialfv(GL_FRONT, GL_SPECULAR, c_specular);
X    glMaterialf(GL_FRONT, GL_SHININESS, 100.0);
}
X
void set_sphere_properties()
{
X    GLfloat s_ambient[] = {0.0, 0.0, 0.7, 1.0};
X    GLfloat s_diffuse[] = {0.1, 0.1, 0.62, 1.0};
X    GLfloat s_specular[] = {0.63, 0.63, 0.73, 1.0};
X
X    glMaterialfv(GL_FRONT, GL_AMBIENT, s_ambient);
X    glMaterialfv(GL_FRONT, GL_DIFFUSE, s_diffuse);
X    glMaterialfv(GL_FRONT, GL_SPECULAR, s_specular);
X    glMaterialf(GL_FRONT, GL_SHININESS, 10.0);
}
X
void draw_teapot()
{
X    glPushMatrix();                        
X    glMatrixMode (GL_MODELVIEW);        
X    glTranslatef(teapot.posn.px, teapot.posn.py, teapot.posn.pz); 
/*printf("\nTEAPOT angle: %f x:%f  y:%f z:%f", teapot.angle, 
X	teapot.rotn.px, teapot.rotn.py, teapot.rotn.pz);*/
X    glRotatef(teapot.angle.px, 1.0, 0.0, 0.0);    
X    glRotatef(teapot.angle.py, 0.0, 1.0, 0.0);    
X    glRotatef(teapot.angle.pz, 0.0, 0.0, 1.0);    
X    glScalef(0.1*teapot.scf, 0.1*teapot.scf, 0.1*teapot.scf);
/*    glColor3fv(YELLOW);*/
X    set_teapot_properties();
X    glutSolidTeapot(0.3);
glDisable(GL_BLEND);  
X    glPopMatrix();
}
X
void draw_cube()
{
X    glPushMatrix();                        
X    glEnable(GL_LIGHT1);
X    glMatrixMode (GL_MODELVIEW);        
X    glTranslatef(cube.posn.px, cube.posn.py, cube.posn.pz);
/*printf("\nCUBE angle: %f x:%f  y:%f z:%f", cube.angle, 
X	cube.rotn.px, cube.rotn.py, cube.rotn.pz); */
X    glRotatef(cube.angle.px, 1.0, 0.0, 0.0);    
X    glRotatef(cube.angle.py, 0.0, 1.0, 0.0);    
X    glRotatef(cube.angle.pz, 0.0, 0.0, 1.0);    
X    glScalef(0.1*cube.scf, 0.1*cube.scf, 0.1*cube.scf);
/*    glColor3fv(RED);*/
X    set_cube_properties();
X    glutSolidCube(0.5);
X    glPopMatrix();
X    glDisable(GL_LIGHT1);
}
X
void draw_sphere()
{
X    glPushMatrix();                        
X    glMatrixMode (GL_MODELVIEW);        
X    glTranslatef(sphere.posn.px, sphere.posn.py, sphere.posn.pz);
/*printf("\nSPHERE angle: %f x:%f  y:%f z:%f", sphere.angle, 
X	sphere.rotn.px, sphere.rotn.py, sphere.rotn.pz);*/
X    glRotatef(sphere.angle.px, 1.0, 0.0, 0.0);    
X    glRotatef(sphere.angle.py, 0.0, 1.0, 0.0);    
X    glRotatef(sphere.angle.pz, 0.0, 0.0, 1.0);    
X    glScalef(0.1*sphere.scf, 0.1*sphere.scf, 0.1*sphere.scf);
/*    glColor3fv(BLUE); */
X    set_sphere_properties();
X    glutSolidSphere(0.3, 14, 14);
X    glPopMatrix();
}
X
X
void display(void)
{
X
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X    glPushMatrix();          
X    glScalef(scf*0.1*Main_SCF, scf*0.1*Main_SCF, scf*0.1*Main_SCF);
X
X    draw_teapot();
X    draw_cube();
X    draw_sphere();
X
X    glPopMatrix();
X    glutSwapBuffers();
}
X
X
void myReshape(int w, int h)
{
X    glViewport(0, 0, w, h);
X    glMatrixMode(GL_PROJECTION);
X    glLoadIdentity();
X    if (w <= h)
X        glOrtho(-2.5, 2.5, -2.5 * (GLfloat) h / (GLfloat) w,
X            2.5 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
X    else
X        glOrtho(-2.5 * (GLfloat) w / (GLfloat) h,
X            2.5 * (GLfloat) w / (GLfloat) h, -2.5, 2.5, -10.0, 10.0);
X    glMatrixMode(GL_MODELVIEW);
}
X
/*
X * Keyboard handler
X */
void Key(unsigned char key, int x, int y)
{
X  struct POSITION p, ang;
X  float  tmp_scf;
X  int each_flag = 1;
X
X    switch (key) {
X    case 'i':		/* Scale entire image */
X      scf=scf+1;       each_flag = 0;
X      break;
X    case 'd':		/* Scale entire image */
X      scf=scf-1;       each_flag = 0;   
X      break;
X    case 'z':		/* Rotate entire image about Y*/
X      glMatrixMode(GL_MODELVIEW);
X      glRotatef(15.0, 0.0, 1.0, 0.0);  
X      break;
X    case 'x':		/* Rotate entire image about X*/
X      glMatrixMode(GL_MODELVIEW);
X      glRotatef(15.0, 1.0, 0.0, 0.0);
X      break;
X    case 'c':		/* Rotate entire image about X*/
X      glMatrixMode(GL_MODELVIEW);
X      glRotatef(-15.0, 1.0, 0.0, 0.0);  
X      break;
X    case 'v':		/* Rotate entire image about Y*/
X      glMatrixMode(GL_MODELVIEW);
X      glRotatef(-15.0,  0.0, 1.0, 0.0);  
X      break;
X     case 'f':
X      ang.px = 0.0;  	ang.py = 0.0;  		ang.pz = 15.0;  
X      p.px = 0.0;  p.py = 1.0;  p.pz = 0.0;  
X      break;
X     case 'g':
X      ang.px = 0.0;  	ang.py = 15.0;  	ang.pz = 0.0;  
X      p.px = 0.0;  p.py = 1.0;  p.pz = 0.0;  
X      break;
X    case 'h':
X      ang.px = 15.0;  	ang.py = 0.0;  		ang.pz = 0.0;  
X      p.px = 1.0;  p.py = 0.0;  p.pz = 0.0;  
X      break;
X    case 'j':
X      ang.px = -15.0;  	ang.py = 0.0;  		ang.pz = 0.0;  
X      p.px = -1.0;  p.py = 0.0;  p.pz = 0.0;  
X      break;
X    case 'k':
X      ang.px = 0.0;  	ang.py = -15.0;  	ang.pz = 0.0;  
X      p.px = 0.0;  p.py = -1.0;  p.pz = 0.0;  
X      break;
X     case 'l':
X      ang.px = 0.0;  	ang.py = 0.0;  		ang.pz = -15.0;  
X      p.px = 0.0;  p.py = 1.0;  p.pz = 0.0;  
X      break;
X    case 'b':
X      tmp_scf = 1;      
X      break;
X    case 's':
X      tmp_scf = -1;       
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    
X    if (each_flag == 1)  {
X      switch (Opern) {
X        case ROTATE:
X          switch (Select_obj) {
X            case TEAPOT:
X              teapot.angle.px += ang.px;  teapot.angle.py += ang.py;  
X	      teapot.angle.pz += ang.pz;  
X              break;
X            case CUBE:
X              cube.angle.px += ang.px;  cube.angle.py += ang.py;  
X	      cube.angle.pz += ang.pz;  
X              break;
X            case SPHERE:
X              sphere.angle.px += ang.px;  sphere.angle.py += ang.py;  
X	      sphere.angle.pz += ang.pz;  
X              break;
X            default:
X              break;
X            };
X          break;
X        case MOVE:
X          switch (Select_obj) {
X            case TEAPOT:
X              teapot.posn.px += p.px;  teapot.posn.py += p.py;
X              break;
X            case CUBE:
X              cube.posn.px += p.px;  cube.posn.py += p.py;
X              break;
X            case SPHERE:
X              sphere.posn.px += p.px;  sphere.posn.py += p.py;
X              break;
X            default:
X              break;
X            };
X          break;
X        case SCALE:
X          switch (Select_obj) {
X            case TEAPOT:
X              teapot.scf += tmp_scf;  
X              break;
X            case CUBE:
X              cube.scf += tmp_scf;  
X              break;
X            case SPHERE:
X              sphere.scf += tmp_scf;
X              break;
X            default:
X              break;
X            };
X          break;
X      };
X    };
X    
X    glutPostRedisplay();
X
X }
X
void rotate_obj(int value)
{
X    Opern = ROTATE;
X    Select_obj=value;
}
X
void move_obj(int value)
{
X    Opern = MOVE;
X    Select_obj=value;
}
X
void scale_obj(int value)
{
X    Opern = SCALE;
X    Select_obj=value;
}
X
void transparency(int value)
{
X    Trans_state = value;
X    glutPostRedisplay();
}
X
void polygon_mode(int value)
{
X    switch (value) {
X    case 1:
X        glEnable(GL_DEPTH_TEST);
X        glEnable(GL_LIGHTING);
X        glDisable(GL_BLEND);
X        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
X        break;
X    case 2:
X        glDisable(GL_DEPTH_TEST);
X        glDisable(GL_LIGHTING);
X        glColor3f(1.0, 1.0, 1.0);
X        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
X        glEnable(GL_LINE_SMOOTH);
X        glEnable(GL_BLEND);
X        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X        break;
X    }
X    glutPostRedisplay();
}
X
void main_menu(int value)
{
X    switch (value) {
X    case 6:
X        exit(0);
X        break;
X    default:
X        Select_obj=value;
X        break;
X    }
}
X
/*  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
void main(int argc, char **argv)
{
X    int submenu0, submenu1, submenu2, submenu3, submenu4;
X     
X    pgm_init();
X    glutInit(&argc, argv);
X    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X    glutInitWindowPosition(800, 200);
X    glutInitWindowSize(400, 400);
X    glutCreateWindow(argv[0]);
X    myinit();
X    glutKeyboardFunc(Key);
X    glutReshapeFunc(myReshape);
X    glutDisplayFunc(display);
X
X    submenu0 = glutCreateMenu(polygon_mode);
X    glutAddMenuEntry("Filled", 1);
X    glutAddMenuEntry("Outline", 2);
X    submenu1 = glutCreateMenu(rotate_obj);
X    glutAddMenuEntry("Rotate Teapot", TEAPOT);
X    glutAddMenuEntry("Rotate Cube", CUBE);
X    glutAddMenuEntry("Rotate Sphere", SPHERE);
X    submenu2 = glutCreateMenu(move_obj);
X    glutAddMenuEntry("Move Teapot", TEAPOT);
X    glutAddMenuEntry("Move Cube", CUBE);
X    glutAddMenuEntry("Move Sphere", SPHERE);
X    submenu3 = glutCreateMenu(scale_obj);
X    glutAddMenuEntry("Scale Teapot", TEAPOT);
X    glutAddMenuEntry("Scale Cube", CUBE);
X    glutAddMenuEntry("Scale Sphere", SPHERE);
X    submenu4 = glutCreateMenu(transparency);
X    glutAddMenuEntry("ON", ON);
X    glutAddMenuEntry("OFF", OFF);
X    glutCreateMenu(main_menu);
X    glutAddMenuEntry("Quit", 6);
X     glutAddSubMenu("Rotate object", submenu1);
X     glutAddSubMenu("Move Object", submenu2);
X     glutAddSubMenu("Scale Object", submenu3);
X     glutAddSubMenu("Transparency", submenu4);
X     glutAddSubMenu("Display Polygon mode", submenu0);
X    glutAttachMenu(GLUT_RIGHT_BUTTON);
X    glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206183797 'hw.c' &&
  chmod 0600 'hw.c' ||
  $echo 'restore of' 'hw.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw.c:' 'MD5 check failed'
8b779707275b744faab4640d2c0cae6e  hw.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw.c'`"
    test 14399 -eq "$shar_count" ||
    $echo 'hw.c:' 'original size' '14399,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh17122
exit 0

From ???@??? Fri Feb 07 07:33:08 1997
Received: from cortez.sss.rpi.edu (tulumg@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id SAA42742
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 18:04:10 -0500
From: "Gregory C. Tulumbas" <tulumg>
Received: (tulumg@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id SAA122124 for citrit@rpi.edu; Thu, 6 Feb 1997 18:04:10 -0500
Date: Thu, 6 Feb 1997 18:04:10 -0500
Message-Id: <199702062304.SAA122124@cortez.sss.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: c9cfbe6fa8f94dc6df9c264665e78c60

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 18:03 EST by <tulumg@cortez>.
# Source directory was `/afs/rpi.edu/home/05/tulumg/private/gl'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   5543 -rw-rw-r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh128104; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* Gregory C. Tulumbas  - Homework #1 */
X
typedef struct {
X	GLfloat		dx;
X	GLfloat		dy;
X	GLfloat		dz;
X	
X	GLfloat		xangle;
X	GLfloat		yangle;
X	GLfloat		zangle;
X
X	GLfloat		c_diff[4];
X	GLfloat		c_spec[4];
X
X	GLfloat		shiny;
} ObjState;
X
ObjState cube;
ObjState sphere;
ObjState teapot;
ObjState camera;
X
ObjState *curr;
X
X
void display(void)
{
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
X	  
X	  /* Change camera angle */
X	  glMatrixMode(GL_PROJECTION);
X	  glPushMatrix();
X	    glRotatef(camera.xangle, 1.0, 0.0, 0.0);
X	    glRotatef(camera.yangle, 0.0, 1.0, 0.0);
X
X	    glMatrixMode (GL_MODELVIEW);
X	  
X	    /* Draw sphere */
X	    glPushMatrix();
X	     glTranslatef(sphere.dx, sphere.dy, sphere.dz);
X  	     glRotatef(sphere.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(sphere.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,sphere.c_diff);
X	     glMaterialfv(GL_FRONT,GL_SPECULAR, sphere.c_spec);
X	     glutSolidSphere(1.0, 10, 10);
X	    glPopMatrix();
X
X	    /* Draw teapot */
X	    glPushMatrix();
X	     glTranslatef(teapot.dx, teapot.dy, teapot.dz);	   
X	     glRotatef(teapot.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(teapot.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,teapot.c_diff); 
X	     glutSolidTeapot(0.75);
X	    glPopMatrix();
X
X        /* Draw cube */
X	    glPushMatrix();
X	     glTranslatef(cube.dx, cube.dy, cube.dz);	   
X	     glRotatef(cube.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(cube.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,cube.c_diff);
X	     glMaterialfv(GL_FRONT,GL_SPECULAR, cube.c_spec);
X	     glMaterialf(GL_FRONT,GL_SHININESS,cube.shiny);
X	     glutSolidCube(1.0);
X	    glPopMatrix();
X
X	  glMatrixMode(GL_PROJECTION);
X	  glPopMatrix();
X
X      glutSwapBuffers(); 
}
X
void myInit(void)
{
X      static float lightPos[4] = {2.0, 2.0, 3.0, 1.0};
X
X	  /* Initialize lighting & shading model */
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glEnable(GL_DEPTH_TEST);
X	  glShadeModel (GL_SMOOTH);
X
X	  /* Initialize objects */
X	  cube.dx = 0.0;
X	  cube.dy = 0.0;
X	  cube.dz = 0.0;
X	  cube.xangle = 0.0;
X	  cube.yangle = 0.0;
X	  cube.zangle = 0.0;
X	  cube.c_diff[0] = 1.0;
X	  cube.c_diff[1] = 0.0;
X	  cube.c_diff[2] = 0.0;
X	  cube.c_diff[3] = 1.0;
X	  cube.c_spec[0] = 0.8;
X	  cube.c_spec[1] = 0.8; 
X	  cube.c_spec[2] = 0.8;
X	  cube.c_spec[3] = 1.0;
X	  cube.shiny = 10.0;
X
X	  sphere.dx = 2.0;
X	  sphere.dy = 0.0;
X	  sphere.dz = 0.0;
X	  sphere.xangle = 0.0;
X	  sphere.yangle = 0.0;
X	  sphere.zangle = 0.0;
X	  sphere.c_diff[0] = 0.0;
X	  sphere.c_diff[1] = 0.0;
X	  sphere.c_diff[2] = 1.0;
X	  sphere.c_diff[3] = 1.0;
X	  sphere.c_spec[0] = 0.0;
X	  sphere.c_spec[1] = 0.0;
X	  sphere.c_spec[2] = 0.0;
X	  sphere.c_spec[3] = 1.0;
X
X
X	  teapot.dx = -2.0;
X	  teapot.dy = 0.0;
X	  teapot.dz = 0.0;
X	  teapot.xangle = 0.0;
X	  teapot.yangle = 0.0;
X	  teapot.zangle = 0.0;
X	  teapot.c_diff[0] = 1.0;
X	  teapot.c_diff[1] = 1.0;
X	  teapot.c_diff[2] = 0.0;
X	  teapot.c_diff[3] = 1.0;
X	  teapot.c_spec[0] = 0.0;
X	  teapot.c_spec[1] = 0.0;
X	  teapot.c_spec[2] = 0.0;
X	  teapot.c_spec[3] = 1.0;
X
X	  camera.xangle = 0.0;
X	  camera.yangle = 0.0;
X	  camera.zangle = 0.0;
X
X	  curr = &cube;
}
X
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'a':
X      curr->xangle = curr->xangle - 10 % 360;
X      break;
X    case 'z':
X      curr->xangle = curr->xangle + 10 % 360; 
X      break;
X    case 'k':
X      curr->yangle = curr->yangle - 10 % 360;
X      break;
X    case 'l':
X      curr->yangle = curr->yangle + 10 % 360;
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
/*
X *  Handle Menus
X */
void Select(int value){
X    switch (value) {
X	case 1:
X	    curr = &cube;
X		break;
X	case 2:
X		curr = &sphere;
X		break;
X	case 3:
X		curr = &teapot;
X		break;
X	case 4:
X		curr = &camera;
X		break;
X	case 5:
X		myInit();
X	    glutPostRedisplay();
X		break;
X    case 20:
X        exit(0);
X        break;
X    }
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X	  glTranslatef (0.0, 0.0, -9.0);     /*  viewing transformation      */
X	  glPushMatrix();
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) {
X
X printf("Project #1: Teapot, Cube & Sphere\n");
X printf("---------------------------------\n");
X printf("Use the right mouse button to select object to modify.\n");
X printf("A & Z : rotate around the X axis\n");
X printf("K & L : rotate around the Y axis\n");
X 
X /* Init */
X glutInit(&argc, argv);
X glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X glutCreateWindow ("Teapot, Sphere & Cube");
X myInit ();
X glutKeyboardFunc(Key);
X glutReshapeFunc (myReshape);
X glutDisplayFunc(display);
X 
X /* Set up right button menu */
X glutCreateMenu(Select);
X glutAddMenuEntry("Cube", 1);
X glutAddMenuEntry("Sphere", 2);
X glutAddMenuEntry("Teapot", 3);
X glutAddMenuEntry("Camera", 4);
X glutAddMenuEntry("Reset Scene", 5);
X glutAddMenuEntry("Quit", 20);
X glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206180197 'hw1.c' &&
  chmod 0664 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
c282a4368bb6a7ea39e2aa4a8650c950  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 5543 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '5543,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh128104
exit 0

From ???@??? Fri Feb 07 07:34:25 1997
Received: from vcmr-13.rcs.rpi.edu (pedrih@vcmr-13.rcs.rpi.edu [128.113.113.34])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA38370
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:42:33 -0500
From: Helio Pedrini <pedrih>
Received: (pedrih@localhost) by vcmr-13.rcs.rpi.edu (SMI-8.6/8.6.4) id XAA17214 for citrit@rpi.edu; Thu, 6 Feb 1997 23:42:30 -0500
Date: Thu, 6 Feb 1997 23:42:30 -0500
Message-Id: <199702070442.XAA17214@vcmr-13.rcs.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 85ddf12a8a7b42ab367833a9c1865693

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:40 EST by <pedrih@vcmr-13.rcs.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/75/pedrih/RPI_courses.dir/DV.dir/assign1.dir'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   7229 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh16973; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X * Advanced Computer Graphics and Data Visualization
X *
X * Homework 1
X *
X * Instructor: Thomas D. Citriniti
X *
X * Student: Helio Pedrini
X *
X * This program implements the following features:
X * 
X * - open a window with a double buffered visual;
X * - draw three objects: a solid red cube with a shiny surface,
X *   a solid blue sphere 2 units to the right of the cube with a rough surface,
X *   and a yellow teapot 2 units to the left of the cube;
X * - allow movement of the viewpoint of the observer (camera point);
X * - scale, translate, and rotate each object independent of the others (extra credit).
*/
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
#define   TEAPOT   1
#define   CUBE     2
#define   SPHERE   3
X
int OBJECT = TEAPOT            /* define an object (default is teapot) */;
X
float angle=0, rx, ry, rz,     /* rotation parameters    */
X      sc=1,                    /* scaling parameter      */
X      dx=0, dy=0, dz=0;        /* translation parameters */
X
/*
X *  Define lights, materials, colors;
X *  Draw objects;
X */
X void display(void)
{
X      GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
X
X      GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 }; 
X      GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 }; 
X      GLfloat mat_diffuse[] = { 0.5, 0.5, 0.5, 1.0 }; 
X
X      GLfloat mat_specular[] = { 0.0, 1.0, 1.0, 1.0 }; 
X      
X      GLfloat no_shininess[] = { 0.0 }; 
X      GLfloat low_shininess[] = { 5.0 }; 
X      GLfloat high_shininess[] = { 120.0 }; 
X      
X      GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};
X
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
X      
X      glPushMatrix();
X      glScalef(0.5, 0.5, 0.5);
X       
X      glEnable(GL_COLOR_MATERIAL);
X      
X      glPushMatrix();
X        glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X        glColor3f(1.0, 0.0, 0.0);
X        glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
X        if (OBJECT==CUBE) {
X          glScalef(sc, sc, sc);
X          glTranslatef(dx, dy, dz);
X          glRotatef(angle, rx, ry, rz);
X        }
X        glutSolidCube(1.0);                                      /* draw the cube */
X      glPopMatrix();
X
X      glPushMatrix();
X        glTranslatef(-3.0, 0.0, 0.0);
X        glColor3f(1.0, 1.0, 0.0);
X        if (OBJECT==TEAPOT) {
X          glScalef(sc, sc, sc);
X          glTranslatef(dx, dy, dz);
X          glRotatef(angle, rx, ry, rz);
X        }
X        glutSolidTeapot(1.0);                                    /* draw the teapot */
X      glPopMatrix();
X
X      glPushMatrix();
X        glTranslatef(2.5, 0.0, 0.0);
X        glColor3f(0.0, 0.0, 1.0);
X        glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X        glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X        glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X        glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
X        glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
X        if (OBJECT==SPHERE) {
X          glScalef(sc, sc, sc);
X          glTranslatef(dx, dy, dz);
X          glRotatef(angle, rx, ry, rz);
X        }
X        glutSolidSphere(1.0, 360, 360);                          /* draw the sphere */
X      glPopMatrix();
X       
X      glDisable(GL_COLOR_MATERIAL);
X      glPopMatrix();
X      glutSwapBuffers();
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X      glClearColor (0.0, 0.0, 0.0, 0.0);
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void 
myReshape(int w, int h)
{
X    glViewport(0, 0 , w, h);
X    glMatrixMode(GL_PROJECTION);
X    glLoadIdentity();
X    if (w <= h)
X        glOrtho(-2.5, 2.5, -2.5 * (GLfloat) h / (GLfloat) w,
X            2.5 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
X    else
X        glOrtho(-2.5 * (GLfloat) w / (GLfloat) h,
X            2.5 * (GLfloat) w / (GLfloat) h, -2.5, 2.5, -10.0, 10.0);
X    glMatrixMode(GL_MODELVIEW);
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':                    /* keys for rotation: 'h', 'j', 'k', 'l' */
X      angle+=15.0;
X      rx=0.0; ry=1.0; rz=0.0;
X      sc=1.0;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case 'j':
X      angle+=15.0;
X      rx=1.0; ry=0.0; rz=0.0;
X      sc=1.0;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case 'k':
X      angle+=-15.0;
X      rx=1.0; ry=0.0; rz=0.0;
X      sc=1.0;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case 'l':
X      angle+=-15.0;
X      rx=0.0; ry=1.0; rz=0.0;
X      sc=1.0;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case '-':                    /* keys for scaling: '-', '+' */
X      angle+=0.0;
X      sc/=1.2;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case '+':     
X      angle+=0.0;
X      sc*=1.2;
X      dx=0.0; dy=0.0; dz=0.0;
X      break;
X    case '<':                    /* keys for translation: '<', '>'*/
X      angle+=0.0;
X      sc*=1.0;
X      dx-=0.2; dy-=0.2; dz-=0.2;
X      break;
X    case '>':     
X      angle+=0.0;
X      sc*=1.0;
X      dx+=0.2; dy+=0.2; dz+=0.2;
X      break;
X    case 27:                     /* Esc will quit */
X      exit(1);
X      break;
X    default:
X      break;
X    }
X    display();
}
X
/*
X *  Handle SubMenu (Transformation of the objects: scaling, translation, rotation)
X */
X void
Transform_select(int value)
{
X    OBJECT=value;       /* select object (mouse) */
}
X
/*
X *  Handle Main Menu
X */
void
Select(int value)
{
X    switch (value) {
X    case 2:                                    /* move viewpoint of the observer */
X        gluLookAt(1, 0, 0, 0, 1, 1, 0, 1, 0);
X        display();
X        break;
X    case 3:                                    /* Quit */
X        exit(0);
X        break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X  int transform_menu;
X
X      glutInit(&argc, argv);
X      glutInitWindowPosition(500, 500);
X      glutInitWindowSize(500, 500);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X          
X      transform_menu = glutCreateMenu(Transform_select);
X      glutAddMenuEntry("Teapot", 1);
X      glutAddMenuEntry("Cube", 2);
X      glutAddMenuEntry("Sphere", 3);
X 
X      glutCreateMenu(Select);
X      glutAddSubMenu("Transform Objects", transform_menu);
X      glutAddMenuEntry("Move Viewpoint", 2);
X      glutAddMenuEntry("Quit", 3);
X      
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206233597 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
8c7a1513d157af260606b98a7e8d834f  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 7229 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '7229,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh16973
exit 0

From ???@??? Fri Feb 07 07:32:58 1997
Received: from act3.bme.rpi.edu (jainh@act3.bme.rpi.edu [128.113.12.16])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id PAA34974
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 15:21:13 -0500
From: Hemant Jain <jainh>
Received: (jainh@localhost) by act3.bme.rpi.edu (8.6.9/8.6.4) id PAA03888 for citrit@rpi.edu; Thu, 6 Feb 1997 15:21:11 -0500
Date: Thu, 6 Feb 1997 15:21:11 -0500
Message-Id: <199702062021.PAA03888@act3.bme.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: 6fe09cea6db6421b46a30e1c2d26dea3

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 15:20 EST by <jainh@act3.bme.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/92/jainh/courses/GraphVis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    323 -rw------- Makefile
#   8026 -rw------- draw_obj.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh03879; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
CC=acc
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	-lMesaaux -lglut -lMesatk -lMesaGLU -lMesaGL  \
X	-L/usr/local/X11/lib -lXmu -lXt -lX11 -lm
X
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include
X
TARGET=draw_obj
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0206151397 'Makefile' &&
  chmod 0600 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
da19f4dd2e9bd031984a8e91a8d44f71  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 323 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '323,' 'current size' "$shar_count!"
  fi
fi
# ============= draw_obj.c ==============
if test -f 'draw_obj.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'draw_obj.c' '(file already exists)'
else
  $echo 'x -' extracting 'draw_obj.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'draw_obj.c' &&
#include <GL/gl.h>
#include <GL/glut.h>
X
X        GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
X        GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };
X        GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };
X        GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };
X        GLfloat mat_specular[] = { 0.7, 0.7, 0.7, 1.0 };
X        GLfloat no_shininess[] = { 0.0 };
X        GLfloat low_shininess[] = { 5.0 };
X        GLfloat high_shininess[] = { 100.0 };
X        GLfloat mat_emission[] = {0.1, 0.1, 0.1, 1.0};
X
static int main_win;
static int buffer = 2;
X
/**
flags for different states. changed using Menu.
**/
static int flag_T = 0, flag_C = 1, flag_S = 0, flag_V = 0; 
X
/****
X Define state as 3-element array. 1st element = X translation,
X 2nd element = Rotation around x-axis,
X 3rd element = Rotation around y-axis.
*****/
static int Cube_state[] = {0, 0, 0}; 
static int Sphere_state[] = {+2, 0, 0}; 
static int Teapot_state[] = {-2, 0, 0}; 
X
void display_C(void)
{
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, no_mat);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, mat_emission);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, high_shininess);
X      glColor3f(1.0, 0.0, 0.0);
X      glutSolidCube(1.0);
}
X
void display_S(void)
{
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, no_mat);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, no_mat);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, no_mat);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, no_shininess);
X      glColor3f(0.0, 0.0, 1.0);
X      glutSolidSphere(0.75, 25, 25);   
}
X
void display_T(void)
{
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, no_mat);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, mat_emission);
X      glColor3f(1.0, 1.0, 0.0);
X      glutSolidTeapot(0.7);
}
X
X
void display(void)
{
X        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X        glEnable(GL_COLOR_MATERIAL);
X        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
X        
X        glPushMatrix();
X        glLoadIdentity();
X        glTranslatef ( (GLfloat) Cube_state[0] , 0.0, 0.0);
X        glRotatef ( (GLfloat) Cube_state[1] , 1.0, 0.0, 0.0);
X        glRotatef ( (GLfloat) Cube_state[2] , 0.0, 1.0, 0.0);
X        display_C();
X        glPopMatrix();
X
X        glPushMatrix();
X        glLoadIdentity();
X        glTranslatef ( (GLfloat) Sphere_state[0] , 0.0, 0.0);
X        glRotatef ( (GLfloat) Sphere_state[1] , 1.0, 0.0, 0.0);
X        glRotatef ( (GLfloat) Sphere_state[2] , 0.0, 1.0, 0.0);
X        display_S();
X        glPopMatrix();
X
X        glPushMatrix();
X        glLoadIdentity();
X        glTranslatef ( (GLfloat) Teapot_state[0] , 0.0, 0.0);
X        glRotatef ( (GLfloat) Teapot_state[1] , 1.0, 0.0, 0.0);
X        glRotatef ( (GLfloat) Teapot_state[2] , 0.0, 1.0, 0.0);
X        display_T();
X        glPopMatrix();
X
X        glDisable(GL_COLOR_MATERIAL);
X        
X     if (buffer == 2)
X      glutSwapBuffers(); 
X     else if (buffer == 1)
X      glFlush();
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glClearColor(0.0, 0.0, 0.0, 1.0);
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X      glShadeModel(GL_FLAT);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X
X    switch (key) {
X    case 'x':
X    if (flag_C == 1) 
X      Cube_state[1] += 10; 
X    if (flag_S == 1) 
X      Sphere_state[1] += 10; 
X    if (flag_T == 1) 
X      Teapot_state[1] += 10; 
X    if (flag_V == 1) 
X      {
X       glMatrixMode(GL_PROJECTION);
X       glRotatef(5.0, 1.0, 0.0, 0.0);
X       glMatrixMode (GL_MODELVIEW);       
X      }
X      break;
X    case 'y':
X    if (flag_C == 1) 
X      Cube_state[2] += 10; 
X    if (flag_S == 1) 
X      Sphere_state[2] += 10; 
X    if (flag_T == 1) 
X      Teapot_state[2] += 10; 
X    if (flag_V == 1) 
X      {
X       glMatrixMode(GL_PROJECTION);
X       glRotatef(5.0, 0.0, 1.0, 0.0);
X       glMatrixMode (GL_MODELVIEW);      
X      }
X      break;
X    case 'i':
X    if (flag_C == 1)
X      Cube_state[1] -= 10;
X    if (flag_S == 1)
X      Sphere_state[1] -= 10;
X    if (flag_T == 1)
X      Teapot_state[1] -= 10;
X    if (flag_V == 1)
X      {
X       glMatrixMode(GL_PROJECTION);
X       glRotatef(-5.0, 1.0, 0.0, 0.0);
X       glMatrixMode (GL_MODELVIEW);    
X      }
X      break;
X    case 'j':
X    if (flag_C == 1)
X      Cube_state[2] -= 10;
X    if (flag_S == 1)
X      Sphere_state[2] -= 10;
X    if (flag_T == 1)
X      Teapot_state[2] -= 10;
X    if (flag_V == 1)
X      {
X       glMatrixMode(GL_PROJECTION);
X       glRotatef(-5.0, 0.0, 1.0, 0.0);
X       glMatrixMode (GL_MODELVIEW);   
X      }
X      break;
/**********
X To switch between Single and Double buffer.
X Doesn't seem to work right now!
**********/
X    case 'b':
X        if (buffer == 2) {
X         buffer = 1;
X         glutInitDisplayMode (GLUT_SINGLE | GLUT_RGBA);
X         }
X        else if (buffer == 1){
X          buffer = 2;
X         glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X         }
X
X        break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        flag_T = 1;
X        flag_C = 0;
X        flag_S = 0;
X        flag_V = 0;
X        break;
X    case 2:
X        flag_T = 0;
X        flag_C = 1;
X        flag_S = 0;
X        flag_V = 0;
X        break;
X    case 3:
X        flag_T = 0;
X        flag_C = 0;
X        flag_S = 1;
X        flag_V = 0;
X        break;
X    case 4:
X        flag_T = 0;
X        flag_C = 0;
X        flag_S = 0;
X        flag_V = 1;
X        break;
X    case 5:
X        exit(0);
X        break;
X    }
}
X
void print_usage()
{
X printf("\n\n"
X        "Use the Right Mouse button for Menu:\n"
X        "   Select an object or Camera view point.\n"
X        "Following Keys can be used to manuplate different objects:\n"
X        "--- 'x' and 'y' to rotate clockwise around these axes.\n"
X        "--- 'i' and 'j' to rotate anticlockwise.\n"
X        "--- 'b' to toggle between the buffer modes.\n");
}
X
/*
X *  Main Loop
X */
int main(int argc, char** argv) 
{
X      print_usage();
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      main_win = glutCreateWindow (argv[0]);
X      glutReshapeWindow(400,200);
X      myInit();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("TeaPot", 1);
X      glutAddMenuEntry("Cube", 2);
X      glutAddMenuEntry("Sphere", 3);
X      glutAddMenuEntry("Camera", 4);
X      glutAddMenuEntry("Quit", 5);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206151697 'draw_obj.c' &&
  chmod 0600 'draw_obj.c' ||
  $echo 'restore of' 'draw_obj.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'draw_obj.c:' 'MD5 check failed'
781674460dfb035252f26aebae12fdea  draw_obj.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'draw_obj.c'`"
    test 8026 -eq "$shar_count" ||
    $echo 'draw_obj.c:' 'original size' '8026,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh03879
exit 0

From ???@??? Fri Feb 07 07:33:22 1997
Received: from magritte.its.rpi.edu (younh@magritte.its.rpi.edu [128.113.113.19])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id TAA33182
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 19:17:56 -0500
From: Hyung-Jun Brutus Youn <younh>
Received: (younh@localhost) by magritte.its.rpi.edu (8.6.9/8.6.4) id TAA191720 for citrit@rpi.edu; Thu, 6 Feb 1997 19:17:55 -0500
Date: Thu, 6 Feb 1997 19:17:55 -0500
Message-Id: <199702070017.TAA191720@magritte.its.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: 6b637942a823bc7f13152fb941f66f11

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:17 EST by <younh@magritte>.
# Source directory was `/afs/rpi.edu/home/29/younh/Visualization'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   8779 -rwxr--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh94634; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 hw1.c
M+RH-"B`J"B`J($)R=71U<R!9;W5N"B`J($=R87!H:6-S(&%N9"!6:7-U86QI
M>F%T:6]N"B`J($A7(",Q"B`J"B`J"B`J+PH*+RH@26YC;'5D97,@<F5Q=6ER
M960@*B\-"B-I;F-L=61E(#QS=&1L:6(N:#X-"B-I9F1E9B!?5TE.,S(-"B-I
M;F-L=61E(#QW:6YD;W=S+F@^#0HC96YD:68*(VEN8VQU9&4@/$=,+V=L+F@^
M"B-I;F-L=61E(#Q'3"]G;'5T+F@^"@T*($=,9FQO870@;F]?;6%T6UT@/2![
M(#`N,"P@,"XP+"`P+C`L(#$N,"!].PT*($=,9FQO870@;6%T7V%M8FEE;G1;
M72`]('L@,"XW+"`P+C<L(#`N-RP@,2XP('T[(`T*($=,9FQO870@;6%T7V%M
M8FEE;G1?8V]L;W);72`]('L@,"XX+"`P+C@L(#`N,BP@,2XP('T[("`@("`@
M(`T*($=,9FQO870@;6%T7V1I9F9U<V5;72`]('L@,"XQ+"`P+C4L(#`N."P@
M,2XP('T[(`T*($=,9FQO870@;6%T7W-P96-U;&%R6UT@/2![(#$N,"P@,2XP
M+"`Q+C`L(#$N,"!].R`-"B!'3&9L;V%T(&YO7W-H:6YI;F5S<UM=(#T@>R`P
M+C`@?3L@#0H@1TQF;&]A="!L;W=?<VAI;FEN97-S6UT@/2![(#4N,"!].R`-
M"B!'3&9L;V%T(&AI9VA?<VAI;FEN97-S6UT@/2![(#$P,"XP('T[(`T*($=,
M9FQO870@;6%T7V5M:7-S:6]N6UT@/2![,"XS+"`P+C(L(#`N,BP@,"XP?3L@
M(`T*#0H@:6YT(&]B:F5C="`](#`[#0H@:6YT(')O=')I9VAT6S-=(#T@>S`L
M(#`L(#!].PT*(&EN="!R;W1D;W=N6S-=(#T@>S`L(#`L(#!].PT*(&EN="!R
M;W1U<%LS72`]('LP+"`P+"`P?3L-"B!I;G0@<F]T;&5F=%LS72`]('LP+"`P
M+"`P?3L-"B!I;G0@;6]V<FEG:'1;,UT@/2![,"P@,"P@,'T[#0H@:6YT(&UO
M=F1O=VY;,UT@/2![,"P@,"P@,'T[#0H@:6YT(&UO=G5P6S-=(#T@>S`L(#`L
M(#!].PT*(&EN="!M;W9L969T6S-=(#T@>S`L(#`L(#!].PT*(&EN="!S8V%L
M975P6S-=(#T@>S`L(#`L(#!].PT*(&EN="!S8V%L961O=VY;,UT@/2![,"P@
M,"P@,'T[#0H@#0H@:6YT(&D[#0H-"@HO*@H@*B`@0VQE87(@=&AE('-C<F5E
M;BX@(%-E="!T:&4@8W5R<F5N="!C;VQO<B!T;R!W:&ET92X*("H@($1R87<@
M=&AE(&-U8F4N"B`J+PIV;VED(&1I<W!L87DH=F]I9"D*>PT*"2`@9VQ%;F%B
M;&4H1TQ?3$E'2%1)3D<I.PT*("`@("`@9VQ%;F%B;&4H1TQ?3$E'2%0P*3L*
M("`@("`@9VQ#;&5A<BA'3%]#3TQ/4E]"549&15)?0DE4('P@1TQ?1$505$A?
M0E5&1D527T))5"D[#0H@("`@("!G;$-O;&]R36%T97)I86PH1TQ?1E)/3E0L
M($=,7T%-0DE%3E1?04Y$7T1)1D954T4I.R`-"B`@("`@(&=L16YA8FQE*$=,
M7T-/3$]27TU!5$5224%,*3L-"B`@("`@(&=L0V]L;W(S9B@P+C@L(#`N,"P@
M,"XP*3L@+RH@4V5T(&-O;&]R(%)%1"`J+PT*"2`@9VQ-871E<FEA;&9V*$=,
M7T923TY47T%.1%]"04-++$=,7T%-0DE%3E1?04Y$7T1)1D954T4L(&UA=%]A
M;6)I96YT*3L-"@D@(&=L36%T97)I86QF=BA'3%]&4D].5"P@1TQ?1$E&1E53
M12P@;6%T7V1I9F9U<V4I.PT*("`@("`@9VQ-871E<FEA;&9V*$=,7T923TY4
M+"!'3%]34$5#54Q!4BP@;6%T7W-P96-U;&%R*3L-"B`@("`@(&=L36%T97)I
M86QF=BA'3%]&4D].5"P@1TQ?4TA)3DE.15-3+"!H:6=H7W-H:6YI;F5S<RD[
M#0H@("`@("!G;$UA=&5R:6%L9G8H1TQ?1E)/3E0L($=,7T5-25-324].+"!N
M;U]M870I.PT*"2`@9VQ0=7-H36%T<FEX*"D[#0H)("`-"@D@(&9O<B`H:3TP
M.R!I/#UR;W1R:6=H=%LP73L@:2LK*0D@("\J(%)O=&%T92!/8FIE8W0@:6X@
M4W!A8V4@*B\-"@D@("!G;%)O=&%T968H,34N,"P@,"XP+"`Q+C`L(#`N,"D[
M#0H)("`-"@D@(&9O<B`H:3TP.R!I/#UR;W1L969T6S!=.R!I*RLI#0H)("`@
M9VQ2;W1A=&5F*"TQ-2XP+"`P+C`L(#$N,"P@,"XP*3L-"@T*"2`@9F]R("AI
M/3`[(&D\/7)O=&1O=VY;,%T[(&DK*RD-"@D@("!G;%)O=&%T968H,34N,"P@
M,2XP+"`P+C`L(#`N,"D[#0H-"B`@("`@(&9O<B`H:3TP.R!I/#UR;W1U<%LP
M73L@:2LK*0T*"2`@(&=L4F]T871E9B@M,34N,"P@,2XP+"`P+C`L(#`N,"D[
M#0H-"B`)("!F;W(@*&D],#L@:3P];6]V<FEG:'1;,%T[(&DK*RD)("`O*B!-
M;W9E($]B:F5C="!I;B!3<&%C92`J+PT*"2`@(&=L5')A;G-L871E9B@P+C(L
M(#`N,"P@,"XP*3L-"@D@(`T*"2`@9F]R("AI/3`[(&D\/6UO=FQE9G1;,%T[
M(&DK*RD-"@D@("!G;%1R86YS;&%T968H+3`N,BP@,"XP+"`P+C`I.PT*#0H)
M("!F;W(@*&D],#L@:3P];6]V9&]W;ELP73L@:2LK*0T*"2`@(&=L5')A;G-L
M871E9B@P+C`L("TP+C(L(#`N,"D[#0H-"B`@("`@(&9O<B`H:3TP.R!I/#UM
M;W9U<%LP73L@:2LK*0T*"2`@(&=L5')A;G-L871E9B@P+C`L(#`N,BP@,"XP
M*3L-"@T*"2`@9F]R("AI/3`[(&D\/7-C86QE9&]W;ELP73L@:2LK*2`@("`@
M+RH@4V-A;&4@3V)J96-T("HO#0H)("`@9VQ38V%L968H,"XX+"`P+C@L(#`N
M."D[#0H-"B`@("`@(&9O<B`H:3TP.R!I/#US8V%L975P6S!=.R!I*RLI#0H)
M("`@9VQ38V%L968H,2XR+"`Q+C(L(#$N,BD[#0H-"@D@(&=L=713;VQI9$-U
M8F4H,2XP*3L@("`O*B`@9')A=R!T:&4@8W5B92`@("`@("`J+PT*"2`@9VQ0
M;W!-871R:7@H*3L-"@D@(`T*"2`@9VQ#;VQO<DUA=&5R:6%L*$=,7T923TY4
M+"!'3%]!34))14Y47T%.1%]$249&55-%*3L@#0H@("`@("!G;$5N86)L92A'
M3%]#3TQ/4E]-051%4DE!3"D[#0H@("`@("!G;$-O;&]R,V8H,"XP+"`P+C`L
M(#`N."D[("\J(%-E="!C;VQO<B!"3%5%("HO#0H)("!G;$UA=&5R:6%L9G8H
M1TQ?1E)/3E0L1TQ?04U"245.5%]!3D1?1$E&1E5312P@;6%T7V%M8FEE;G0I
M.PT*"2`@9VQ-871E<FEA;&9V*$=,7T923TY4+"!'3%]$249&55-%+"!M871?
M9&EF9G5S92D[#0H@("`@("!G;$UA=&5R:6%L9G8H1TQ?1E)/3E0L($=,7U-0
M14-53$%2+"!N;U]M870I.PT*("`@("`@9VQ-871E<FEA;&9V*$=,7T923TY4
M+"!'3%]32$E.24Y%4U,L(&YO7W-H:6YI;F5S<RD[#0H@("`@("!G;$UA=&5R
M:6%L9G8H1TQ?1E)/3E0L($=,7T5-25-324].+"!N;U]M870I.PT*"2`@9VQ0
M=7-H36%T<FEX*"D[#0H@("`@("!G;%1R86YS;&%T968@*#(N-2P@,"XP+"`P
M+C`I.PT*"2`@#0H)("!F;W(@*&D],#L@:3P]<F]T<FEG:'1;,5T[(&DK*RD)
M("`O*B!2;W1A=&4@3V)J96-T(&EN(%-P86-E("HO#0H)("`@9VQ2;W1A=&5F
M*#$U+C`L(#`N,"P@,2XP+"`P+C`I.PT*"2`@#0H)("!F;W(@*&D],#L@:3P]
M<F]T;&5F=%LQ73L@:2LK*0T*"2`@(&=L4F]T871E9B@M,34N,"P@,"XP+"`Q
M+C`L(#`N,"D[#0H-"@D@(&9O<B`H:3TP.R!I/#UR;W1D;W=N6S%=.R!I*RLI
M#0H)("`@9VQ2;W1A=&5F*#$U+C`L(#$N,"P@,"XP+"`P+C`I.PT*#0H@("`@
M("!F;W(@*&D],#L@:3P]<F]T=7!;,5T[(&DK*RD-"@D@("!G;%)O=&%T968H
M+3$U+C`L(#$N,"P@,"XP+"`P+C`I.PT*"2`@#0H@"2`@9F]R("AI/3`[(&D\
M/6UO=G)I9VAT6S%=.R!I*RLI"2`@+RH@36]V92!/8FIE8W0@:6X@4W!A8V4@
M*B\-"@D@("!G;%1R86YS;&%T968H,"XR+"`P+C`L(#`N,"D[#0H)("`-"@D@
M(&9O<B`H:3TP.R!I/#UM;W9L969T6S%=.R!I*RLI#0H)("`@9VQ4<F%N<VQA
M=&5F*"TP+C(L(#`N,"P@,"XP*3L-"@T*"2`@9F]R("AI/3`[(&D\/6UO=F1O
M=VY;,5T[(&DK*RD-"@D@("!G;%1R86YS;&%T968H,"XP+"`M,"XR+"`P+C`I
M.PT*#0H@("`@("!F;W(@*&D],#L@:3P];6]V=7!;,5T[(&DK*RD-"@D@("!G
M;%1R86YS;&%T968H,"XP+"`P+C(L(#`N,"D[#0H-"@D@(&9O<B`H:3TP.R!I
M/#US8V%L961O=VY;,5T[(&DK*RD@("`@("\J(%-C86QE($]B:F5C="`J+PT*
M"2`@(&=L4V-A;&5F*#`N."P@,"XX+"`P+C@I.PT*#0H@("`@("!F;W(@*&D]
M,#L@:3P]<V-A;&5U<%LQ73L@:2LK*0T*"2`@(&=L4V-A;&5F*#$N,BP@,2XR
M+"`Q+C(I.PT*#0H)("`-"@D@(&=L=713;VQI9%-P:&5R92@Q+C`L(#(P+C`L
M(#(P+C`I.R`@("\J("!D<F%W('1H92!S<&AE<F4@("`@("`@*B\-"@D@(&=L
M4&]P36%T<FEX*"D[#0H-"@D@(&=L0V]L;W)-871E<FEA;"A'3%]&4D].5"P@
M1TQ?04U"245.5%]!3D1?1$E&1E5312D[(`T*("`@("`@9VQ%;F%B;&4H1TQ?
M0T],3U)?34%415))04PI.PT*("`@("`@9VQ#;VQO<C-F*#`N."P@,"XX+"`P
M+C`I.R`O*B!3970@8V]L;W(@645,3$]7("HO#0H)("!G;$UA=&5R:6%L9G8H
M1TQ?1E)/3E1?04Y$7T)!0TLL($=,7T%-0DE%3E1?04Y$7T1)1D954T4L(&UA
M=%]A;6)I96YT*3L-"@D@(&=L36%T97)I86QF=BA'3%]&4D].5"P@1TQ?1$E&
M1E5312P@;F]?;6%T*3L-"B`@("`@(&=L36%T97)I86QF=BA'3%]&4D].5"P@
M1TQ?4U!%0U5,05(L(&UA=%]S<&5C=6QA<BD[#0H@("`@("!G;$UA=&5R:6%L
M9G8H1TQ?1E)/3E0L($=,7U-(24Y)3D534RP@:&EG:%]S:&EN:6YE<W,I.PT*
M("`@("`@9VQ-871E<FEA;&9V*$=,7T923TY4+"!'3%]%34E34TE/3BP@;F]?
M;6%T*3L-"@D@(&=L4'5S:$UA=')I>"@I.PT*("`@("`@9VQ4<F%N<VQA=&5F
M("@M,BXU+"`P+C`L(#`N,"D[#0H)("`-"@D@(&9O<B`H:3TP.R!I/#UR;W1R
M:6=H=%LR73L@:2LK*0D@("`O*B!2;W1A=&4@3V)J96-T(&EN(%-P86-E("HO
M#0H)("`@9VQ2;W1A=&5F*#$U+C`L(#`N,"P@,2XP+"`P+C`I.PT*"2`@#0H)
M("!F;W(@*&D],#L@:3P]<F]T;&5F=%LR73L@:2LK*0T*"2`@(&=L4F]T871E
M9B@M,34N,"P@,"XP+"`Q+C`L(#`N,"D[#0H-"@D@(&9O<B`H:3TP.R!I/#UR
M;W1D;W=N6S)=.R!I*RLI#0H)("`@9VQ2;W1A=&5F*#$U+C`L(#$N,"P@,"XP
M+"`P+C`I.PT*#0H@("`@("!F;W(@*&D],#L@:3P]<F]T=7!;,ET[(&DK*RD-
M"@D@("!G;%)O=&%T968H+3$U+C`L(#$N,"P@,"XP+"`P+C`I.PT*#0H@"2`@
M9F]R("AI/3`[(&D\/6UO=G)I9VAT6S)=.R!I*RLI"2`@+RH@36]V92!/8FIE
M8W0@:6X@4W!A8V4@*B\-"@D@("!G;%1R86YS;&%T968H,"XR+"`P+C`L(#`N
M,"D[#0H)("`-"@D@(&9O<B`H:3TP.R!I/#UM;W9L969T6S)=.R!I*RLI#0H)
M("`@9VQ4<F%N<VQA=&5F*"TP+C(L(#`N,"P@,"XP*3L-"@T*"2`@9F]R("AI
M/3`[(&D\/6UO=F1O=VY;,ET[(&DK*RD-"@D@("!G;%1R86YS;&%T968H,"XP
M+"`M,"XR+"`P+C`I.PT*#0H@("`@("!F;W(@*&D],#L@:3P];6]V=7!;,ET[
M(&DK*RD-"@D@("!G;%1R86YS;&%T968H,"XP+"`P+C(L(#`N,"D[#0H-"@D@
M(&9O<B`H:3TP.R!I/#US8V%L961O=VY;,ET[(&DK*RD@("`@("\J(%-C86QE
M($]B:F5C="`J+PT*"2`@(&=L4V-A;&5F*#`N."P@,"XX+"`P+C@I.PT*#0H@
M("`@("!F;W(@*&D],#L@:3P]<V-A;&5U<%LR73L@:2LK*0T*"2`@(&=L4V-A
M;&5F*#$N,BP@,2XR+"`Q+C(I.PT*#0H)("`-"@D@(&=L=713;VQI9%1E87!O
M="@Q+C`I.R`@("\J("!D<F%W('1H92!T96%P;W0@("`@("`J+PT*"2`@9VQ0
M;W!-871R:7@H*3L-"@T*"2`@9VQU=%-W87!"=69F97)S*"D[(`I]"@HO*B!)
M;FET:6%L:7IE('-H861I;F<@;6]D96P@*B\*=F]I9"!M>4EN:70H=F]I9"D*
M>PH@("`@("!S=&%T:6,@9FQO870@;&EG:'10;W-;-%T@/2![,BXP+"`T+C`L
M(#(N,"P@,2XP?3L*("`@("`@<W1A=&EC(&9L;V%T(&QI9VAT1&ER6S1=(#T@
M>RTR+C`L("TT+C`L("TR+C`L(#$N,'T["B`@("`@('-T871I8R!F;&]A="!L
M:6=H=$%M8ELT72`]('LP+C<L(#`N-RP@,"XW+"`Q+C!].PH@("`@("!S=&%T
M:6,@9FQO870@;&EG:'1$:69F6S1=(#T@>S`N."P@,"XX+"`P+C@L(#$N,'T[
M"B`@("`@('-T871I8R!F;&]A="!L:6=H=%-P96-;-%T@/2![,"XT+"`P+C0L
M(#`N-"P@,2XP?3L*"B`@("`@(&=L0V]L;W(S9B@Q+C`L(#`N,"P@,"XP*3L*
M("`@("`@9VQ%;F%B;&4H1TQ?3$E'2%1)3D<I.PH@("`@("!G;$5N86)L92A'
M3%],24=(5#`I.PH@("`@("!G;$QI9VAT9G8H1TQ?3$E'2%0P+"!'3%]03U-)
M5$E/3BP@;&EG:'10;W,I.PH@("`@("!G;$QI9VAT9G8H1TQ?3$E'2%0P+"!'
M3%]!34))14Y4+"!L:6=H=$%M8BD["B`@("`@(&=L3&EG:'1F=BA'3%],24=(
M5#`L($=,7T1)1D954T4L(&QI9VAT1&EF9BD["B`@("`@(&=L3&EG:'1F=BA'
M3%],24=(5#`L($=,7U-014-53$%2+"!L:6=H=%-P96,I.PH@("`@("!G;$5N
M86)L92A'3%]$15!42%]415-4*3L*("`@("`@9VQ3:&%D94UO9&5L("A'3%]&
M3$%4*3L*("`@("`@9VQ#;&5A<D-O;&]R("@P+C`L(#`N,"P@,"XP+"`P+C`I
M.PI]#0H*+RH*("H@($-A;&QE9"!W:&5N('1H92!W:6YD;W<@:7,@9FER<W0@
M;W!E;F5D(&%N9"!W:&5N979E<B`*("H@('1H92!W:6YD;W<@:7,@<F5C;VYF
M:6=U<F5D("AM;W9E9"!O<B!R97-I>F5D*2X*("HO"G9O:60@;7E297-H87!E
M*&EN="!W+"!I;G0@:"D*>PH@("`@("!G;%9I97=P;W)T("@P+"`P+"!W+"!H
M*3L@("`@("`@("`@("`O*B`@9&5F:6YE('1H92!V:65W<&]R="`J+PH@("`@
M("!G;$UA=')I>$UO9&4H1TQ?4%)/2D5#5$E/3BD["B`@("`@(&=L3&]A9$ED
M96YT:71Y*"D["B`@("`@(&=L=5!E<G-P96-T:79E*#0U+C`L(#$N,"HH1TQF
M;&]A="EW+RA'3&9L;V%T*6@L(#$N,"P@,3`N,"D["B`@("`@(&=L5')A;G-L
M871E9B`H,"XP+"`P+C`L("TU+C`I.R`@("`@+RH@('9I97=I;F<@=')A;G-F
M;W)M871I;VX@("`@("`J+PH@("`@("!G;$UA=')I>$UO9&4@*$=,7TU/1$5,
M5DE%5RD[("`@("`@("`O*B!B86-K('1O(&UO9&5L=FEE=R!M871R:7@@("HO
M"GT*"B\J"B`J($ME>6)O87)D(&AA;F1L97(*("HO"G9O:60*2V5Y*'5N<VEG
M;F5D(&-H87(@:V5Y+"!I;G0@>"P@:6YT('DI"GL*("`@('-W:71C:"`H:V5Y
M*2!["B`@("!C87-E("=K)SH*("`@("`@9VQ-871R:7A-;V1E("A'3%]04D]*
M14-424].*3L@("`@("`@("\J(&UA;FEP=6QA=&4@8V%M97)A=FEE=R!M871R
M:7@@("HO"B`@("`@(&=L4F]T871E9B@Q-2XP+"`P+C`L,2XP+#`N,"D["B`@
M("`@(&)R96%K.PH@("`@8V%S92`G;2<Z"B`@("`@(&=L36%T<FEX36]D92`H
M1TQ?4%)/2D5#5$E/3BD[("`@("`@("`O*B!M86YI<'5L871E(&-A;65R879I
M97<@;6%T<FEX("`J+PH@("`@("!G;%)O=&%T968H,34N,"P@,2XP+#`N,"PP
M+C`I.PH@("`@("!B<F5A:SL*("`@(&-A<V4@)VDG.@H@("`@("!G;$UA=')I
M>$UO9&4@*$=,7U!23TI%0U1)3TXI.R`@("`@("`@+RH@;6%N:7!U;&%T92!C
M86UE<F%V:65W(&UA=')I>"`@*B\*("`@("`@9VQ2;W1A=&5F*"TQ-2XP+"`Q
M+C`L,"XP+#`N,"D["B`@("`@(&)R96%K.PH@("`@8V%S92`G:B<Z"B`@("`@
M(&=L36%T<FEX36]D92`H1TQ?4%)/2D5#5$E/3BD[("`@("`@("`O*B!M86YI
M<'5L871E(&-A;65R879I97<@;6%T<FEX("`J+PH@("`@("!G;%)O=&%T968H
M+3$U+C`L(#`N,"PQ+C`L,"XP*3L*("`@("`@8G)E86L[#0H)8V%S92`G<R<Z
M#0H)("!R;W1R:6=H=%MO8FIE8W1=*RL[#0H@("`@("!B<F5A:SL-"B`@("!C
M87-E("=Z)SH-"@D@(')O=&1O=VY;;V)J96-T72LK.PT*"2`@8G)E86L[#0H@
M("`@8V%S92`G=R<Z#0H)("!R;W1U<%MO8FIE8W1=*RL[#0H)("!B<F5A:SL-
M"B`@("!C87-E("=A)SH-"B`@("`@(')O=&QE9G1;;V)J96-T72LK.PT*("`@
M("`@8G)E86L[#0H)8V%S92`G-B<Z#0H)("!M;W9R:6=H=%MO8FIE8W1=*RL[
M#0H@("`@("!B<F5A:SL-"B`@("!C87-E("<R)SH-"@D@(&UO=F1O=VY;;V)J
M96-T72LK.PT*"2`@8G)E86L[#0H@("`@8V%S92`G."<Z#0H)("!M;W9U<%MO
M8FIE8W1=*RL[#0H)("!B<F5A:SL-"B`@("!C87-E("<T)SH-"B`@("`@(&UO
M=FQE9G1;;V)J96-T72LK.PT*"2`@8G)E86L[#0H)8V%S92`G*R<Z#0H)("!S
M8V%L975P6V]B:F5C=%TK*SL-"@D@(&)R96%K.PT*("`@(&-A<V4@)RTG.@T*
M("`@("`@<V-A;&5D;W=N6V]B:F5C=%TK*SL-"B`@("`@(&)R96%K.PH@("`@
M8V%S92`R-SH@("`@("`@("`@("\J($5S8R!W:6QL('%U:70@*B\*("`@("`@
M("!E>&ET*#$I.PH@("`@("`@(&)R96%K.PH@("`@9&5F875L=#H*("`@("`@
M8G)E86L["B`@("!]"B`@("!G;'5T4&]S=%)E9&ES<&QA>2@I.PI]"@HO*@H@
M*B`@2&%N9&QE($UE;G5S"B`J+PIV;VED"E-E;&5C="AI;G0@=F%L=64I"GL*
M("`@('-W:71C:"`H=F%L=64I('L*("`@(&-A<V4@,3H*("`@("`@("!E>&ET
M*#`I.PH@("`@("`@(&)R96%K.PT*"6-A<V4@,CH-"@D);V)J96-T(#T@,#L-
M"@D)8G)E86L[#0H)8V%S92`S.@T*"0EO8FIE8W0@/2`Q.PT*"0EB<F5A:SL-
M"@EC87-E(#0Z#0H)"6]B:F5C="`](#([#0H*("`@('T*?0H*+RH*("H@($UA
M:6X@3&]O<`H@*B`@3W!E;B!W:6YD;W<@=VET:"!I;FET:6%L('=I;F1O=R!S
M:7IE+"!T:71L92!B87(L(`H@*B`@4D="02!D:7-P;&%Y(&UO9&4L(&%N9"!H
M86YD;&4@:6YP=70@979E;G1S+@H@*B\*:6YT(&UA:6XH:6YT(&%R9V,L(&-H
M87(J*B!A<F=V*2`*>PT*"2`@9VQU=$EN:70H)F%R9V,L(&%R9W8I.PH@("`@
M("!G;'5T26YI=$1I<W!L87E-;V1E("A'3%547T1/54),12!\($=,551?4D="
M02D["B`@("`@(&=L=71#<F5A=&57:6YD;W<@*&%R9W9;,%TI.PT*"2`@9VQU
M=%)E<VAA<&57:6YD;W<@*#8U,"P@,S`P*3L*("`@("`@;7E);FET("@I.PH@
M("`@("!G;'5T2V5Y8F]A<F1&=6YC*$ME>2D["B`@("`@(&=L=71297-H87!E
M1G5N8R`H;7E297-H87!E*3L*("`@("`@9VQU=$1I<W!L87E&=6YC*&1I<W!L
M87DI.PH@("`@("!G;'5T0W)E871E365N=2A396QE8W0I.PT*"2`@9VQU=$%D
M9$UE;G5%;G1R>2@B36%N:7!U;&%T92!#=6)E(BP@,BD[#0H)("!G;'5T061D
M365N=45N=')Y*")-86YI<'5L871E(%-P:&5R92(L(#,I.PT*"2`@9VQU=$%D
M9$UE;G5%;G1R>2@B36%N:7!U;&%T92!496%P;W0B+"`T*3L*("`@("`@9VQU
M=$%D9$UE;G5%;G1R>2@B475I="(L(#$I.PT*"B`@("`@(&=L=71!='1A8VA-
M96YU*$=,551?4DE'2%1?0E545$].*3L*("`@("`@9VQU=$UA:6Y,;V]P*"D[
$"GT*"D=,
`
end
SHAR_EOF
  $shar_touch -am 0206185497 'hw1.c' &&
  chmod 0744 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
0f3fb32af52e3f5b0fbd12e36d0e1b87  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8779 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8779,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh94634
exit 0

From ???@??? Fri Feb 07 07:33:36 1997
Received: from cii3112-16.its.rpi.edu (braunj@cii3112-16.its.rpi.edu [128.113.109.166])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA34652
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:38:33 -0500
From: Jeffrey Howard Braunstein <braunj>
Received: (braunj@localhost) by cii3112-16.its.rpi.edu (8.6.9/8.6.4) id XAA17934 for citrit@rpi.edu; Thu, 6 Feb 1997 23:38:24 -0500
Date: Thu, 6 Feb 1997 23:38:24 -0500
Message-Id: <199702070438.XAA17934@cii3112-16.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: f74e4d2b83185e1f8593fa25231da890

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:37 EST by <braunj@cii3112-16>.
# Source directory was `/afs/rpi.edu/home/90/braunj/datavis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   3513 -rw------- hw1.c
#     97 -rw------- note
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh18692; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X *  Simple2.c 
X *
X *  Simple example of programming using the OpenGL graphics library
X *  Taken from the "OpenGL Programming Guide"
X *
X *
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X      glPushMatrix();
X      glScalef(0.7,0.7,0.7);
X
X      glPushMatrix();
X      glutSolidCube(1.0);   /*  draw the cube       */
X      glPopMatrix();
X
X      glPushMatrix();
X      glTranslatef(-2.0,0.0,0.0);
X      glutSolidCube(1.0);   /*  draw the cube       */
X      glPopMatrix();
X
X      glPushMatrix();
X      glTranslatef(2.0,0.0,0.0);
X      glutSolidCube(1.0);   /*  draw the cube       */
X      glPopMatrix();
X
X      glPopMatrix();
X      glFlush();
X      glutSwapBuffers();
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
/*     glShadeModel (GL_FLAT);
X *     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 1.0,0.0,0.0);
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 0.0,1.0,0.0);
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Quit", 1);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206233797 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
214040ac0b766177184c9cbd5ad2330f  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 3513 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '3513,' 'current size' "$shar_count!"
  fi
fi
# ============= note ==============
if test -f 'note' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'note' '(file already exists)'
else
  $echo 'x -' extracting 'note' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'note' &&
This homework is incomplete and I intend to
hand in the completed project late.
X
Jeff Braunstein
SHAR_EOF
  $shar_touch -am 0206233797 'note' &&
  chmod 0600 'note' ||
  $echo 'restore of' 'note' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'note:' 'MD5 check failed'
77f6a024e8116219ee7a3f195f87a4c5  note
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'note'`"
    test 97 -eq "$shar_count" ||
    $echo 'note:' 'original size' '97,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh18692
exit 0

From ???@??? Fri Feb 07 07:33:35 1997
Received: from magritte.its.rpi.edu (kozurj@magritte.its.rpi.edu [128.113.113.19])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA33256
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:23:30 -0500
From: Johan <kozurj>
Received: (kozurj@localhost) by magritte.its.rpi.edu (8.6.9/8.6.4) id XAA213742 for citrit@rpi.edu; Thu, 6 Feb 1997 23:23:29 -0500
Date: Thu, 6 Feb 1997 23:23:29 -0500
Message-Id: <199702070423.XAA213742@magritte.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: df2647208404151c3b2bab7ccb00372d

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:23 EST by <kozurj@magritte>.
# Source directory was `/afs/rpi.edu/home/96/kozurj/private/visual/proj1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    815 -rw-r----- README
#   8621 -rw-r----- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh35436; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= README ==============
if test -f 'README' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'README' '(file already exists)'
else
  $echo 'x -' extracting 'README' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 README
M5&AE(&9I;&4@<')O:C$N8R!W87,@9&5V96QO<&5D(&%N9"!T97-T960@=&\@
M=V]R:R!O;B!A(%=I;F1O=W,Y-2!P;&%T9F]R;2X@(`I)="!R97%U:7)E<R!T
M:&4@9VQU="P@9VPL(&%N9"!G;'4@;&EB<F%R:65S(&-O;7!I;&5D('1O('=O
M<FL@*&]F(&-O=7)S92DN("`*16%C:"!O9B!T:&4@;V)J96-T<R!A;F0@=&AE
M(&-A;65R82!I<R!I;F1E<&5N9&%N=&QY(&UO=F%B;&4L(')O=&%T86)L92P@
M86YD(`IS8V%L86)L92!T:')O=6=H(&ME>7,@9&ES<&QA>65D(&]N('!R;V=R
M86T@<W1A<G1U<"X@($%D9&ET:6]N86QL>2P@<F]T871I;VX@"F%N9"!T<F%N
M<VQA=&EO;B!C86X@8F4@86-H:65V960@8GD@:&]L9&EN9R!D;W=N('1H92!L
M969T(&]R(')I9VAT(&UO=7-E(`IB=71T;VXL(')E<W!E8W1I=F5L>2P@=&AE
M;B!M;W9I;F<@=&AE(&UO=7-E(&%R;W5N9"!T:&4@<V-R965N+B`@5&\@8VAO
M;W-E(`IW:&EC:"!O8FIE8W0@:7,@8F5I;F<@8VAA;F=E9"P@<')E<W,@,2P@
M,BP@;W(@,R!F;W(@=&AE('1E87!O="P@8W5B92P@;W(@"G-P:&5R92P@;W(@
M<')E<W,@,"!T;R!C:&%N9V4@=&AE(&-A;65R82!P;W-I=&EO;BX@(%1H92!M
M;W1I;VX@=V%S('!R971T>2`*<VUO;W1H(&%N9"!F87-T(&]N(&$@4&5N=&EU
M;3(P,"!P;&%T9F]R;2!W:71H(&$@9G5L;"!W:6YD;W<@=FEE=SL@=&AE(&UO
M=7-E(`IA8W1I;VX@8V]U;&0@8F4@:F5R:WD@;VX@<VQO=V5R('!L871F;W)M
M<RX@($9I;F%L;'DL(&%N(&]B:F5C="!C86X@8F4@;6%D92`*<V5M:2UT<F%N
M<W!A<F5N="!B>2!T;V=G;&EN9R!W:71H('1H92`G="<@:V5Y+@H*2F]H;B!+
%;WIU<F%N
`
end
SHAR_EOF
  $shar_touch -am 0206232297 'README' &&
  chmod 0640 'README' ||
  $echo 'restore of' 'README' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'README:' 'MD5 check failed'
9d59d20faee066b9c5c1796ba49bd919  README
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'README'`"
    test 815 -eq "$shar_count" ||
    $echo 'README:' 'original size' '815,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*  John Kozura
X	Graphics and Visualization Project 1
X    This program cretes 3 shapes and allows independant rotation
X	and translation of the objects and the camera.  Use either the
X	keys given or the mouse.
*/
X
/* Includes required */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
X
X
#define OBJNUM 3		/* number of objects total */
X
typedef struct {
X	GLdouble x;
X	GLdouble y;
X	GLdouble z;
} Vector;
X
/* Structure for each object */
typedef struct {
X	char name[10];
X	Vector pos;
X	Vector rot;
X	GLdouble size;
X	float color[3];
X	int shine;
X	int transparent;
} Object;
X
/* array of all objects in here */
Object objlist[OBJNUM+1];
int Currobj;
X
/* mouse motion initial variables */
int xstart, ystart, mbutton, Strt = 1;
Object mobject;
X
X
/* Just reset an object */
void initObject(Object *obj) {
X	strcpy(obj->name, "Nothing");
X	obj->pos.x = 0.0;
X	obj->pos.y = 0.0;
X	obj->pos.z = 0.0;
X	obj->rot.x = 0.0;
X	obj->rot.y = 0.0;
X	obj->rot.z = 0.0;
X	obj->size = 1.0;
X	obj->color[0] = 0.0;
X	obj->color[1] = 0.0;
X	obj->color[2] = 0.0;
X	obj->shine = 128;
X	obj->transparent = 0;
}
X
/* copy one vector to another */
void vectorCopy(Vector *dest, Vector *source) {
X	dest->x = source->x;
X	dest->y = source->y;
X	dest->z = source->z;
}
X
X
/* function called to display all the objects, performs transforms etc */
void display(void)
{
X	int i;
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X	glMatrixMode (GL_MODELVIEW);
X    for (i = 1; i <= OBJNUM; i++) {
X		glLoadIdentity();
X		glTranslatef(objlist[i].pos.x, objlist[i].pos.y, objlist[i].pos.z);
X		glRotatef(objlist[i].rot.x, 1.0, 0.0, 0.0);
X		glRotatef(objlist[i].rot.y, 0.0, 1.0, 0.0);
X		glRotatef(objlist[i].rot.z, 0.0, 0.0, 1.0);
X		glColor3fv(objlist[i].color);
X		glMateriali(GL_FRONT, GL_SHININESS, objlist[i].shine);
X		if (objlist[i].transparent)
X			glDisable(GL_DEPTH_TEST);
X		else
X			glEnable(GL_DEPTH_TEST);
X
X		switch(i) {
X			case(1):
X				glutSolidTeapot(objlist[i].size);
X				break;
X			case(2):
X				glutSolidCube(objlist[i].size);
X				break;
X			case(3):
X				glutSolidSphere(objlist[i].size, 30, 20);
X				break;
X		}
X	}
X    glutSwapBuffers(); 
}
X
/* Initialize lighting, variables, and all sorts of other stuff */
void myInit(void)
{
X      int i;
X	  static float lightPos[4] = {-2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.4, 0.4, 0.4, 1.0};
X      static float lightDiff[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightSpec[4] = {1.0, 1.0, 1.0, 1.0};
X
X	  glColorMaterial(GL_FRONT, GL_SPECULAR);
X	  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X	  glEnable(GL_COLOR_MATERIAL);
X      glEnable(GL_DEPTH_TEST);
X
X      glColor3f(1.0, 1.0, 1.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X
X
X	  for (i = 0; i <= OBJNUM; i++)
X		  initObject(&objlist[i]);
X
X	  objlist[0].pos.z = -5;
X
X	  strcpy(objlist[1].name, "Teapot");
X	  objlist[1].pos.x = 2.5;
X	  objlist[1].color[0] = 1.0;
X	  objlist[1].color[1] = 1.0;
X	  objlist[1].shine = 50;
X
X	  strcpy(objlist[2].name, "Cube");
X	  objlist[2].color[0] = 0.8;
X	  objlist[2].shine = 20;
X
X	  strcpy(objlist[3].name, "Sphere");
X	  objlist[3].pos.x = -2.5;
X	  objlist[3].color[2] = 1.0;
X	  objlist[3].shine = 128;
X
X	  printf("Choose an object with 1, 2, 3, or choose 0 for camera change\n\n");
X	  printf("Rotation: (about given axis) \n\n");
X	  printf("    L  K\n");
X	  printf("    | / \n");
X	  printf(" U--*--M\n");
X	  printf("  / |   \n");
X	  printf(" J  H   \n");
X	  printf("\nPostition (in original planes):\n\n");
X	  printf("    E  W\n");
X	  printf("    | / \n");
X	  printf(" A--*--F\n");
X	  printf("  / |   \n");
X	  printf(" S  D   \n");
X	  printf("\nScaling or Zoom + or -\n");
X	  printf("More or less shiny: * or /\n");
X	  printf("Transparent toggle: t\n");
X	  printf("Reset the scene with the = key\n\n");
X	  printf("Or you can do it the easy way, leftmouse for rotate and rightmouse for moving\n");
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X    glViewport (0, 0, w, h);            /*  define the viewport */
X    glMatrixMode(GL_PROJECTION);
X    glLoadIdentity();
X
X	glFrustum(1.0, -1.0, -0.5, 0.5, 1.0, 10.0);
X
X    glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */		
X    glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/* called to refresh perspective on camera angle changes */
void changeCamera() {
X    glMatrixMode(GL_PROJECTION);
X    glLoadIdentity();
X	glFrustum(1.0, -1.0, -0.5, 0.5, 1.0, 10.0);
X    glTranslatef (objlist[0].pos.x, objlist[0].pos.y, objlist[0].pos.z);
X	glRotatef(objlist[0].rot.x, 1.0, 0.0, 0.0);
X	glRotatef(objlist[0].rot.y, 0.0, 1.0, 0.0);
X	glRotatef(objlist[0].rot.z, 0.0, 0.0, 1.0);
X	glScalef(objlist[0].size, objlist[0].size, objlist[0].size);
X		
X    glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/* Keyboard handler */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
/* All the rotations */
X    case 'm':
X		objlist[Currobj].rot.x = objlist[Currobj].rot.x + 10.0;
X	  break;
X    case 'u':
X		objlist[Currobj].rot.x = objlist[Currobj].rot.x - 10.0;
X      break;
X    case 'h':
X		objlist[Currobj].rot.y = objlist[Currobj].rot.y + 10.0;
X	  break;
X    case 'l':
X		objlist[Currobj].rot.y = objlist[Currobj].rot.y - 10.0;
X      break;
X    case 'k':
X		objlist[Currobj].rot.z = objlist[Currobj].rot.z + 10.0;
X      break;
X    case 'j':
X		objlist[Currobj].rot.z = objlist[Currobj].rot.z - 10.0;
X      break;
X
/* all the translations */
X	case 'a':
X		objlist[Currobj].pos.x = objlist[Currobj].pos.x + 0.2;
X		break;
X	case 'f':
X		objlist[Currobj].pos.x = objlist[Currobj].pos.x - 0.2;
X		break;
X	case 'w':
X		objlist[Currobj].pos.z = objlist[Currobj].pos.z - 0.2;
X		break;
X	case 's':
X		objlist[Currobj].pos.z = objlist[Currobj].pos.z + 0.2;
X		break;
X	case 'e':
X		objlist[Currobj].pos.y = objlist[Currobj].pos.y + 0.2;
X		break;
X	case 'd':
X		objlist[Currobj].pos.y = objlist[Currobj].pos.y - 0.2;
X		break;
X
/* zoom in and out */
X	case '+':
X		objlist[Currobj].size = objlist[Currobj].size * 1.2;
X		break;
X	case '-':
X		objlist[Currobj].size = objlist[Currobj].size / 1.2;
X		break;
X
/* change shininess somewhat */
X    case '/':
X		objlist[Currobj].shine = objlist[Currobj].shine + 8;
X		if (objlist[Currobj].shine > 128)
X			objlist[Currobj].shine = 128;
X		break;
X	case '*':
X		objlist[Currobj].shine = objlist[Currobj].shine - 8;
X		if (objlist[Currobj].shine < 4)
X			objlist[Currobj].shine = 4;
X		break;
X
/* reset */
X	case '=':
X		myInit();
X		break;
X 
/* transparent */
X	case 't':
X		objlist[Currobj].transparent = 1 - objlist[Currobj].transparent;
X		break;
X
X	case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X		if ((key >= '0') && (key <= '3'))
X			Currobj = key - '0';
X      break;
X    }
X	if (Currobj == 0)
X		changeCamera();
X
X	glutPostRedisplay();
X	if (Strt) {
X		myInit();
X		Strt = 0;
X	}
}
X
/* mouse interrupt for button press..stor current mouse position */
void MouseButton(int button, int state, int x, int y) {
X	
X	if (state == GLUT_DOWN) {
X		xstart = x;
X		ystart = y;
X		mbutton = button;
X		vectorCopy(&mobject.pos, &objlist[Currobj].pos);
X		vectorCopy(&mobject.rot, &objlist[Currobj].rot);
X		glutKeyboardFunc(NULL);
X	} else 
X		glutKeyboardFunc(Key);
}
X
/* Mouse motion function when button pressed, rotate or translate objects */
void MouseMove(int x, int y) {
X	int change = 0;
X
/* rotation if left button held */
X	if (mbutton == GLUT_LEFT_BUTTON) {
X		objlist[Currobj].rot.y = mobject.rot.y - (x - xstart);
X		objlist[Currobj].rot.x = mobject.rot.x + (y - ystart);
X		change = 1;
X	}
/* position if right button held */
X	if (mbutton == GLUT_RIGHT_BUTTON) {
X		objlist[Currobj].pos.x = mobject.pos.x - ((float)(x - xstart))/100;
X		objlist[Currobj].pos.y = mobject.pos.y - ((float)(y - ystart))/100;
X		change = 1;
X	}
X	if (change) {
X		if (Currobj == 0)
X			changeCamera();
X		
X		glutPostRedisplay();
X
X	}
}
X
X
/*
X    Main Loop
X    Open window with initial window size, title bar, 
X    RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow ("Awwwww Yeah");
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X	  glutMouseFunc(MouseButton);
X	  glutMotionFunc(MouseMove);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206231897 'hw1.c' &&
  chmod 0640 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
1a6a3e8eedb67c12dd8a5edd9a7d0098  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8621 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8621,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh35436
exit 0

From ???@??? Thu Feb 06 07:38:01 1997
Received: from cortez.sss.rpi.edu (wilmesj@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id SAA31660
	for <citrit@rpi.edu>; Wed, 5 Feb 1997 18:25:21 -0500
From: Josh Wilmes <wilmesj>
Received: (wilmesj@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id SAA58162 for citrit@rpi.edu; Wed, 5 Feb 1997 18:25:20 -0500
Date: Wed, 5 Feb 1997 18:25:20 -0500
Message-Id: <199702052325.SAA58162@cortez.sss.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: 1293129d5d73a39dcfd0057fdb7a5cf7

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-05 18:25 EST by <wilmesj@cortez>.
# Source directory was `/afs/rpi.edu/home/80/wilmesj/Classes/Visualization/HW1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    814 -rw------- Makefile
#    814 -rw------- Makefile.Mesa.aix
#    779 -rw------- Makefile.Mesa.linux
#    810 -rw------- Makefile.Mesa.sun
#    898 -rw------- Makefile.sgi
#   9299 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh116498; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lglut -lMesaGLU -lMesaGL -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0203130497 'Makefile' &&
  chmod 0600 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
b372b7437d5b7c8f07484606a593666a  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 814 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '814,' 'current size' "$shar_count!"
  fi
fi
# ============= Makefile.Mesa.aix ==============
if test -f 'Makefile.Mesa.aix' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.Mesa.aix' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.Mesa.aix' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.Mesa.aix' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lglut -lMesaGLU -lMesaGL -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0203130497 'Makefile.Mesa.aix' &&
  chmod 0600 'Makefile.Mesa.aix' ||
  $echo 'restore of' 'Makefile.Mesa.aix' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.Mesa.aix:' 'MD5 check failed'
b372b7437d5b7c8f07484606a593666a  Makefile.Mesa.aix
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.Mesa.aix'`"
    test 814 -eq "$shar_count" ||
    $echo 'Makefile.Mesa.aix:' 'original size' '814,' 'current size' "$shar_count!"
  fi
fi
# ============= Makefile.Mesa.linux ==============
if test -f 'Makefile.Mesa.linux' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.Mesa.linux' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.Mesa.linux' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.Mesa.linux' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
CC=gcc
LDFLAGS= -lglut -lMesaGLU -lMesaGL -L/usr/X11R6/lib -lXmu -lXt -lX11 -lXi -lm
CFLAGS= -g -I/usr/include/mesa -I/usr/include/glut
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0203130297 'Makefile.Mesa.linux' &&
  chmod 0600 'Makefile.Mesa.linux' ||
  $echo 'restore of' 'Makefile.Mesa.linux' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.Mesa.linux:' 'MD5 check failed'
bd4d471a3461bdfe433485cdba10c077  Makefile.Mesa.linux
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.Mesa.linux'`"
    test 779 -eq "$shar_count" ||
    $echo 'Makefile.Mesa.linux:' 'original size' '779,' 'current size' "$shar_count!"
  fi
fi
# ============= Makefile.Mesa.sun ==============
if test -f 'Makefile.Mesa.sun' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.Mesa.sun' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.Mesa.sun' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.Mesa.sun' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
CC=acc
LDFLAGS= -L/locker/44/000644/Mesa/@sys/lib -lglut -lMesaGLU -lMesaGL -L/usr/local/X11/lib -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/locker/44/000644/Mesa/@sys/include
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
SHAR_EOF
  $shar_touch -am 0203130497 'Makefile.Mesa.sun' &&
  chmod 0600 'Makefile.Mesa.sun' ||
  $echo 'restore of' 'Makefile.Mesa.sun' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.Mesa.sun:' 'MD5 check failed'
0496885efb572c4a172e2560c65ee8e6  Makefile.Mesa.sun
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.Mesa.sun'`"
    test 810 -eq "$shar_count" ||
    $echo 'Makefile.Mesa.sun:' 'original size' '810,' 'current size' "$shar_count!"
  fi
fi
# ============= Makefile.sgi ==============
if test -f 'Makefile.sgi' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.sgi' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.sgi' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.sgi' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lMesaaux -lMesatk -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=cc
X
TARGET = simple
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LDFLAGS)
X
lorenz:    lorenz.o
X	$(CC) $(CFLAGS) -o $@ $? $(LIBS)
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0203130497 'Makefile.sgi' &&
  chmod 0600 'Makefile.sgi' ||
  $echo 'restore of' 'Makefile.sgi' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.sgi:' 'MD5 check failed'
a911ac703d77657be3fecce582d7478a  Makefile.sgi
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.sgi'`"
    test 898 -eq "$shar_count" ||
    $echo 'Makefile.sgi:' 'original size' '898,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 hw1.c
M+RH*("H@2&]M97=O<FL@,2P@061V86YC960@0V]M<'5T97(@1W)A<&AI8W,@
M86YD($1A=&$@5FES=6%L:7IA=&EO;@H@*B!*;W-H(%=I;&UE<R`H=VEL;65S
M:D!R<&DN961U*0H@*B`R+S$O.3<*("HO"@HO*B!);F-L=61E<R!R97%U:7)E
M9"`J+PHC:6YC;'5D92`\1TPO9VPN:#X*(VEN8VQU9&4@/$=,+V=L=70N:#X*
M"B\J('-T<G5C='5R97,@*B\*<W1R=6-T(&]B:F5C="!["B`@8VAA<BH@;F%M
M93L*("`O*B!P;W-I=&EO;B`J+PH@(&9L;V%T('AP;W,["B`@9FQO870@>7!O
M<SL*("!F;&]A="!Z<&]S.PH@("\J(&]R:65N=&%T:6]N("HO"B`@:6YT('AR
M;W0["B`@:6YT('ER;W0["B`@+RH@<V-A;&EN9R`J+PH@(&9L;V%T('-I>F4[
M"B`@9FQO870@9&5F7W-I>F4["B`@+RH@;6%T97)I86P@<')O<&5R=&EE<R`J
M+PH@(&9L;V%T(&%M8FEE;G1;-%T["B`@9FQO870@9&EF9G5S95LT73L*("!F
M;&]A="!S<&5C=6QA<ELT73L*("!F;&]A="!S:&EN:6YE<W-;,5T["GT["@HO
M*B!G;'5T+6-A;&QE9"!F=6YC=&EO;G,@*B\*<W1A=&EC('9O:60@9V-?:61L
M92AV;VED*3L*<W1A=&EC('9O:60@9V-?9&ES<&QA>2AV;VED*3L*<W1A=&EC
M('9O:60@9V-?<F5S:&%P92AI;G0L(&EN="D["G-T871I8R!V;VED(&=C7VME
M>2AU;G-I9VYE9"!C:&%R+"!I;G0L(&EN="D["G-T871I8R!V;VED(&=C7W-P
M96-I86QK97DH:6YT+"!I;G0L(&EN="D["G-T871I8R!V;VED(&=C7VUE;G4H
M:6YT*3L*"B\J(&UA;G5A;&QY+6-A;&QE9"!F=6YC=&EO;G,@*B\*<W1A=&EC
M('9O:60@;&EG:'1?:6YI="AV;VED*3L*=F]I9"!O8FI?<')E<"`H<W1R=6-T
M(&]B:F5C="HI.PH*+RH@8V]N<W1A;G1S("HO"B-D969I;F4@455)5"`@(#$*
M(V1E9FEN92!414%03U0@,@HC9&5F:6YE($-50D4@("`S"B-D969I;F4@4U!(
M15)%(#0*(V1E9FEN92!62457("`@-0H*+RH@;V)J96-T(&EN:71I86QI>F%T
M:6]N("HO"G-T<G5C="!O8FIE8W0@=&5A<&]T(#T@>R`B=&5A<&]T(BP*"0D)
M("`@+3(N,"P@("\J('AP;W,@*B\*"0D)("`@,"XP+"`O*B!Y<&]S("HO"@D)
M"2`@(#`N,"P@+RH@>G!O<R`J+PH)"0D@("`P+"`O*B!X<F]T("HO"@D)"2`@
M(#`L("\J('ER;W0@*B\*"0D)("`@,"XX+"`O*B!S:7IE("HO"@D)"2`@(#`N
M."P@+RH@9&5F875L="!S:7IE("HO"@D)"2`@('L@,"XP+"`P+C`L(#`N,"P@
M,2XP('TL("\J(&%M8FEE;G0@*B\*"0D)("`@>R`Q+C`L(#$N,"P@,"XP+"`Q
M+C`@?2P@+RH@9&EF9G5S92`J+PH)"0D@("![(#$N,"P@,2XP+"`Q+C`L(#$N
M,"!]+"`O*B!S<&5C=6QA<B`J+PH)"0D@("![(#4P+C`@?2`@("`@("`@("`@
M("`@("`O*B!S:&EN:6YE<W,@*B\*"0D@("`@("`@?3L@"@IS=')U8W0@;V)J
M96-T(&-U8F4@/2![(")C=6)E(BP*"0D)(#`N,"P@("\J('AP;W,@*B\*"0D)
M(#`N,"P@+RH@>7!O<R`J+PH)"0D@,"XP+"`O*B!Z<&]S("HO"@D)"2`P+"`O
M*B!X<F]T("HO"@D)"2`P+"`O*B!Y<F]T("HO"@D)"2`Q+C`L("\J('-I>F4@
M*B\*"0D)(#$N,"P@+RH@9&5F875L="!S:7IE("HO"@D)"2![(#`N,"P@,"XP
M+"`P+C`L(#$N,"!]+"`O*B!A;6)I96YT("HO"@D)"2![(#$N,"P@,"XP+"`P
M+C`L(#$N,"!]+"`O*B!D:69F=7-E("HO"@D)"2![(#$N,"P@,2XP+"`Q+C`L
M(#$N,"!]+"`O*B!S<&5C=6QA<B`J+PH)"0D@>R`Q,#`N,"!]("`@("`@("`@
M("`@("`@("\J('-H:6YI;F5S<R`J+PH)"2`@("`@?3L@"@H*<W1R=6-T(&]B
M:F5C="!S<&AE<F4@/2![(")S<&AE<F4B+`H)"0D@("`R+C`L("`O*B!X<&]S
M("HO"@D)"2`@(#`N,"P@+RH@>7!O<R`J+PH)"0D@("`P+C`L("\J('IP;W,@
M*B\*"0D)("`@,"P@+RH@>')O="`J+PH)"0D@("`P+"`O*B!Y<F]T("HO"@D)
M"2`@(#`N-BP@+RH@<VEZ92`J+PH)"0D@("`P+C8L("\J(&1E9F%U;'0@<VEZ
M92`J+PH)"0D@("![(#`N,"P@,"XP+"`P+C`L(#$N,"!]+"`O*B!A;6)I96YT
M("HO"@D)"2`@('L@,"XP+"`P+C`L(#$N,"P@,2XP('TL("\J(&1I9F9U<V4@
M*B\*"0D)("`@>R`Q+C`L(#$N,"P@,2XP+"`Q+C`@?2P@+RH@<W!E8W5L87(@
M*B\*"0D)("`@>R`P+C`@?2`@("`@("`@("`@("`@("`O*B!S:&EN:6YE<W,@
M*B\*"0D@("`@("`@?3L@"@IS=')U8W0@;V)J96-T('9I97<@/2![(")V:65W
M(BP*"0D)(#`N,"P@+RH@>'!O<R`M:6=N;W)E9"`J+PH)"0D@,"XP+"`O*B!Y
M<&]S("UI9VYO<F5D("HO"@D)"2`P+C`L("\J('IP;W,@+6EG;F]R960@*B\*
M"0D)(#`L("\J('AR;W0@*B\*"0D)(#`L("\J('ER;W0@*B\*"0D)(#`L("\J
M('-I>F4M(&EG;F]R960@*B\*"0D)(#`L("\J(&1E9F%U;'0@<VEZ92T@:6=N
M;W)E9"`J+PH)"0D@>R`P+C`L(#`N,"P@,"XP+"`Q+C`@?2P@+RH@86UB:65N
M="`M:6=N;W)E9"`J+PH)"0D@>R`P+C`L(#`N,"P@,"XP+"`Q+C`@?2P@+RH@
M9&EF9G5S92`M:6=N;W)E9"`J+PH)"0D@>R`P+C`L(#`N,"P@,"XP+"`Q+C`@
M?2P@+RH@<W!E8W5L87(@+6EG;F]R960@*B\*"0D)('L@,"XP('T@("`@("`@
M("`@("`@("`@+RH@<VAI;FEN97-S("UI9VYO<F5D("HO"@D)("`@("!].R`*
M"G-T<G5C="!O8FIE8W0J('-E;&5C=&5D7V]B:F5C=#TF=FEE=SL*"B\J*BHJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ($=,550@0V%L;&)A8VMS("HJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHO"@HO*CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ(&=C7VED;&4@.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHZ.CHZ.CHZ.CHJ+PHO*B!#86QL960@87,@82!G;'5T(&-A;&QB86-K
M(&1U<FEN9R!I9&QE(&QO;W`@*B\*=F]I9"!G8U]I9&QE*'9O:60I"GL*"GT*
M"B\J.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.B!G8U]D:7-P;&%Y
M(#HZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.BHO"B\J(&=L=70@1&ES
M<&QA>2!F=6YC=&EO;B`J+PIV;VED(&=C7V1I<W!L87DH=F]I9"D*>PH@(&=L
M0VQE87(H1TQ?0T],3U)?0E5&1D527T))5"!\($=,7T1%4%1(7T)51D9%4E]"
M250I.PH@(&=L0VQE87)#;VQO<B`H,"XP+"`P+C`L(#`N,"P@,"XP*3L*("`*
M("!G;$UA=')I>$UO9&4@*$=,7TU/1$5,5DE%5RD[("`@("`@("`O*B!M86YI
M<'5L871E(&UO9&5L=FEE=R!M871R:7@@("HO"@H@("\J(&1O('9I97<@=')A
M;G-F;W)M871I;VYS("HO"B`@9VQ,;V%D261E;G1I='DH*3L*("!G;%1R86YS
M;&%T968H=FEE=RYX<&]S+"!V:65W+GEP;W,L('9I97<N>G!O<RD["B`@9VQ2
M;W1A=&5F*"UV:65W+GAR;W0L(#$N,"P@,"XP+"`P+C`I.R`O*B`H;6]V92!I
M;B!O<'!O<VET92!D:7)E8W1I;VX@9F]R("HO"B`@9VQ2;W1A=&5F*"UV:65W
M+GER;W0L(#`N,"P@,2XP+"`P+C`I.R`O*B`@=&AE('9I97<I("HO"@H@(&=L
M4'5S:$UA=')I>"@I.PH@("`@(&]B:E]P<F5P*"9C=6)E*3L*("`@("!G;'5T
M4V]L:61#=6)E*&-U8F4N<VEZ92D[("`@+RH@(&1R87<@=&AE(&-U8F4@*B\*
M("!G;%!O<$UA=')I>"@I.PH@(`H@(&=L4'5S:$UA=')I>"@I.PH@("`@(&]B
M:E]P<F5P*"9S<&AE<F4I.PH@("`@(&=L=713;VQI9%-P:&5R92AS<&AE<F4N
M<VEZ92PR,"PR,"D["B`@9VQ0;W!-871R:7@H*3L*("`*("!G;%!U<VA-871R
M:7@H*3L*("`@("!O8FI?<')E<"@F=&5A<&]T*3L*("`@("!G;'5T4V]L:614
M96%P;W0H=&5A<&]T+G-I>F4I.PH@(&=L4&]P36%T<FEX*"D["B`@"B`@9VQU
M=%-W87!"=69F97)S*"D[(`I]"@HO*CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHZ.CH@9V-?<F5S:&%P92`Z.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHJ+PHO*B`@0V%L;&5D('=H96X@=&AE('=I;F1O=R!I<R!F:7)S="!O
M<&5N960@86YD('=H96YE=F5R(`H@*B`@=&AE('=I;F1O=R!I<R!R96-O;F9I
M9W5R960@*&UO=F5D(&]R(')E<VEZ960I+@H@*B\*=F]I9"!G8U]R97-H87!E
M*&EN="!W+"!I;G0@:"D*>PH@("`@("!G;%9I97=P;W)T("@P+"`P+"!W+"!H
M*3L@("`@("`@("`@("`O*B`@9&5F:6YE('1H92!V:65W<&]R="`J+PH@("`@
M("!G;$UA=')I>$UO9&4H1TQ?4%)/2D5#5$E/3BD["B`@("`@(&=L3&]A9$ED
M96YT:71Y*"D["B`@("`@(&=L=5!E<G-P96-T:79E*#0U+C`L(#$N,"HH1TQF
M;&]A="EW+RA'3&9L;V%T*6@L(#$N,"P@,3`N,"D["B`@("`@(&=L5')A;G-L
M871E9B`H,"XP+"`P+C`L("TT+C`I.R`@("`@+RH@('9I97=I;F<@=')A;G-F
M;W)M871I;VX@("`@("`J+PH@("`@("!G;$UA=')I>$UO9&4@*$=,7TU/1$5,
M5DE%5RD[("`@("`@("`O*B!B86-K('1O(&UO9&5L=FEE=R!M871R:7@@("HO
M"GT*"B\J.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.B!G8U]K
M97D@.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.BHO"B\J($ME>6)O
M87)D(&AA;F1L97(@*B\*=F]I9"!G8U]K97DH=6YS:6=N960@8VAA<B!K97DL
M(&EN="!X+"!I;G0@>2D*>PH@("`@<W=I=&-H("AK97DI('L*("`@(&-A<V4@
M,C<Z("`@("`@("`@("`O*B!%<V,@=VEL;"!Q=6ET("HO"B`@("`@(&5X:70H
M,2D["B`@("`@(&)R96%K.PH@("`@8V%S92`G<2<Z"B`@("`@('-E;&5C=&5D
M7V]B:F5C="T^>'!O<R`K/2`P+C(@.PH@("`@("!B<F5A:SL*("`@(&-A<V4@
M)V$G.@H@("`@("!S96QE8W1E9%]O8FIE8W0M/GAP;W,@+3T@,"XR(#L*("`@
M("`@8G)E86L["B`@("!C87-E("=W)SH*("`@("`@<V5L96-T961?;V)J96-T
M+3YY<&]S("L](#`N,B`["B`@("`@(&)R96%K.PH@("`@8V%S92`G<R<Z"B`@
M("`@('-E;&5C=&5D7V]B:F5C="T^>7!O<R`M/2`P+C(@.PH@("`@("!B<F5A
M:SL*("`@(&-A<V4@)V4G.@H@("`@("!S96QE8W1E9%]O8FIE8W0M/GIP;W,@
M*ST@,"XR(#L*("`@("`@8G)E86L["B`@("!C87-E("=D)SH*("`@("`@<V5L
M96-T961?;V)J96-T+3YZ<&]S("T](#`N,B`["B`@("`@(&)R96%K.PH@("`@
M9&5F875L=#H*("`@("`@8G)E86L["B`@("!]"B`@("!G;'5T4&]S=%)E9&ES
M<&QA>2@I.PI]"@HO*CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.B!G
M8U]S<&5C:6%L:V5Y(#HZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHJ+PHO
M*B!3<&5C:6%L($ME>2!H86YD;&5R("HO"G-T871I8R!V;VED(&=C7W-P96-I
M86QK97DH(&EN="!K97DL(&EN="!X+"!I;G0@>2`I"GL*("!S=VET8V@@*&ME
M>2D@>PH@(&-A<V4@1TQ55%]+15E?4$%'15]54#H*("`@('!R:6YT9B`H(E-C
M86QE("5S('5P7&XB+'-E;&5C=&5D7V]B:F5C="T^;F%M92D["B`@("!S96QE
M8W1E9%]O8FIE8W0M/G-I>F4@*ST@+C(["B`@("!B<F5A:SL*"B`@8V%S92!'
M3%547TM%65]004=%7T1/5TXZ"B`@("!P<FEN=&8@*")38V%L92`E<R!D;W=N
M7&XB+'-E;&5C=&5D7V]B:F5C="T^;F%M92D["B`@("!S96QE8W1E9%]O8FIE
M8W0M/G-I>F4@+3T@+C(["B`@("!B<F5A:SL*"B`@8V%S92!'3%547TM%65],
M1494.@H@("`@<')I;G1F("@B4F]T871E("5S(&QE9G1<;B(L<V5L96-T961?
M;V)J96-T+3YN86UE*3L*("`@('-E;&5C=&5D7V]B:F5C="T^>7)O="`M/2`Q
M-3L*("`@(&)R96%K.PH*("!C87-E($=,551?2T597T1/5TXZ"B`@("!P<FEN
M=&8@*")2;W1A=&4@)7,@9&]W;EQN(BQS96QE8W1E9%]O8FIE8W0M/FYA;64I
M.PH@("`@<V5L96-T961?;V)J96-T+3YX<F]T("L](#$U.PH@("`@8G)E86L[
M"@H@(&-A<V4@1TQ55%]+15E?55`Z"B`@("!P<FEN=&8@*")2;W1A=&4@)7,@
M=7!<;B(L<V5L96-T961?;V)J96-T+3YN86UE*3L*("`@('-E;&5C=&5D7V]B
M:F5C="T^>')O="`M/2`Q-3L*("`@(&)R96%K.PH*("!C87-E($=,551?2T59
M7U))1TA4.@H@("`@<')I;G1F("@B4F]T871E("5S(')I9VAT7&XB+'-E;&5C
M=&5D7V]B:F5C="T^;F%M92D["B`@("!S96QE8W1E9%]O8FIE8W0M/GER;W0@
M*ST@,34["B`@("!B<F5A:SL*"B`@8V%S92!'3%547TM%65](3TU%.@H@("`@
M<')I;G1F("@B4F5S=&]R92`E<R!T;R!H;VUE('!O<UQN(BQS96QE8W1E9%]O
M8FIE8W0M/FYA;64I.PH@("`@<V5L96-T961?;V)J96-T+3YY<F]T/3`["B`@
M("!S96QE8W1E9%]O8FIE8W0M/GAR;W0],#L*("`@('-E;&5C=&5D7V]B:F5C
M="T^<VEZ93US96QE8W1E9%]O8FIE8W0M/F1E9E]S:7IE.PH@("`@8G)E86L[
M"B`@?0H@(&EF("AS96QE8W1E9%]O8FIE8W0M/GER;W0@/"`P*2`@('-E;&5C
M=&5D7V]B:F5C="T^>7)O="`K/2`S-C`["B`@:68@*'-E;&5C=&5D7V]B:F5C
M="T^>7)O="`^(#,V,"D@<V5L96-T961?;V)J96-T+3YY<F]T("T](#,V,#L*
M("!I9B`H<V5L96-T961?;V)J96-T+3YX<F]T(#P@,"D@("!S96QE8W1E9%]O
M8FIE8W0M/GAR;W0@*ST@,S8P.PH@(&EF("AS96QE8W1E9%]O8FIE8W0M/GAR
M;W0@/B`S-C`I('-E;&5C=&5D7V]B:F5C="T^>')O="`M/2`S-C`["B`@9VQU
M=%!O<W12961I<W!L87DH*3L*?0H*+RHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHZ.CHZ.B!G8U]M96YU(#HZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ
M.CHZ.CHZ*B\*<W1A=&EC('9O:60@9V-?;65N=2`H:6YT(&-H;VEC92D@"GL*
M("!S=VET8V@H8VAO:6-E*2!["B`@8V%S92!154E4.B`@("!E>&ET*#`I.PH@
M(&-A<V4@5$5!4$]4.B`@<V5L96-T961?;V)J96-T/29T96%P;W0[(&)R96%K
M.PH@(&-A<V4@0U5"13H@("`@<V5L96-T961?;V)J96-T/29C=6)E.R`@(&)R
M96%K.PH@(&-A<V4@4U!(15)%.B`@<V5L96-T961?;V)J96-T/29S<&AE<F4[
M(&)R96%K.PH@(&-A<V4@5DE%5SH@("`@<V5L96-T961?;V)J96-T/29V:65W
M.R`@(&)R96%K.PH@('T*("!P<FEN=&8H(DUE;G4@<V5L96-T.B`E<UQN(BQS
M96QE8W1E9%]O8FIE8W0M/FYA;64I.PH@(&=L=710;W-T4F5D:7-P;&%Y*"D[
M"GT*"@HO*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHO"@HO*CHZ.CHZ
M.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CH@;&EG:'1?:6YI="`Z.CHZ.CHZ
M.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHJ+PHO*B!);FET:6%L:7IE('-H861I
M;F<@;6]D96P@*B\*=F]I9"!L:6=H=%]I;FET*'9O:60I"GL*("`@("`@<W1A
M=&EC(&9L;V%T(&QI9VAT4&]S6S1=(#T@>S`N,"P@,"XP+"`T+C`L(#$N,'T[
M"B`@("`@('-T871I8R!F;&]A="!L:6=H=$%M8ELT72`]('LP+C<L(#`N-RP@
M,"XW+"`Q+C!].PH@("`@("!S=&%T:6,@9FQO870@;&EG:'1$:69F6S1=(#T@
M>S`N."P@,"XX+"`P+C@L(#$N,'T["B`@("`@('-T871I8R!F;&]A="!L:6=H
M=%-P96-;-%T@/2![,"XT+"`P+C0L(#`N-"P@,2XP?3L*"B`@("`@(&=L16YA
M8FQE*$=,7TQ)1TA424Y'*3L*("`@("`@9VQ%;F%B;&4H1TQ?3$E'2%0P*3L*
M("`@("`@9VQ,:6=H=&9V*$=,7TQ)1TA4,"P@1TQ?4$]3251)3TXL(&QI9VAT
M4&]S*3L*("`@("`@9VQ,:6=H=&9V*$=,7TQ)1TA4,"P@1TQ?04U"245.5"P@
M;&EG:'1!;6(I.PH@("`@("!G;$QI9VAT9G8H1TQ?3$E'2%0P+"!'3%]$249&
M55-%+"!L:6=H=$1I9F8I.PH@("`@("!G;$QI9VAT9G8H1TQ?3$E'2%0P+"!'
M3%]34$5#54Q!4BP@;&EG:'13<&5C*3L*("`@("`@9VQ%;F%B;&4H1TQ?1$50
M5$A?5$535"D["B`@("`@("\J("`@9VQ3:&%D94UO9&5L("A'3%]&3$%4*3L@
M("HO"GT*"B\J.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CH@;V)J
M7W!R97`@.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.CHZ.BHO"B\J('!R
M97!A<F4@=&AE(&UO9&5L=FEE=R!T<F%N<V9O<FUA=&EO;B!M871R:7@@=7-I
M;F<@=F%L=65S(&EN("IO8FIE8W0Z("HO"B\J(&%L<V\@<V5T<R!U<"!M871E
M<FEA;',@*B\*=F]I9"!O8FI?<')E<"`H<W1R=6-T(&]B:F5C="H@;V)J96-T
M*0I["B`@9VQ4<F%N<VQA=&5F*&]B:F5C="T^>'!O<RP@;V)J96-T+3YY<&]S
M+"!O8FIE8W0M/GIP;W,I.PH@(&=L4F]T871E9BAO8FIE8W0M/GAR;W0L(#$N
M,"P@,"XP+"`P+C`I.PH@(&=L4F]T871E9BAO8FIE8W0M/GER;W0L(#`N,"P@
M,2XP+"`P+C`I.PH@(&=L36%T97)I86QF=BA'3%]&4D].5"P@1TQ?04U"245.
M5"P@("!O8FIE8W0M/F%M8FEE;G0I.PH@(&=L36%T97)I86QF=BA'3%]&4D].
M5"P@1TQ?1$E&1E5312P@("!O8FIE8W0M/F1I9F9U<V4I.PH@(&=L36%T97)I
M86QF=BA'3%]&4D].5"P@1TQ?4U!%0U5,05(L("!O8FIE8W0M/G-P96-U;&%R
M*3L*("!G;$UA=&5R:6%L9G8H1TQ?1E)/3E0L($=,7U-(24Y)3D534RP@;V)J
M96-T+3YS:&EN:6YE<W,I.PI]"@HO*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ
M*BHJ*BHJ*BHJ*BHJ($U!24X@*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ
M*BHJ*BHJ*BHO"FEN="!M86EN*&EN="!A<F=C+"!C:&%R*BH@87)G=BD@"GL*
M("!P<FEN=&8@*")+97ES.EQN(%5P7'12;W1A=&4@=7!<;B!$;W=N.EQT4F]T
M871E(&1O=VY<;B!,969T.EQT4F]T871E(&QE9G1<;B!2:6=H=#I<=%)O=&%T
M92!2:6=H=%QN(%!A9V55<#I38V%L92!U<%QN(%!A9V5$;CI38V%L92!D;W=N
M7&X@82]S.EQT;6]V92`K+RT@>%QN('<O<SI<=&UO=F4@*R\M('E<;B!E+V0Z
M7'1M;W9E("LO+2!Z7&Y(;VUE.EQT36]V92!T;R!H;VUE('!O<VET:6]N7&Y-
M;W5S93H@7&X@4FEG:'0@8G5T=&]N.B!S96QE8W0@;V)J96-T(&UE;G5<;EQN
M(BD["@H@(&=L=71);FET*"9A<F=C+"!A<F=V*3L*("!G;'5T26YI=$1I<W!L
M87E-;V1E("A'3%547T1/54),12!\($=,551?4D="02D["B`@9VQU=$EN:717
M:6YD;W=3:7IE("@T,#`L(#(P,"D["B`@9VQU=$-R96%T95=I;F1O=R`H87)G
M=ELP72D["B`@"B`@;&EG:'1?:6YI="`H*3L@"B`@"B`@+RH@<F5G:7-T97(@
M;W5R(&-A;&QB86-K<R`J+PH@(&=L=71+97EB;V%R9$9U;F,H9V-?:V5Y*3L*
M("!G;'5T4W!E8VEA;$9U;F,@*&=C7W-P96-I86QK97DI.PH@(&=L=71297-H
M87!E1G5N8R`H9V-?<F5S:&%P92D["B`@9VQU=$1I<W!L87E&=6YC("AG8U]D
M:7-P;&%Y*3L*("`O*F=L=71)9&QE1G5N8R`@("AG8U]I9&QE*3LJ+PH@(`H@
M("\J(%-E="!U<"!A(&UE;G4@;VX@=&AE(')I9VAT(&)U='1O;B`J+PH@(&=L
M=71#<F5A=&5-96YU("`H9V-?;65N=2D["B`@9VQU=$%D9$UE;G5%;G1R>2@B
M475I="(L(%%5250I.PH@(&=L=71!9&1-96YU16YT<GDH(BTM+2TM+2TM+2TM
M+2TB+"`P*3L*("!G;'5T061D365N=45N=')Y*")396QE8W0@=&5A<&]T(BP@
M5$5!4$]4*3L*("!G;'5T061D365N=45N=')Y*")396QE8W0@8W5B92(L($-5
M0D4I.PH@(&=L=71!9&1-96YU16YT<GDH(E-E;&5C="!S<&AE<F4B+"!34$A%
M4D4I.PH@(&=L=71!9&1-96YU16YT<GDH(E-E;&5C="!V:65W<&]I;G0B+"!6
M2457*3L*("`*("!G;'5T071T86-H365N=2A'3%547U))1TA47T)55%1/3BD[
M"B`@"B`@+RH@5'5R;B!C;VYT<F]L(&]V97(@=&\@=&AE(&=L=70@979E;G0@
=;&]O<"`J+PH@(&=L=71-86EN3&]O<"@I.PI]"@H@
`
end
SHAR_EOF
  $shar_touch -am 0203160597 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
221d05895e6fe68d725037b5061f7194  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 9299 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '9299,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh116498
exit 0

From ???@??? Fri Feb 07 07:34:38 1997
Received: from dekalb.vf.mmc.com (dekalb.vf.mmc.com [192.35.35.21])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id HAA44346
	for <citrit@rpi.edu>; Fri, 7 Feb 1997 07:25:39 -0500
From: kalisz@fc01.psf.lmco.com
Received: from franklin.vf.lmco.com ([166.17.5.51]) by dekalb.vf.mmc.com (8.7.6/8.7.3) with ESMTP id HAA04513 for <citrit@rpi.edu>; Fri, 7 Feb 1997 07:25:38 -0500 (EST)
Received: from fc01.psf.lmco.com (fc01.psf.lmco.com [166.16.60.2]) by franklin.vf.lmco.com (8.7.6/8.7.3) with SMTP id HAA07642 for <citrit@rpi.edu>; Fri, 7 Feb 1997 07:25:36 -0500 (EST)
Received: from eng526.psf.lmco.com by fc01.psf.lmco.com (4.1/LMCO SunOS Server Nondomain-1.1)
	id AA17339; Fri, 7 Feb 97 07:28:39 EST
Received: by eng526.psf.lmco.com (4.1/LMCO Sun Client Nondomain-1.1)
	id AA25433; Fri, 7 Feb 97 07:28:41 EST
Date: Fri, 7 Feb 97 07:28:41 EST
Message-Id: <9702071228.AA25433@eng526.psf.lmco.com>
To: citrit@rpi.edu
Subject: HOMEWORK #1
Content-Type: X-sun-attachment
X-UIDL: c06e274d86a1f509da13381c11f71aef

----------
X-Sun-Data-Type: text
X-Sun-Data-Description: text
X-Sun-Data-Name: text
X-Sun-Content-Lines: 1

Here's the homwork.
----------
X-Sun-Data-Type: shell-script
X-Sun-Data-Name: hwmain.shar
X-Sun-Content-Lines: 510

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-07 07:22 EST by <kalisj@rebecca.its.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/27/kalisj'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  18750 -rw-r----- hwmain.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh19901; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hwmain.c ==============
if test -f 'hwmain.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hwmain.c' '(file already exists)'
else
  $echo 'x -' extracting 'hwmain.c' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 hwmain.c
M+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/2`J+PT*+RH@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@061V86YC960@0V]M<'5T
M97(@1W)A<&AI8W,@86YD($-O;7!U=&5R(%9I<W5A;&EZ871I;VX@("`@("`@
M("`@("`@("`@("`@("`J+PT*+RH@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`J+PT*+RH@2&]M97=O<FL@07-S:6=N;65N="`Q("T@-B!&96)R=6%R
M>2`Q.3DW("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*
M+RH@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@:'=-86EN
M+F,@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`J+PT*+RH@2F]H;B!4+B!+86QI<WH@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`J+PT*+RH@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*
M+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/2`J+PT*+RH@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@4%524$]313H@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`J+PT*+RH@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`J+PT*+RH@5&AE('!R;V=R86T@;W!E;G,@82!W:6YD;W<@=VET:"!A
M(&1O=6)L92!B=69F97)E9"!V:7-U86PN("!4:&4@<')O9W)A;2`@("`J+PT*
M+RH@9')A=W,@=&AR964@;V)J96-T<SH@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH)"3$N($$@<V]L:60@<VAI
M;GD@<F5D(&-U8F4N("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("HO#0HO*B`@("`@(#(N($$@<V]L:60@<F]U9V@@8FQU92!S
M<&AE<F4N*#(@=6YI=',@=&\@=&AE(')I9VAT(&]F('1H92!C=6)E*2`@("`@
M("HO#0HO*B`@("`@(#,N($$@>65L;&]W('1E87!O="X@("`@("`@("`@*#(@
M=6YI=',@=&\@=&AE(&QE9G0@;V8@=&AE(&-U8F4I("`@("`@("HO#0HO*B`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("HO#0HO*B!4:&4@;W!E<F%T
M;W(@;6%Y(&-H;V]S92!T;R!R;W1A=&4@86YY(&]B:F5C="!A<R!F;VQL;W=S
M.B`@("`@("`@("`@("`@("`@("HO#0HO*B`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("HO#0HO*@D)4')E<W,@<R`M('1O(&-H;V]S92!S<&AE<F4@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-
M"B\J"0E0<F5S<R!C("T@=&\@8VAO;W-E(&-U8F4@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH)"5!R97-S('0@
M+2!T;R!C:&]O<V4@=&5A<&]T("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("HO#0HO*@D)4')E<W,@>B`M('1O(&-H;V]S92!V
M:65W<&]I;G0@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@*B\-"B\J("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J
M(%1H92!O<&5R871O<B!M87D@<F]T871E(&%B;W5T(&%L;"!T:')E92!A>&5S
M(&)Y('!R97-S:6YG.B`@("`@("`@("`@("`@("`@*B\-"B\J("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@*B\-"B\J("`@("`@57`@07)R;W<@+R`@
M1&]W;B!!<G)O=R`@("T@(%@@07AI<R`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@*B\-"B\J("`@("`@;B!K97D@+R!M(&ME>2`@("`@("`@
M("`@("T@(%D@07AI<R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@*B\-"B\J("`@("`@4FEG:'0@07)R;W<@+R!,969T($%R<F]W("T@(%H@
M07AI<R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J(%%U:70@=&AE
M('!R;V=R86T@8GD@<')E<W-I;F)G($530RX@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@*B\-"B\J("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@*B\-"B\J(#T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T@*B\-"B\J($A%041%4E,@1DE,15,@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J
M(#T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T@*B\-"B\J(%=I;F1O=W,@
M05!)("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@*B\-"B`@("-I;F-L=61E(")W:6YD;W=S
M+F@B#0HO*B!O<&5N1TP@05!)("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("HO#0H@("`C
M:6YC;'5D92`B9VPO9VPN:"(@("`@(`T*+RH@;W!E;D=,(%5T:6QI=&EE<R`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`J+PT*("`@(VEN8VQU9&4@(F=L+V=L=2YH(@T*+RH@;W!E
M;D=,($%U>&EL:6%R>2!L:6)R87)Y($%022`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*("`@(VEN8VQU9&4@(F=L
M+V=L875X+F@B("`-"B\J(%-T86YD87)D($DO3R!L:6)R87)Y("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M*B\-"B`@("-I;F-L=61E(")S=&1I;RYH(B`@#0HO*B`]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]("HO#0HO*B!465!%($1%1DE.251)3TY3("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("HO#0HO*B`]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]("HO
M#0HO*B!$969I;F4@96YU;65R871E9"!T>7!E(&9O<B!O8FIE8W1S("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("HO#0IE;G5M(`T*
M>PT*"5-02$5212P-"@E#54)%+`T*"51%05!/5"P-"@E62457+`T*?2!H=T]B
M:F5C=$YA;64[#0H-"B\J($1E9FEN92!3=')U8W1U<F4@=&\@<W1O<F4@8W5R
M<F5N="!S=&%T92!O9B!E86-H(&]B:F5C="X@("`@("`@("HO#0IT>7!E9&5F
M('-T<G5C="`-"GL-"@T*+RH@(%!/4TE424].($E.1D]234%424].("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`J+PT*#0H)1TQF;&]A="!X4&]S:71I;VX[("`O*B!#=7)R96YT(%@@8V]O
M<F1I;F%T92!O9B!O8FIE8W0@*B\-"@E'3&9L;V%T('E0;W-I=&EO;CL@("\J
M($-U<G)E;G0@62!C;V]R9&EN871E(&]F(&]B:F5C="`J+PT*"4=,9FQO870@
M>E!O<VET:6]N.R`@+RH@0W5R<F5N="!:(&-O;W)D:6YA=&4@;V8@;V)J96-T
M("HO#0H)#0H)1TQF;&]A="!X06YG;&4[("`@("`O*B!#=7)R96YT(&%N9VQE
M(&]F(')O=&%T:6]N(&%B;W5T(%@M07AI<R`J+PT*("`@($=,9FQO870@>4%N
M9VQE.R`@("`@+RH@0W5R<F5N="!A;F=L92!O9B!R;W1A=&EO;B!A8F]U="!9
M+4%X:7,@*B\-"@E'3&9L;V%T('I!;F=L93L@("`@("\J($-U<G)E;G0@86YG
M;&4@;V8@<F]T871I;VX@86)O=70@6BU!>&ES("HO#0H-"B\J("!-051%4DE!
M3"!)3D9/4DU!5$E/3B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`J+PT*#0H)1TQF;&]A="!S:&EN:6YE<W-;
M,5T[("\J(%-H:6YI;F5S<R`@("`@("`J+PT*"4=,9FQO870@<W!E8W5L87);
M-%T[("`O*B!3<&5C=6QA<B!696-T;W(@*B\-"@E'3&9L;V%T(&5M:7-S:6]N
M6S1=.R`@+RH@16UI<W-I;VX@5F5C=&]R("HO#0H)1TQF;&]A="!A;6)I96YT
M6S1=.R`@("\J($%M8FEE;G0@5F5C=&]R("`J+PT*"4=,9FQO870@9&EF9G5S
M95LT73L@("`O*B!$:69F=7-E(%9E8W1O<B`@*B\-"@T*#0HO*B`@3T)*14-4
M($E$14Y4249)15(@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@*B\-"@T*"65N=6T@;V)J96-T3F%M92!O
M8FIE8W1)9#L@+RH@3F%M92!B>2!W:&EC:"!O8FIE8W0@=VEL;"!B92!R969E
M<F5N8V5D("`@("HO#0H)1TQF;&]A="!S:7IE.R`@("`@("`@("`@("`O*B!3
M:7IE(&]F(&]B:F5C="`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-
M"GT@2%=/0DI%0U0[#0H-"@T*+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/2`J+PT*+RH@3$]#04P@5D%224%"3$4@1$5&24Y)5$E/3E,@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*
M+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/2`J+PT*2%=/0DI%0U0@
M:'=/8FIE8W1S6S-=.PT*96YU;2!O8FIE8W1.86UE(&-U<G)E;G1/8FIE8W0[
M#0IE;G5M(&AW07AI<R!C=7)R96YT07AI<SL-"@T*+RH@/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/2`J+PT*+RH@3$]#04P@1E5.0U1)3TX@4%)/5$]4
M65!%4R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`J+PT*+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/2`J
M+PT*=F]I9"!H=TEN:70H=F]I9"D[#0IV;VED($-!3$Q"04-+(&AW4F5S:&%P
M92A'3'-I>F5I('<L($=,<VEZ96D@:"D[#0IV;VED($-!3$Q"04-+(&AW1&ES
M<&QA>2AV;VED*3L-"G9O:60@:'=296YD97(H2%=/0DI%0U0@*F]B:F5C="D[
M#0IS=&%T:6,@=F]I9"!#04Q,0D%#2R!+97E?<RAV;VED*3L-"G-T871I8R!V
M;VED($-!3$Q"04-+($ME>5]C*'9O:60I.PT*<W1A=&EC('9O:60@0T%,3$)!
M0TL@2V5Y7W0H=F]I9"D[#0IS=&%T:6,@=F]I9"!#04Q,0D%#2R!+97E?=7`H
M=F]I9"D[#0IS=&%T:6,@=F]I9"!#04Q,0D%#2R!+97E?9&]W;BAV;VED*3L-
M"G-T871I8R!V;VED($-!3$Q"04-+($ME>5]L969T*'9O:60I.PT*<W1A=&EC
M('9O:60@0T%,3$)!0TL@2V5Y7W)I9VAT*'9O:60I.PT*<W1A=&EC('9O:60@
M0T%,3$)!0TL@2V5Y7VXH=F]I9"D[#0IS=&%T:6,@=F]I9"!#04Q,0D%#2R!+
M97E?;2AV;VED*3L-"G-T871I8R!V;VED($-!3$Q"04-+($ME>5]Z*'9O:60I
M.PT*+RH@/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/2`J+PT*+RH@14Y4
M4ED@4$])3E0@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`J+PT*+RH@/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/2`J+PT*:6YT(&UA:6XH=F]I9"D-"GL-"B\J("`M
M+2T@4%))3E0@24Y35%)50U1)3TY3("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\@#0H)("`@('!R:6YT9B@B
M5T5,0T]-12!43R!(3TU%5T]22R!!4U-)1TY-14Y4(#%<;B(I.PT*"0EP<FEN
M=&8H(DIO:&X@5"X@2V%L:7-Z7&Y<;B(I.PT*"0EP<FEN=&8H(E!R97-S('1H
M92!F;VQL;W=I;F<@:V5Y('1O('-E;&5C="!A;B!O8FIE8W0Z7&XB*3L-"@D)
M<')I;G1F*")<=&,@+2!C=6)E7&Y<=',@+2!S<&AE<F5<;EQT="`M('1E87!O
M=%QN(BD[#0H)"7!R:6YT9B@B7'1Z("T@=FEE=W!O:6YT7&Y<;B(I.PT*"0EP
M<FEN=&8H(E5S92!T:&4@9F]L;&]W:6YG(&ME>7,@=&\@<F]T871E.EQN(BD[
M#0H)"7!R:6YT9B@B6"U!>&ES("T@57`@86YD($1O=VX@07)R;W=S7&XB*3L-
M"@D)<')I;G1F*")9+4%X:7,@+2!N(&%N9"!M($ME>7-<;B(I.PT*"0EP<FEN
M=&8H(EHM07AI<R`M($QE9G0@86YD(%)I9VAT($%R<F]W<UQN(BD[(`T*"0EP
M<FEN=&8H(EQN15-#("T@455)5"(I.PT*"0EP<FEN=&8H(EQN3D]413I<;EQN
M(BD[#0H)"7!R:6YT9B@B5&AE('1E87!O="!W:6QL(&%P<&5A<B!Y96QL;W<@
M:68@>6]U(')O=&%T92!I="Y<;B(I.PT*"0EP<FEN=&8H(E5N9F]R='5N871E
M;'D@22!H879E(&YO="!B965N(&%B;&4@=&\@9V5T('1H92!<;B(I.PT*"0EP
M<FEN=&8H(G1H92!T96%P;W0@=&\@97AH:6)I="`S+40@<')O<&5R=&EE<RXB
M*3L-"B\J("`M+2T@4T54(%50($1/54),12!"549&15))3D<@04Y$(%)'0D$@
M0T],3U(@4T-(14U%("`@("`@("`@("`@("`@("`@("`@("`@*B\-"@D@("`@
M875X26YI=$1I<W!L87E-;V1E*"!!55A?1$]50DQ%('P@05587U)'0D$@*3L-
M"B\J("`M+2T@4T54($E.251)04P@5TE.1$]7(%!/4U1)3TX@04Y$(%-)6D4@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"@D)875X26YI
M=%!O<VET:6]N*#`L(#`L(#4P,"P@-3`P*3L-"B\J("`M+2T@1$5&24Y%($95
M3D-424].4R!!4U-/0TE!5$5$(%=)5$@@2T594R`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@*B\-"@D)875X2V5Y1G5N8RA!55A?<RP@("`H0558
M2T594%)/0RE+97E?<RD[#0H@("`@("`@(&%U>$ME>49U;F,H05587V,L("`@
M*$%56$M%65!23T,I2V5Y7V,I.PT*"0EA=7A+97E&=6YC*$%56%]T+"`@("A!
M55A+15E04D]#*4ME>5]T*3L-"@D)875X2V5Y1G5N8RA!55A?55`L("`H0558
M2T594%)/0RE+97E?=7`I.PT*"0EA=7A+97E&=6YC*$%56%]$3U=.+"`@*$%5
M6$M%65!23T,I2V5Y7V1O=VXI.PT*"0EA=7A+97E&=6YC*$%56%],1494+"`@
M*$%56$M%65!23T,I2V5Y7VQE9G0I.PT*"0EA=7A+97E&=6YC*$%56%]224=(
M5"P@("A!55A+15E04D]#*4ME>5]R:6=H="D[#0H)"6%U>$ME>49U;F,H0558
M7VXL("`H05582T594%)/0RE+97E?;BD[#0H)"6%U>$ME>49U;F,H05587VTL
M("`H05582T594%)/0RE+97E?;2D[#0H)"6%U>$ME>49U;F,H05587WHL("`H
M05582T594%)/0RE+97E?>BD[#0H)"6%U>$ME>49U;F,H05587T530T%012P@
M*$%56$M%65!23T,I875X475I="D[#0HO*B`@+2TM($1)4U!,05D@5TE.1$]7
M(%=)5$@@3D%-12`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("HO#0H)"6%U>$EN:717:6YD;W<H(DAO;65W;W)K(#$@+2!*
M;VAN(%0N($MA;&ES>B`M(#8@1F5B<G5A<GD@.3<B*3L-"B\J("`M+2T@24Y)
M5$E!3$E:12!'3$]"04P@3T)*14-4(%-44E5#5%5215,@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@*B\-"@D):'=);FET*"D[#0HO*B`@+2TM
M($Q%5"!!55A)3$E!4ED@3$E"4D%262!+3D]7(%1(12!,3T-!5$E/3B!/1B!4
M2$4@4D532$%012!&54Y#5$E/3B`@("`@("HO#0H)"6%U>%)E<VAA<&5&=6YC
M*"A!55A215-(05!%4%)/0REH=U)E<VAA<&4I.PT*+RH@("TM+2!$149)3D4@
M3$]/4"!&54Y#5$E/3B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`J+PT*"0EA=7A-86EN3&]O<"@H055834%)3E!2
M3T,I:'=$:7-P;&%Y*3L-"B\J("`M+2T@4D5455).("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@*B\-"@D)<F5T=7)N*#`I.PT*?0T*#0HO*B`]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]("HO#0HO*B!)3DE424%,25I!5$E/3B!23U5424Y%("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("HO#0HO*B`]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]("HO#0IV
M;VED(&AW26YI="AV;VED*0T*>PT*+RH@+2TM(%-%5"!,24=(5"!03U-)5$E/
M3B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`J+PT*"2`@($=,9FQO870@;&EG:'1?<&]S:71I;VY;72`]('L@
M*$=,9FQO870I,C`L#0H)"2`@("`@("`@("`@("`@("`@("`@("`@("`@("`H
M1TQF;&]A="DR,"P-"@D)("`@"0D)"0D)("`@("A'3&9L;V%T*3(P+`T*"0D)
M"0D)"0D@("`@*$=,9FQO870I,"XP('T[#0H-"B\J("TM+2!3150@4TA!1$E.
M1R!-3T1%3"!43R!334]/5$@@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@*B\-"@D@("!G;%-H861E36]D96PH($=,7T9,050@
M*3L-"B\J("TM+2!3150@55`@3$E'2%0@,"!!3D0@14Y!0DQ%("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"@T*"2`@
M(&=L3&EG:'1F=BA'3%],24=(5#`L($=,7U!/4TE424].+"!L:6=H=%]P;W-I
M=&EO;BD[#0H@("`@("`@9VQ%;F%B;&4H1TQ?3$E'2%1)3D<I.PT*("`@("`@
M(&=L16YA8FQE*$=,7TQ)1TA4,"D[#0HO*B`M+2T@4T54($1%4%1(("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("HO#0H@("`@("`@9VQ$97!T:$9U;F,H1TQ?3$534RD[#0H@
M("`@("`@9VQ%;F%B;&4H1TQ?1$505$A?5$535"D[#0HO*B`M+2T@1$5&24Y%
M($E.251)04P@4U1!5$4@1D]2(%-02$5212`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("HO#0H-"@D@("!H=T]B:F5C='-;,%TN;V)J
M96-T260@/2!34$A%4D4[#0H)("`@:'=/8FIE8W1S6S!=+G-I>F4@("`@(#T@
M*$=,9FQO870I,"XU.PT*"2`@(`T*"2`@(&AW3V)J96-T<ULP72YX4&]S:71I
M;VX@/2`H1TQF;&]A="DR+C`[#0H)("`@:'=/8FIE8W1S6S!=+GE0;W-I=&EO
M;B`]("A'3&9L;V%T*3`N,#L-"@D@("!H=T]B:F5C='-;,%TN>E!O<VET:6]N
M(#T@*$=,9FQO870I,"XP.PT*#0H)("`@:'=/8FIE8W1S6S!=+GA!;F=L92`]
M("A'3&9L;V%T*3`N,#L-"@D@("!H=T]B:F5C='-;,%TN>4%N9VQE(#T@*$=,
M9FQO870I,"XP.PT*"2`@(&AW3V)J96-T<ULP72YZ06YG;&4@/2`H1TQF;&]A
M="DP+C`[#0HO*B`M+2T@1$5&24Y%($U!5$5224%,(%!23U!%4E1)15,@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("HO#0H)
M("`@:'=/8FIE8W1S6S!=+G-H:6YI;F5S<ULP72`]("A'3&9L;V%T*3`N,#L-
M"@D@("!H=T]B:F5C='-;,%TN<W!E8W5L87);,%T@/2`H1TQF;&]A="DP+C`[
M#0H)("`@:'=/8FIE8W1S6S!=+G-P96-U;&%R6S%=(#T@*$=,9FQO870I,"XP
M.PT*("`@("`@(&AW3V)J96-T<ULP72YS<&5C=6QA<ELR72`]("A'3&9L;V%T
M*3`N,3L-"B`@("`@("!H=T]B:F5C='-;,%TN<W!E8W5L87);,UT@/2`H1TQF
M;&]A="DP+C`[#0H)("`@#0H)("`@:'=/8FIE8W1S6S!=+F%M8FEE;G1;,%T@
M/2`H1TQF;&]A="DP+C$[#0H)("`@:'=/8FIE8W1S6S!=+F%M8FEE;G1;,5T@
M/2`H1TQF;&]A="DP+C$[#0H@("`@("`@:'=/8FIE8W1S6S!=+F%M8FEE;G1;
M,ET@/2`H1TQF;&]A="DP+C,[#0H@("`@("`@:'=/8FIE8W1S6S!=+F%M8FEE
M;G1;,UT@/2`H1TQF;&]A="DP+C`[#0H-"@D@("!H=T]B:F5C='-;,%TN96UI
M<W-I;VY;,%T@/2`H1TQF;&]A="DP+C`[#0H)("`@:'=/8FIE8W1S6S!=+F5M
M:7-S:6]N6S%=(#T@*$=,9FQO870I,"XP.PT*("`@("`@(&AW3V)J96-T<ULP
M72YE;6ES<VEO;ELR72`]("A'3&9L;V%T*3`N,3L-"B`@("`@("!H=T]B:F5C
M='-;,%TN96UI<W-I;VY;,UT@/2`H1TQF;&]A="DP+C`[#0H-"@D@("!H=T]B
M:F5C='-;,%TN9&EF9G5S95LP72`]("A'3&9L;V%T*3`N,#L-"@D@("!H=T]B
M:F5C='-;,%TN9&EF9G5S95LQ72`]("A'3&9L;V%T*3`N,#L-"B`@("`@("!H
M=T]B:F5C='-;,%TN9&EF9G5S95LR72`]("A'3&9L;V%T*3`N-#L-"B`@("`@
M("!H=T]B:F5C='-;,%TN9&EF9G5S95LS72`]("A'3&9L;V%T*3`N,#L-"B\J
M("TM+2!$149)3D4@24Y)5$E!3"!35$%412!&3U(@0U5"12`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"@T*"2`@(&AW3V)J
M96-T<ULQ72YO8FIE8W1)9"`]($-50D4[#0H)("`@:'=/8FIE8W1S6S%=+G-I
M>F4@("`@(#T@*$=,9FQO870I,"XW.PT*"2`@(`T*"2`@(&AW3V)J96-T<ULQ
M72YX4&]S:71I;VX@/2`H1TQF;&]A="DP+C`[#0H)("`@:'=/8FIE8W1S6S%=
M+GE0;W-I=&EO;B`]("A'3&9L;V%T*3`N,#L-"@D@("!H=T]B:F5C='-;,5TN
M>E!O<VET:6]N(#T@*$=,9FQO870I,"XP.PT*#0H)("`@:'=/8FIE8W1S6S%=
M+GA!;F=L92`]("A'3&9L;V%T*3,S,"XP.PT*"2`@(&AW3V)J96-T<ULQ72YY
M06YG;&4@/2`H1TQF;&]A="DS,"XP.PT*"2`@(&AW3V)J96-T<ULQ72YZ06YG
M;&4@/2`H1TQF;&]A="DS,"XP.PT*+RH@+2TM($1%1DE.12!-051%4DE!3"!0
M4D]015)42453("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`J+PT*"2`@(&AW3V)J96-T<ULQ72YS:&EN:6YE<W-;,%T@/2`H
M1TQF;&]A="DP+C4[#0H)("`@:'=/8FIE8W1S6S%=+G-P96-U;&%R6S!=(#T@
M*$=,9FQO870I,"XR.PT*"2`@(&AW3V)J96-T<ULQ72YS<&5C=6QA<ELQ72`]
M("A'3&9L;V%T*3`N,#L-"B`@("`@("!H=T]B:F5C='-;,5TN<W!E8W5L87);
M,ET@/2`H1TQF;&]A="DP+C`[#0H@("`@("`@:'=/8FIE8W1S6S%=+G-P96-U
M;&%R6S-=(#T@*$=,9FQO870I,"XP.R`-"@T*"2`@(&AW3V)J96-T<ULQ72YA
M;6)I96YT6S!=(#T@*$=,9FQO870I,"XQ.PT*"2`@(&AW3V)J96-T<ULQ72YA
M;6)I96YT6S%=(#T@*$=,9FQO870I,"XQ.PT*("`@("`@(&AW3V)J96-T<ULQ
M72YA;6)I96YT6S)=(#T@*$=,9FQO870I,"XQ.PT*("`@("`@(&AW3V)J96-T
M<ULQ72YA;6)I96YT6S-=(#T@*$=,9FQO870I,"XP.PT*#0H)("`@:'=/8FIE
M8W1S6S%=+F5M:7-S:6]N6S!=(#T@*$=,9FQO870I,"XU.PT*"2`@(&AW3V)J
M96-T<ULQ72YE;6ES<VEO;ELQ72`]("A'3&9L;V%T*3`N,#L-"B`@("`@("!H
M=T]B:F5C='-;,5TN96UI<W-I;VY;,ET@/2`H1TQF;&]A="DP+C`[#0H@("`@
M("`@:'=/8FIE8W1S6S%=+F5M:7-S:6]N6S-=(#T@*$=,9FQO870I,"XP.PT*
M#0H)("`@:'=/8FIE8W1S6S%=+F1I9F9U<V5;,%T@/2`H1TQF;&]A="DP+C4[
M#0H)("`@:'=/8FIE8W1S6S%=+F1I9F9U<V5;,5T@/2`H1TQF;&]A="DP+C`[
M#0H@("`@("`@:'=/8FIE8W1S6S%=+F1I9F9U<V5;,ET@/2`H1TQF;&]A="DP
M+C`[#0H@("`@("`@:'=/8FIE8W1S6S%=+F1I9F9U<V5;,UT@/2`H1TQF;&]A
M="DP+C`[#0HO*B`M+2T@1$5&24Y%($E.251)04P@4U1!5$4@1D]2(%1%05!/
M5"`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("HO#0H-
M"@D@("!H=T]B:F5C='-;,ETN;V)J96-T260@/2!414%03U0[#0H)("`@:'=/
M8FIE8W1S6S)=+G-I>F4@("`@(#T@*$=,9FQO870I,"XU.PT*"2`@(`T*"2`@
M(&AW3V)J96-T<ULR72YX4&]S:71I;VX@/2`H1TQF;&]A="DM,BXP.PT*"2`@
M(&AW3V)J96-T<ULR72YY4&]S:71I;VX@/2`H1TQF;&]A="DP+C`[#0H)("`@
M:'=/8FIE8W1S6S)=+GI0;W-I=&EO;B`]("A'3&9L;V%T*3`N,#L-"@T*"2`@
M(&AW3V)J96-T<ULR72YX06YG;&4@/2`H1TQF;&]A="DP+C`[#0H)("`@:'=/
M8FIE8W1S6S)=+GE!;F=L92`]("A'3&9L;V%T*3`N,#L-"@D@("!H=T]B:F5C
M='-;,ETN>D%N9VQE(#T@*$=,9FQO870I,"XP.PT*+RH@+2TM($1%1DE.12!-
M051%4DE!3"!04D]015)42453("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`J+PT*"2`@(&AW3V)J96-T<ULR72YS:&EN:6YE
M<W-;,%T@/2`H1TQF;&]A="DP+C4[#0H)("`@:'=/8FIE8W1S6S)=+G-P96-U
M;&%R6S!=(#T@*$=,9FQO870I,"XT.PT*"2`@(&AW3V)J96-T<ULR72YS<&5C
M=6QA<ELQ72`]("A'3&9L;V%T*3`N-#L-"B`@("`@("!H=T]B:F5C='-;,ETN
M<W!E8W5L87);,ET@/2`H1TQF;&]A="DP+C`[#0H@("`@("`@:'=/8FIE8W1S
M6S)=+G-P96-U;&%R6S-=(#T@*$=,9FQO870I,"XP.R`-"@T*"2`@(&AW3V)J
M96-T<ULR72YA;6)I96YT6S!=(#T@*$=,9FQO870I,"XP-3L-"@D@("!H=T]B
M:F5C='-;,ETN86UB:65N=%LQ72`]("A'3&9L;V%T*3`N,#4[#0H@("`@("`@
M:'=/8FIE8W1S6S)=+F%M8FEE;G1;,ET@/2`H1TQF;&]A="DP+C`[#0H@("`@
M("`@:'=/8FIE8W1S6S)=+F%M8FEE;G1;,UT@/2`H1TQF;&]A="DP+C`[#0H-
M"@D@("!H=T]B:F5C='-;,ETN96UI<W-I;VY;,%T@/2`H1TQF;&]A="DP+C`U
M.PT*"2`@(&AW3V)J96-T<ULR72YE;6ES<VEO;ELQ72`]("A'3&9L;V%T*3`N
M,#4[#0H@("`@("`@:'=/8FIE8W1S6S)=+F5M:7-S:6]N6S)=(#T@*$=,9FQO
M870I,"XP.PT*("`@("`@(&AW3V)J96-T<ULR72YE;6ES<VEO;ELS72`]("A'
M3&9L;V%T*3`N,#L-"@T*"2`@(&AW3V)J96-T<ULR72YD:69F=7-E6S!=(#T@
M*$=,9FQO870I,"XS.PT*"2`@(&AW3V)J96-T<ULR72YD:69F=7-E6S%=(#T@
M*$=,9FQO870I,"XS.PT*("`@("`@(&AW3V)J96-T<ULR72YD:69F=7-E6S)=
M(#T@*$=,9FQO870I,"XP.PT*("`@("`@(&AW3V)J96-T<ULR72YD:69F=7-E
M6S-=(#T@*$=,9FQO870I,"XP.PT*"2`@(`T*#0I]#0H-"B\J(#T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T@*B\-"B\J(%)%4TA!4$4@1E5.0U1)3TX@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@*B\-"B\J(#T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T@*B\-"G9O:60@0T%,3$)!0TL@:'=297-H87!E*$=,<VEZ96D@=RP@1TQS
M:7IE:2!H*0T*>PT*("`@(&@@/2`H:"`]/2`P*2`_(#$@.B!H.PT*("`@(&=L
M5FEE=W!O<G0H,"P@,"P@=RP@:"D[#0H@("`@9VQ-871R:7A-;V1E*$=,7U!2
M3TI%0U1)3TXI.PT*("`@(&=L3&]A9$ED96YT:71Y*"D[#0H@("`@:68@*'<@
M/#T@:"D@#0H@("`@9VQ/<G1H;R`H+3,L(#,L("TS*BA'3&9L;V%T*6@O*$=,
M9FQO870I=RP@#0H@("`@("`@(#,J*$=,9FQO870I:"\H1TQF;&]A="EW+"`M
M,3`N,"P@,3`N,"D[#0H@("`@96QS92`-"B`@("!G;$]R=&AO*"TS*BA'3&9L
M;V%T*7<O*$=,9FQO870I:"P@#0H@("`@("`@(#,J*$=,9FQO870I=R\H1TQF
M;&]A="EH+"`M,RP@,RP@+3$P+C`L(#$P+C`I.PT*("`@(&=L36%T<FEX36]D
M92A'3%]-3T1%3%9)15<I.PT*("`@(&=L3&]A9$ED96YT:71Y*"D[#0I]#0H-
M"B\J(#T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T@*B\-"B\J($1)4U!,
M05D@1E5.0U1)3TX@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J(#T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T@*B\-"G9O:60@0T%,3$)!0TL@:'=$:7-P;&%Y*'9O
M:60I#0I[#0H):6YT(&]B:D-O=6YT.PT*("`@(&=L36%T<FEX36]D92A'3%]-
M3T1%3%9)15<I.PT*"6=L0VQE87(H1TQ?0T],3U)?0E5&1D527T))5"!\($=,
M7T1%4%1(7T)51D9%4E]"250I.PT*"69O<BAO8FI#;W5N=#T@,#L@;V)J0V]U
M;G0\,SL@;V)J0V]U;G0K*RD-"@E[#0H)"6AW4F5N9&5R*"9H=T]B:F5C='-;
M;V)J0V]U;G1=*3L-"@E]#0H)9VQ&;'5S:"@I.PT*"6%U>%-W87!"=69F97)S
M*"D[#0H-"GT-"B\J(#T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T@*B\-
M"B\J(%)%3D1%4B!&54Y#5$E/3B`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*B\-"B\J(#T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]
M/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T@*B\-"G9O:60@:'=296YD97(H2%=/
M0DI%0U0@*F]B:F5C="D-"GL-"@EG;%!U<VA-871R:7@H*3L-"@EG;$UA=&5R
M:6%L9G8H1TQ?1E)/3E1?04Y$7T)!0TLL($=,7T5-25-324].+"!O8FIE8W0M
M/F5M:7-S:6]N*3L-"@EG;$UA=&5R:6%L9G8H1TQ?1E)/3E1?04Y$7T)!0TLL
M($=,7T%-0DE%3E0L(&]B:F5C="T^86UB:65N="D[#0H)9VQ-871E<FEA;&9V
M*$=,7T923TY47T%.1%]"04-++"!'3%]34$5#54Q!4BP@;V)J96-T+3YS<&5C
M=6QA<BD[#0H)9VQ-871E<FEA;&9V*$=,7T923TY47T%.1%]"04-++"!'3%]%
M34E34TE/3BP@;V)J96-T+3YS<&5C=6QA<BD[#0H)9VQ-871E<FEA;&9V*$=,
M7T923TY47T%.1%]"04-++"!'3%]$249&55-%+"!O8FIE8W0M/F1I9F9U<V4I
M.PT*"6=L5')A;G-L871E9BAO8FIE8W0M/GA0;W-I=&EO;BP@;V)J96-T+3YY
M4&]S:71I;VXL(&]B:F5C="T^>E!O<VET:6]N*3L)#0H)9VQ2;W1A=&5F*&]B
M:F5C="T^>$%N9VQE+"`H1TQF;&]A="DQ+C`L("A'3&9L;V%T*3`N,"PH1TQF
M;&]A="DP+C`I.PT*"6=L4F]T871E9BAO8FIE8W0M/GE!;F=L92P@*$=,9FQO
M870I,"XP+"`H1TQF;&]A="DQ+C`L*$=,9FQO870I,"XP*3L-"B`@("!G;%)O
M=&%T968H;V)J96-T+3YZ06YG;&4L("A'3&9L;V%T*3`N,"P@*$=,9FQO870I
M,"XP+"A'3&9L;V%T*3$N,"D[#0H)<W=I=&-H*&]B:F5C="T^;V)J96-T260I
M#0H)>PT*"2`@("!C87-E(%-02$5213H-"@D@("`@>PT*"0D)#0H)("`@("`@
M("!A=7A3;VQI9%-P:&5R92AO8FIE8W0M/G-I>F4I.PT*"0D@("`@8G)E86L[
M#0H)("`@('T-"@D@("`@8V%S92!#54)%.@T*"2`@("![#0H)"0D-"B`@("`@
M("`@("`@(&%U>%-O;&ED0W5B92AO8FIE8W0M/G-I>F4I.PT*"0D@("`@8G)E
M86L[#0H)("`@('T-"@D@("`@8V%S92!414%03U0Z#0H)("`@('L-"B`@("`@
M("`@("`@(&%U>%-O;&ED5&5A<&]T*&]B:F5C="T^<VEZ92D[#0H)"2`@("!B
M<F5A:SL-"@D@("`@?0T*"0ED969A=6QT.@T*"2`@("![#0H)"2`@("!B<F5A
M:SL-"@D@("`@?0T*"7T-"@EG;%!O<$UA=')I>"@I.PT*?0T*<W1A=&EC('9O
M:60@0T%,3$)!0TL@2V5Y7W,H=F]I9"D-"GL-"@EC=7)R96YT3V)J96-T(#T@
M4U!(15)%.PT*?0T*<W1A=&EC('9O:60@0T%,3$)!0TL@2V5Y7V,H=F]I9"D-
M"GL-"@EC=7)R96YT3V)J96-T(#T@0U5"13L-"GT-"G-T871I8R!V;VED($-!
M3$Q"04-+($ME>5]T*'9O:60I#0I[#0H)8W5R<F5N=$]B:F5C="`](%1%05!/
M5#L-"GT-"G-T871I8R!V;VED($-!3$Q"04-+($ME>5]Z*'9O:60I#0I[#0H@
M("`@8W5R<F5N=$]B:F5C="`](%9)15<[#0I]#0H-"G-T871I8R!V;VED($-!
M3$Q"04-+($ME>5]U<"AV;VED*0T*>PT*"6EF*&-U<G)E;G1/8FIE8W0@(3T@
M5DE%5RD-"@E[("`@#0H@("`@("`@(&AW3V)J96-T<UMC=7)R96YT3V)J96-T
M72YX06YG;&4@*ST@*$=,9FQO870I,3`N,#L-"B`@("`@("`@:68H:'=/8FIE
M8W1S6V-U<G)E;G1/8FIE8W1=+GA!;F=L92`^(#,V,"XP*0T*"2`@("![#0H)
M"2`@("!H=T]B:F5C='-;8W5R<F5N=$]B:F5C=%TN>$%N9VQE("T]("`H1TQF
M;&]A="DS-C`N,#L-"@D@("`@?0T*"2`@("!H=T1I<W!L87DH*3L-"@E]#0H)
M96QS90T*"7L-"@D)9VQ-871R:7A-;V1E*$=,7U!23TI%0U1)3TXI.PT*"0EG
M;%)O=&%T968H*$=,9FQO870I,3`N,"PH1TQF;&]A="DQ+C`L("A'3&9L;V%T
M*3`N,"PH1TQF;&]A="DP+C`I.PT*"7T-"GT-"G-T871I8R!V;VED($-!3$Q"
M04-+($ME>5]D;W=N*'9O:60I#0I[#0H):68H8W5R<F5N=$]B:F5C="`A/2!6
M2457*0T*"7L-"B`@("`@("`@:'=/8FIE8W1S6V-U<G)E;G1/8FIE8W1=+GA!
M;F=L92`M/2`H1TQF;&]A="DQ,"XP.PT*("`@("`@("!I9BAH=T]B:F5C='-;
M8W5R<F5N=$]B:F5C=%TN>$%N9VQE(#P@,"XP*0T*"2`@("![#0H)"2`@("!H
M=T]B:F5C='-;8W5R<F5N=$]B:F5C=%TN>$%N9VQE("L]("`H1TQF;&]A="DS
M-C`N,#L-"@D@("`@?0T*"2`@("!H=T1I<W!L87DH*3L-"@E]#0H)96QS90T*
M"7L-"B`@("`@("`@9VQ-871R:7A-;V1E*$=,7U!23TI%0U1)3TXI.PT*"0EG
M;%)O=&%T968H*$=,9FQO870I+3$P+C`L*$=,9FQO870I,2XP+"`H1TQF;&]A
M="DP+C`L*$=,9FQO870I,"XP*3L-"@E]#0I]#0IS=&%T:6,@=F]I9"!#04Q,
M0D%#2R!+97E?;&5F="AV;VED*0T*>PT*"6EF*&-U<G)E;G1/8FIE8W0@(3T@
M5DE%5RD-"@E[#0H@("`@("`@(&AW3V)J96-T<UMC=7)R96YT3V)J96-T72YZ
M06YG;&4@*ST@*$=,9FQO870I,3`N,#L-"B`@("`@("`@:68H:'=/8FIE8W1S
M6V-U<G)E;G1/8FIE8W1=+GI!;F=L92`^(#,V,"XP*0T*"2`@("![#0H)"2`@
M("!H=T]B:F5C='-;8W5R<F5N=$]B:F5C=%TN>D%N9VQE("T]("`H1TQF;&]A
M="DS-C`N,#L-"@D@("`@?0T*"2`@("!H=T1I<W!L87DH*3L-"@E]#0H)96QS
M90T*"7L-"B`@("`@("`@9VQ-871R:7A-;V1E*$=,7U!23TI%0U1)3TXI.PT*
M"0EG;%)O=&%T968H*$=,9FQO870I,3`N,"PH1TQF;&]A="DP+C`L("A'3&9L
M;V%T*3`N,"PH1TQF;&]A="DQ+C`I.PT*"7T-"GT-"G-T871I8R!V;VED($-!
M3$Q"04-+($ME>5]R:6=H="AV;VED*0T*>PT*"6EF*&-U<G)E;G1/8FIE8W0@
M(3T@5DE%5RD-"@E[#0H@("`@("`@(&AW3V)J96-T<UMC=7)R96YT3V)J96-T
M72YZ06YG;&4@+3T@*$=,9FQO870I,3`N,#L-"B`@("`@("`@:68H:'=/8FIE
M8W1S6V-U<G)E;G1/8FIE8W1=+GI!;F=L92`\(#`N,"D-"@D@("`@>PT*"0D@
M("`@:'=/8FIE8W1S6V-U<G)E;G1/8FIE8W1=+GI!;F=L92`K/2`@*$=,9FQO
M870I,S8P+C`[#0H)("`@('T-"@D@("`@:'=$:7-P;&%Y*"D[#0H)?0T*"65L
M<V4-"@E[#0H@("`@("`@(&=L36%T<FEX36]D92A'3%]04D]*14-424].*3L-
M"@D)9VQ2;W1A=&5F*"A'3&9L;V%T*2TQ,"XP+"A'3&9L;V%T*3`N,"P@*$=,
M9FQO870I,"XP+"A'3&9L;V%T*3$N,"D[#0H)?0T*?0T*<W1A=&EC('9O:60@
M0T%,3$)!0TL@2V5Y7VXH=F]I9"D-"GL-"@EI9BAC=7)R96YT3V)J96-T("$]
M(%9)15<I#0H)>PT*("`@("`@("!H=T]B:F5C='-;8W5R<F5N=$]B:F5C=%TN
M>4%N9VQE("L]("A'3&9L;V%T*3$P+C`[#0H@("`@("`@(&EF*&AW3V)J96-T
M<UMC=7)R96YT3V)J96-T72YY06YG;&4@/B`S-C`N,"D-"@D@("`@>PT*"0D@
M("`@:'=/8FIE8W1S6V-U<G)E;G1/8FIE8W1=+GE!;F=L92`M/2`@*$=,9FQO
M870I,S8P+C`[#0H)("`@('T-"@D@("`@:'=$:7-P;&%Y*"D[#0H)?0T*"65L
M<V4-"@E[#0H@("`@("`@(&=L36%T<FEX36]D92A'3%]04D]*14-424].*3L-
M"@D)9VQ2;W1A=&5F*"A'3&9L;V%T*3$P+C`L*$=,9FQO870I,"XP+"`H1TQF
M;&]A="DQ+C`L*$=,9FQO870I,"XP*3L-"@E]#0I]#0IS=&%T:6,@=F]I9"!#
M04Q,0D%#2R!+97E?;2AV;VED*0T*>PT*"6EF*&-U<G)E;G1/8FIE8W0@(3T@
M5DE%5RD-"@E[#0H@("`@("`@(&AW3V)J96-T<UMC=7)R96YT3V)J96-T72YY
M06YG;&4@+3T@*$=,9FQO870I,3`N,#L-"B`@("`@("`@:68H:'=/8FIE8W1S
M6V-U<G)E;G1/8FIE8W1=+GE!;F=L92`\(#`N,"D-"@D@("`@>PT*"0D@("`@
M:'=/8FIE8W1S6V-U<G)E;G1/8FIE8W1=+GE!;F=L92`K/2`@*$=,9FQO870I
M,S8P+C`[#0H)("`@('T-"@D@("`@:'=$:7-P;&%Y*"D[#0H)?0T*"65L<V4-
M"@E[#0H@("`@("`@(&=L36%T<FEX36]D92A'3%]04D]*14-424].*3L-"@D)
M9VQ2;W1A=&5F*"A'3&9L;V%T*2TQ,"XP+"A'3&9L;V%T*3`N,"P@*$=,9FQO
>870I,2XP+"A'3&9L;V%T*3`N,"D[#0H)?0T*?0T*
`
end
SHAR_EOF
  $shar_touch -am 0207071897 'hwmain.c' &&
  chmod 0640 'hwmain.c' ||
  $echo 'restore of' 'hwmain.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hwmain.c:' 'MD5 check failed'
ad4914f2ce3099919a530e556e06f4ab  hwmain.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hwmain.c'`"
    test 18750 -eq "$shar_count" ||
    $echo 'hwmain.c:' 'original size' '18750,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh19901
exit 0

From ???@??? Fri Feb 07 07:33:30 1997
Received: from magritte.its.rpi.edu (anandk@magritte.its.rpi.edu [128.113.113.19])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id WAA38772
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 22:15:54 -0500
From: Kanwaljit Singh Anand <anandk>
Received: (anandk@localhost) by magritte.its.rpi.edu (8.6.9/8.6.4) id WAA66928 for citrit@rpi.edu; Thu, 6 Feb 1997 22:15:52 -0500
Date: Thu, 6 Feb 1997 22:15:52 -0500
Message-Id: <199702070315.WAA66928@magritte.its.rpi.edu>
To: citrit@rpi.edu
Subject: homework #1
X-UIDL: 9e6c2538f6370273925357bb7eae968e

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 22:11 EST by <anandk@magritte>.
# Source directory was `/afs/rpi.edu/home/38/anandk/private/ACG/homework1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  15443 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh126106; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* HW#1: Graphics and Visualization. Kanwaljit Anand */
/* Was written, compiled and tested on the SGI system */
X
#include <stdio.h>
#include <stdlib.h>
X
#include <GL/gl.h>
#include <GL/glut.h>
X
X		int parent = 0;
X		int new_win = 0;
X		int parent_menu = 0;
X		
X		int MODE = 1;
X
X    	GLfloat RED[]    = {1.0, 0.0, 0.0, 1.0};
X    	GLfloat YELLOW[] = {1.0, 1.0, 0.0, 1.0};
X    	GLfloat BLUE[]   = {0.0, 0.0, 1.0, 1.0};
X    
X    	int TEAPOT = 1;
X    	int CUBE   = 1;
X    	int SPHERE = 1;
X    
X    	float TEAPOT_SCALING = 1.0;
X    	float CUBE_SCALING = 1.0;
X    	float SPHERE_SCALING = 1.0;
X    
X    	float TEAPOT_ROTATION = 0.0;
X    	float CUBE_ROTATION = 30.0;
X    	float SPHERE_ROTATION = 0.0;
X
X		float CUBE_RX = 1.0;
X		float CUBE_RY = 0.0;
X		float CUBE_RZ = 1.0;
X
X		float TEAPOT_RX = 1.0;
X		float TEAPOT_RY = 1.0;
X		float TEAPOT_RZ = 1.0;
X
X		float SPHERE_RX = 1.0;
X		float SPHERE_RY = 1.0;
X		float SPHERE_RZ = 1.0;
X		
X		float CUBE_TX = 0.0;
X		float TEAPOT_TX = -1.0;
X		float SPHERE_TX = 1.0;
X
X		float CUBE_TY = 0.0;
X		float TEAPOT_TY = 0.0;
X		float SPHERE_TY = 0.0;
X				
X		int W = 600;
X		int H = 500;
X		
X		float XV = 0.0;
X		float YV = 0.0;
X		
X		int TRANSPARENT = 0;
X		
X			
void myInit(void)
{
X    GLfloat ambient[]  = { 0.1, 0.1, 0.1, 1.0 };     
X    GLfloat diffuse[]  = { 0.8, 0.8, 0.8, 1.0 };     
X    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };     
X    GLfloat position[] = { 3.0, 3.0, 3.0, 0.0 }; 
X    
X    glEnable(GL_DEPTH_TEST);     
X    glDepthFunc(GL_LEQUAL);
X    
X    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
X 
X    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);     
X    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);     
X    glLightfv(GL_LIGHT0, GL_POSITION, position);      
X    
X    glEnable(GL_LIGHTING);
X    glEnable(GL_LIGHT0);
}
X
X
void Compute_Cube(float SCALE, float ROTATE, float RX, float RY, float RZ)
{
X 	float mat[4];
X   glPushMatrix();
X   glRotatef(ROTATE, RX, RY, RZ);
X   glColor4fv(RED);
X    
X   glScalef(SCALE, SCALE, SCALE);
X   glTranslatef(CUBE_TX, CUBE_TY, 0.0);
X
X   mat[0] = 0.8; mat[1] = 0.0; mat[2] = 0.0;  mat[3]=1.0;
X   glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
X   mat[0] = 0.8; mat[1] = 0.0; mat[2] = 0.0;  mat[3]=1.0;
X   glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
X   mat[0] = 0.9; mat[1] = 0.9; mat[2] = 0.9; mat[3]=1.0;
X   glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
X   glMaterialf (GL_FRONT, GL_SHININESS, 0.8*128.0);
X        
X   glutSolidCube(0.5);
X   glPopMatrix();
}
X
void Compute_Teapot(float SCALE, float ROTATE, float RX, float RY, float RZ)
{
X 	float mat[4];
X
X 	float transparent[] = {0.8, 0.8, 0.0, 0.25};
X 	
X   glPushMatrix();
X       
X   glRotatef(ROTATE, RX, RY, RZ);
X   glColor4fv(YELLOW);
X   glScalef(SCALE, SCALE, SCALE);
X   glTranslatef(TEAPOT_TX, TEAPOT_TY, 0.0);
X
X   mat[0] = 0.8; mat[1] = 0.8; mat[2] = 0.0; mat[3]=1.0;
X   glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, mat);
X
X   mat[0] = 0.8; mat[1] = 0.8; mat[2] = 0.0;  mat[3]=1.0;
X   glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, mat); 
X   glMaterialf (GL_FRONT_AND_BACK, GL_SHININESS, 0.5*128.0);
X
X   if(TRANSPARENT == 0)
X   {
X   	mat[0] = 0.8; mat[1] = 0.8; mat[2] = 0.0;  mat[3]=1.0;
X   	glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, mat);
X   	glutSolidTeapot(0.25);
X   }
X   
X   if(TRANSPARENT == 1)
X   {
X		glEnable(GL_BLEND);  
X     	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, transparent);
X   	glutSolidTeapot(0.25);
X		glDisable(GL_BLEND);  
X	}
X   glPopMatrix();
}
X
void Compute_Sphere(float SCALE, float ROTATE, float RX, float RY, float RZ)
{
X 	float mat[4];
X
X   glPushMatrix();
X   	glRotatef(ROTATE, RX, RY, RZ);
X   	glColor4fv(BLUE);
X   	glScalef(SCALE, SCALE, SCALE);
X   	glTranslatef(SPHERE_TX, SPHERE_TY, 0.0);
X   		mat[0] = 0.0; mat[1] = 0.0; mat[2] = 0.8;  mat[3]=1.0;
X   	glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
X   		mat[0] = 0.0; mat[1] = 0.0; mat[2] = 0.8;  mat[3]=1.0;
X   	glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
X   		mat[0] = 0.0; mat[1] = 0.0; mat[2] = 0.8;  mat[3]=1.0;
X   	glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
X   	glMaterialf (GL_FRONT, GL_SHININESS, 0.1*128.0);
X   	glutSolidSphere(0.25, 100, 100);
X   glPopMatrix();    
}
X
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);
X      glMatrixMode (GL_MODELVIEW);  
}
X
void Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION += 15.0;
X			CUBE_RX += 0.0;
X			CUBE_RY += 1.0;
X			CUBE_RZ += 0.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION += 15.0;
X			TEAPOT_RX += 0.0;
X			TEAPOT_RY += 1.0;
X			TEAPOT_RZ += 0.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION += 15.0;
X			SPHERE_RX += 0.0;
X			SPHERE_RY += 1.0;
X			SPHERE_RZ += 0.0;
X    }
X    break;
X    case 'j':
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION += 15.0;
X			CUBE_RX += 1.0;
X			CUBE_RY += 0.0;
X			CUBE_RZ += 0.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION += 15.0;
X			TEAPOT_RX += 1.0;
X			TEAPOT_RY += 0.0;
X			TEAPOT_RZ += 0.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION += 15.0;
X			SPHERE_RX += 1.0;
X			SPHERE_RY += 0.0;
X			SPHERE_RZ += 0.0;
X    }
X    break;
X    case 'k':
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION -= 15.0;
X			CUBE_RX += 1.0;
X			CUBE_RY += 0.0;
X			CUBE_RZ += 0.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION -= 15.0;
X			TEAPOT_RX += 1.0;
X			TEAPOT_RY += 0.0;
X			TEAPOT_RZ += 0.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION -= 15.0;
X			SPHERE_RX += 1.0;
X			SPHERE_RY += 0.0;
X			SPHERE_RZ += 0.0;
X    }
X    break;
X    
X    case 'u':	/* up */
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION += 15.0;
X			CUBE_RX += 0.0;
X			CUBE_RY += 0.0;
X			CUBE_RZ += 1.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION += 15.0;
X			TEAPOT_RX += 0.0;
X			TEAPOT_RY += 0.0;
X			TEAPOT_RZ += 1.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION += 15.0;
X			SPHERE_RX += 0.0;
X			SPHERE_RY += 0.0;
X			SPHERE_RZ += 1.0;
X    }
X    break;
X    case 'd': /* Down */
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION -= 15.0;
X			CUBE_RX += 0.0;
X			CUBE_RY += 0.0;
X			CUBE_RZ += 1.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION -= 15.0;
X			TEAPOT_RX += 0.0;
X			TEAPOT_RY += 0.0;
X			TEAPOT_RZ += 1.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION -= 15.0;
X			SPHERE_RX += 0.0;
X			SPHERE_RY += 0.0;
X			SPHERE_RZ += 1.0;
X    }
X    break;
X        
X    case 'l':
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_ROTATION -= 15.0;
X			CUBE_RX += 0.0;
X			CUBE_RY += 1.0;
X			CUBE_RZ += 0.0;
X    }    
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_ROTATION -= 15.0;
X			TEAPOT_RX += 0.0;
X			TEAPOT_RY += 1.0;
X			TEAPOT_RZ += 0.0;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_ROTATION -= 15.0;
X			SPHERE_RX += 0.0;
X			SPHERE_RY += 1.0;
X			SPHERE_RZ += 0.0;
X    }
X    break;
X  case 'b':
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			CUBE_SCALING += 0.5;
X    }
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_SCALING += 0.5;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_SCALING += 0.5;
X    }
X    break;   
X  case 's':						    /* S for smaller */
X    if(CUBE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			(CUBE_SCALING -= 0.5);
X    }
X    if(TEAPOT == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			TEAPOT_SCALING -= 0.5;
X    }
X    if(SPHERE == 1)
X    {
X			glMatrixMode (GL_MODELVIEW);
X			SPHERE_SCALING -= 0.5;
X    }
X    break;
X  case 't':
X    if(CUBE   == 1)    		  CUBE_TY += 0.25;
X    if(TEAPOT == 1)    		TEAPOT_TY += 0.25;
X    if(SPHERE == 1)			SPHERE_TY += 0.25;
X	break;
X  case 'v':
X    if(CUBE   == 1)    		  CUBE_TY -= 0.25;
X    if(TEAPOT == 1)    		TEAPOT_TY -= 0.25;
X    if(SPHERE == 1)			SPHERE_TY -= 0.25;
X 	break;
X  case 'g':
X    if(CUBE   == 1)    		  CUBE_TX += 0.25;
X    if(TEAPOT == 1)    		TEAPOT_TX += 0.25;
X    if(SPHERE == 1)			SPHERE_TX += 0.25;
X	break;
X  case 'f':
X    if(CUBE   == 1)    		  CUBE_TX -= 0.25;
X    if(TEAPOT == 1)    		TEAPOT_TX -= 0.25;
X    if(SPHERE == 1)			SPHERE_TX -= 0.25;
X 	 break;
X  case '1':
X  		W  -= 25.0;
X  		H  -= 25.0;
X  		XV -= 0.10;
X  		YV -= 0.10;
X  		
X      glPushMatrix();
X      glMatrixMode(GL_PROJECTION);
X      glViewport(XV, YV, W, H);
X      glMatrixMode (GL_MODELVIEW);
X      glPopMatrix();
X      
X      break;		
X
X  case '2':   		
X  		W  += 25.0;
X  		H  += 25.0;
X  		XV += 0.10;
X  		YV += 0.10;
X  		
X      glPushMatrix();
X      glMatrixMode(GL_PROJECTION);
X      glViewport(XV, YV, W, H);
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */ 
X      glPopMatrix();
X      
X      break;		
X  case 'q':           /* q for quit */
X    exit(1);
X    break;
X  case 27:           /* Esc will quit */
X    exit(1);
X    break;
X  default:
X    break;
X    }
X    
X	glutPostRedisplay();
}
X
void new_main();
void old_main();
X
void Select(int value)
{
X    switch (value) 
X    {
X	case 6:
X	    exit(0);
X	    break;
X   case 5:
X   	if(MODE == 1)
X   	{
X   		MODE = 0;
X   		printf("Changing to Single Buffer Mode\n");
X   		glutDestroyWindow(parent);   	
X   		new_main();
X   		glutChangeToMenuEntry(5, "Change to Double Buffer ", 5);
X   	}
X   	
X   	else if(MODE == 0)
X   	{
X   		MODE = 1;
X   		printf("Changing to Double Buffer Mode\n");
X   		glutDestroyWindow(new_win);
X   		old_main();
X   		glutChangeToMenuEntry(5, "Change to Single Buffer", 5);
X   	}
X		break;   	
X	case 4:		
X	    if( TRANSPARENT == 0 )
X	    {			
X				TRANSPARENT = 1;
X				glutPostRedisplay();
X				printf("\tTeapot made transparent\n");
X   			glutChangeToMenuEntry(4, "Make Teapot Opaque ", 4);
X   	 }
X	    else if( TRANSPARENT == 1 )
X	    {		
X				TRANSPARENT = 0;
X				glutPostRedisplay();
X				printf("\tTeapot made opaque\n");
X   			glutChangeToMenuEntry(4, "Make Teapot Transparent ", 4);
X   	 }
X	break;
X
X	case 3:
X	    if( TEAPOT == 0 )
X	    {			
X				TEAPOT = 1;
X				printf("\tTeapot was re-selected\n");
X   			glutChangeToMenuEntry(3, "De-Select TEAPOT ", 3);
X   	 }
X	    else if( TEAPOT == 1 )
X	    {			
X				printf("\tTeapot was de-selected\n");
X				TEAPOT = 0;
X   			glutChangeToMenuEntry(3, "Re-Select TEAPOT ", 3);
X   	 }
X	break;
X
X	case 2:
X	    if( CUBE == 0 )
X	    {			
X				CUBE = 1;
X				printf("\tCube was re-selected\n");
X   			glutChangeToMenuEntry(2, "De-Select CUBE ", 2);
X   	 }
X	    else if( CUBE == 1 )
X	    {			
X				printf("\tCube was de-selected\n");
X				CUBE = 0;
X   			glutChangeToMenuEntry(2, "Re-Select CUBE ", 2);
X   	 }
X	break;
X	
X	case 1:
X	    if( SPHERE == 0 )
X	    {			
X				SPHERE = 1;
X				printf("\tSphere was re-selected\n");
X   			glutChangeToMenuEntry(1, "De-Select SPHERE ", 1);
X   	 }
X	    else if( SPHERE == 1 )
X	    {			
X				printf("\tSphere was de-selected\n");
X				SPHERE = 0;
X   			glutChangeToMenuEntry(1, "Re-Select SPHERE ", 1);
X   	 }
X	break;
X    }
}
X
void display(void)
{
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X   
X    Compute_Cube(CUBE_SCALING, CUBE_ROTATION, CUBE_RX, CUBE_RY, CUBE_RZ);
X    Compute_Sphere(SPHERE_SCALING, SPHERE_ROTATION, SPHERE_RX, SPHERE_RY, SPHERE_RZ);
X    Compute_Teapot(TEAPOT_SCALING, TEAPOT_ROTATION, TEAPOT_RX, TEAPOT_RY, TEAPOT_RZ);
X    
X    if(MODE == 1)    glutSwapBuffers(); 
}
X
void Usage()
{
X	printf("\n\n\t\t\tHome Work #1\n\n");
X	printf("USAGE:\n\tUse the Right Mouse button to select/de-select objects\n");
X	printf("\t1, 2, or all 3 objects can be [un-]selected at any given time\n");
X	printf("\nScaling:\n\tUse \"b\" for bigger and \"s\" for making the object smaller\n");
X	printf("\nTranslation:\n\tUse \"f\" for moving left, \"g\" for right; \"t\" for up & \"v\" for down\n");
X	printf("\nRotations:\n\tUse \"k\", \"h\" & \"u\" for Counter CW motion about X, Y, & Z respectively\n"); 
X	printf("\tUse \"j\", \"l\" & \"d\" for Clock-wise motion about X, Y, & Z respectively\n");
X	printf("\nViewport:\n\tUse \"1\" and \"2\" to change camera viewpoint\n");
X	printf("\n\tUsing \"q\" or \"Esc\" will terminate the program\n\n");
X	printf("\nToggle between making the Teapot Opaque and Transparent using the Menu\n");
X	printf("\nToggle between Single & Doubble Buffer using the Menu\n\n");
X	
}
X
int main(int argc, char** argv) 
{
X    	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);	/* Set Initial Display Mode to Double_Buffer */
X    	glutInitWindowPosition(150, 250);					/* Set Window Position */
X    	glutInitWindowSize(600, 500);							/* Set Window Size */
X    	glutInit(&argc, argv);									/* Initialize the GLUT library */
X		parent = glutCreateWindow("HomeWork #1: DOUBLE BUFFER MODE");			/* Create a Top-level window */
X		myInit();													/* Initialize lights and glEnables' */
X      Usage();														/* Print information to term about usage */
X      glutKeyboardFunc(Key);									
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      parent_menu = glutCreateMenu(Select);
X      glutAddMenuEntry("De-Select SPHERE", 1);
X      glutAddMenuEntry("De-Select CUBE", 2);
X      glutAddMenuEntry("De-Select TEAPOT", 3);
X      glutAddMenuEntry("Make Teapot Transparent", 4);
X      glutAddMenuEntry("Change to single buffer Mode", 5);
X      glutAddMenuEntry("Quit", 6);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
void new_main()
{
X   	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
X    	glutInitWindowPosition(150, 250);					/* Set Window Position */
X    	glutInitWindowSize(600, 500);							/* Set Window Size */
X		new_win = glutCreateWindow("HomeWork #1:Single Buffer Mode");			/* Create a Top-level window */
X		myInit();		
X		CUBE = 1; SPHERE = 1; TEAPOT = 1;
X      glutKeyboardFunc(Key);									
X      glutReshapeFunc (myReshape);
X      
X      glutDisplayFunc(display);
X      glutDestroyMenu(parent_menu);
X      parent_menu = glutCreateMenu(Select);
X      glutAddMenuEntry("De-Select SPHERE", 1);
X      glutAddMenuEntry("De-Select CUBE", 2);
X      glutAddMenuEntry("De-Select TEAPOT", 3);
X      glutAddMenuEntry("Make Teapot Transparent", 4);
X      glutAddMenuEntry("Change to Double buffer Mode", 5);
X      glutAddMenuEntry("Quit", 6);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
void old_main()
{
X   	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
X    	glutInitWindowPosition(150, 250);					/* Set Window Position */
X    	glutInitWindowSize(600, 500);							/* Set Window Size */
X		parent = glutCreateWindow("HomeWork #1:Double Buffer Mode");			/* Create a Top-level window */
X		myInit();													/* Initialize lights and glEnables' */
X      
X		CUBE = 1; SPHERE = 1; TEAPOT = 1;
X      glutKeyboardFunc(Key);									
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X 
X      glutDestroyMenu(parent_menu);
X      parent_menu = glutCreateMenu(Select);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("De-Select SPHERE", 1);
X      glutAddMenuEntry("De-Select CUBE", 2);
X      glutAddMenuEntry("De-Select TEAPOT", 3);
X      glutAddMenuEntry("Make Teapot Transparent", 4);
X      glutAddMenuEntry("Change to single buffer Mode", 5);
X      glutAddMenuEntry("Quit", 6);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206221097 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
9b39dd9f09674a9d04710f53cf7aa7e7  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 15443 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '15443,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh126106
exit 0

From ???@??? Fri Feb 07 07:34:25 1997
Received: from cs.rpi.edu (root@cs.rpi.edu [128.213.1.1])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA26042
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:47:02 -0500
Received: from fridge.cs.rpi.edu (moriartk@fridge.cs.rpi.edu [128.213.2.50])
	by cs.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA25693
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:46:58 -0500 (EST)
From: Kathleen Moriarty <moriartk@cs.rpi.edu>
Received: (from moriartk@localhost)
	by fridge.cs.rpi.edu (8.8.5/8.8.5) id XAA29297
	for citrit@rpi.edu; Thu, 6 Feb 1997 23:46:55 -0500 (EST)
Date: Thu, 6 Feb 1997 23:46:55 -0500 (EST)
Message-Id: <199702070446.XAA29297@fridge.cs.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: be5cbbf6eddad4183153f3a4337f529a

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  hw1.c
# Wrapped by moriartk@fridge.cs.rpi.edu on Thu Feb  6 23:46:21 1997
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive."'
if test -f 'hw1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hw1.c'\"
else
  echo shar: Extracting \"'hw1.c'\" \(10242 characters\)
  sed "s/^X//" >'hw1.c' <<'END_OF_FILE'
X/*
X *  Kathleen Moriarty
X *
X *  hw1.c 
X *
X *  Simple example of programming using the OpenGL graphics library
X *  Taken from the "OpenGL Programming Guide"
X *
X *  Edited by: Kathleen Moriarty to do hw1
X *
X *  Purpose:  Draws 3 objects: a blue sphere, a red cube, and a transparent
X *	yellow teapot.  Eah of the objects rotate together and can rotate
X * 	by themselves through the use of the menu system that comes up
X *	using the right mouse button and the letters on the keyboard
X *	h, j, k, and l.  The objects also scale in size through the
X *	use of the same menu system.
X *
X *
X *
X */
X
X/* Includes required */
X#ifdef WIN32
X#include <windows.h>
X#endif
X#include <GL/gl.h> 
X#include <GL/glut.h>
X
Xint all;
Xint sphere, cube, teapot;
Xint movewhich, dir;
Xint scalesphere, scalecube, scaleteapot;
X
X/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
Xvoid display(void)
X{
X      static float sphereAmb[4] = {0.0, 0.0, 9.0, 1.0};
X      static float sphereDiff[4] = {0.1, 0.1, 0.1, 1.0};
X      static float sphereSpec[4] = {0.2, 0.2, 0.2, 1.0};
X      static float sphereMat[4] = {0.1, 0.1, 0.1, 1.0};
X
X      static float cubediffuse[4] = {0.5, 0.5,0.5, 1.0};
X      static float cubeAmb[4] = {9.0, 0.0, 0.0, 1.0};
X      static float cubeSpec[4] = {1.0, 1.0, 1.0, 1.0};
X      static float no_mat[4] = {0.2, 0.2, 0.2, 1.0};
X
X      static float teapotdiffuse[4] = {0.1, 0.1, 0.1, 0.1};
X      static float teapotAmb[4] = {9.0, 9.0, 0.0, 0.9};
X      static float teapotSpec[4] = {0.8, 0.8, 0.8, 0.9};
X
X
X      /* This is where the sphere is drawn & scaled & rotated */
X      glPushMatrix();
X          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X      if (scalesphere == 1)
X          glScalef(2.0, 2.0, 2.0);
X      if (scalesphere == 0)
X          glScalef(1.0, 1.0, 1.0);
X
X      if ((dir == 1) && ((movewhich == 0) || (movewhich == 1))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix h */
X        glRotatef(15.0, 0.0,1.0,0.0); }
X      if ((dir == 2) && ((movewhich == 0) || (movewhich == 1))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix j */
X        glRotatef(15.0, 1.0,0.0,0.0);  }
X      if ((dir == 3) && ((movewhich == 0) || (movewhich == 1))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix k */
X        glRotatef(-15.0, 1.0,0.0,0.0); }
X      if ((dir == 4) && ((movewhich == 0) || (movewhich == 1))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix l */
X        glRotatef(-15.0, 0.0,1.0,0.0); }
X
X          glTranslatef(2.00, 0.30, 0.0); 
X          glMaterialfv(GL_FRONT, GL_AMBIENT, sphereAmb);
X          glMaterialfv(GL_FRONT, GL_DIFFUSE, sphereDiff);
X          glMaterialfv(GL_FRONT, GL_SPECULAR, sphereSpec);
X	  glMaterialfv(GL_FRONT, GL_EMISSION, sphereMat); 
X      	  glMaterialf(GL_FRONT, GL_SHININESS, 10.0);
X      glutSolidSphere(1.0, 50, 50);   /*  draw the cube       */
X      glPopMatrix();
X
X
X      /* Here is where the cube is drawn & scaled & rotated */
X
X      glPushMatrix();
X
X      if (scalecube == 1)
X          glScalef(2.0, 2.0, 2.0);
X      if (scalecube == 0)
X          glScalef(1.0, 1.0, 1.0);
X
X      if ((dir == 1) && ((movewhich == 0) || (movewhich == 2))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix h */
X        glRotatef(15.0, 0.0,1.0,0.0); }
X      if ((dir == 2) && ((movewhich == 0) || (movewhich == 2))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix j */
X        glRotatef(15.0, 1.0,0.0,0.0);  }
X      if ((dir == 3) && ((movewhich == 0) || (movewhich == 2))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix k */
X        glRotatef(-15.0, 1.0,0.0,0.0); }
X      if ((dir == 4) && ((movewhich == 0) || (movewhich == 2))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix l */
X        glRotatef(-15.0, 0.0,1.0,0.0); }
X
X          /* glTranslatef(0.00, 0.00, 0.0); don't need this because 
X		it's in the middle */
X          glMaterialfv(GL_FRONT, GL_AMBIENT, cubeAmb);
X	  glMaterialfv(GL_FRONT, GL_DIFFUSE, cubediffuse);
X          glMaterialfv(GL_FRONT, GL_SPECULAR, cubeSpec);
X	  glMaterialf(GL_FRONT, GL_SHININESS, 100.0);
X	  glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
X      glutSolidCube(1.0);
X      glPopMatrix();
X    
X 
X      /* This is where the teapot is drawn & scaled & rotated */
X
X      glPushMatrix(); 
X
X      if (scaleteapot == 1)
X          glScalef(2.0, 2.0, 2.0);
X      if (scaleteapot == 0)
X          glScalef(1.0, 1.0, 1.0);
X
X      if ((dir == 1) && ((movewhich == 0) || (movewhich == 3))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix h */
X        glRotatef(15.0, 0.0,1.0,0.0); }
X      if ((dir == 2) && ((movewhich == 0) || (movewhich == 3))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix j */
X        glRotatef(15.0, 1.0,0.0,0.0);  }
X      if ((dir == 3) && ((movewhich == 0) || (movewhich == 3))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix k */
X        glRotatef(-15.0, 1.0,0.0,0.0); }
X      if ((dir == 4) && ((movewhich == 0) || (movewhich == 3))) {
X        glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix l */
X        glRotatef(-15.0, 0.0,1.0,0.0); }
X
X	  glTranslatef(-2.00, 0.60, 0.0); 
X          glEnable(GL_BLEND);
X          glMaterialfv(GL_FRONT, GL_AMBIENT, teapotAmb);
X	  glMaterialfv(GL_FRONT, GL_DIFFUSE, teapotdiffuse);
X          glMaterialfv(GL_FRONT, GL_SPECULAR, teapotSpec);
X	  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X      glutSolidTeapot(1.0);
X          glDisable(GL_BLEND);   
X      glPopMatrix();
X    
X      glutSwapBuffers(); 
X}
X
X/* Initialize shading model */
Xvoid myInit(void)
X{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X/*        glShadeModel (GL_FLAT);
X *     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
X}
X
X/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
Xvoid myReshape(int w, int h)
X{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
X}
X
X/*
X * Keyboard handler
X */
Xvoid
XKey(unsigned char key, int x, int y)
X{
X    switch (key) {
X    case 'h':
X      if (movewhich == 0) {
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0); }
X      dir = 1;
X      break;
X    case 'j':
X      if (movewhich == 0) {
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);  }
X      dir = 2;
X      break;
X    case 'k':
X      if (movewhich == 0) {
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 1.0,0.0,0.0); }
X      dir = 3;
X      break;
X    case 'l':
X      if (movewhich == 0) {
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 0.0,1.0,0.0); }
X      dir = 4;
X      break;
X    case '0':
X      movewhich = 0;	/* rotate camera matrix or all objects together */
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      break;
X    case '1':
X      movewhich = 1;  	/* sphere */
X      break;
X    case '2':
X      movewhich = 2;	/* cube */
X      break;
X    case '3':
X      movewhich = 3;	/* teapot */
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
X}
X
X/*
X *  Handle Menus
X */
Xvoid
XSelect(int value)
X{
X    switch (value) {
X    case 12:
X        exit(0);
X        break;
X    case 2:
X      movewhich = 1;    /* sphere */
X      break;
X    case 3:
X      movewhich = 2;    /* cube */
X      break;
X    case 4:
X      movewhich = 3;    /* teapot */
X      break;
X    case 5:
X      movewhich = 0;    /* all */
X      break;
X    case 6:
X      scalesphere = 1;    /* scale sphere */
X      break;
X    case 7:
X      scalesphere = 0;    /* scale sphere */
X      break;
X    case 8:
X      scalecube = 1;    /* scale cube */
X      break;
X    case 9:
X      scalecube = 0;    /* scale cube */
X      break;
X    case 10:
X      scaleteapot = 1;    /* scale teapot */
X      break;
X    case 11:
X      scaleteapot = 0;    /* scale teapot */
X      break;
X
X    }
X    glutPostRedisplay();
X}
X
X/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
Xint main(int argc, char** argv) 
X{
X      all = 0;
X      dir = 0;
X      sphere = 1;
X      cube = 2;
X      teapot = 3;
X      movewhich = 0;
X      scalesphere = 0;
X      scalecube = 0;
X      scaleteapot = 0;
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Use h, j, k, l to Rotate the objects", 1);
X      glutAddMenuEntry("Rotate Sphere", 2);
X      glutAddMenuEntry("Rotate Cube", 3);
X      glutAddMenuEntry("Rotate Teapot", 4);
X      glutAddMenuEntry("Rotate All", 5);
X      glutAddMenuEntry("Scale Sphere", 6);
X      glutAddMenuEntry("UnScale Sphere", 7);
X      glutAddMenuEntry("Scale Cube", 8);
X      glutAddMenuEntry("UnScale Cube", 9);
X      glutAddMenuEntry("Scale Teapot", 10);
X      glutAddMenuEntry("UnScale Teapot", 11);
X      glutAddMenuEntry("Quit", 12);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
X}
X
X
END_OF_FILE
  if test 10242 -ne `wc -c <'hw1.c'`; then
    echo shar: \"'hw1.c'\" unpacked with wrong size!
  fi
  # end of 'hw1.c'
fi
echo shar: End of archive.
exit 0

From ???@??? Fri Feb 07 07:33:25 1997
Received: from marcus.its.rpi.edu (clarkl@marcus.its.rpi.edu [128.113.113.16])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id TAA31830
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 19:50:13 -0500
From: Landon David Clark <clarkl>
Received: (clarkl@localhost) by marcus.its.rpi.edu (8.6.9/8.6.4) id TAA106402 for citrit@rpi.edu; Thu, 6 Feb 1997 19:50:12 -0500
Date: Thu, 6 Feb 1997 19:50:12 -0500
Message-Id: <199702070050.TAA106402@marcus.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: dc9b17c8d99400fc44d35c15c3252757

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:49 EST by <clarkl@marcus>.
# Source directory was `/afs/rpi.edu/home/92/clarkl/advgra/temp'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    898 -rw-r--r-- Makefile.sgi
#   8946 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh52801; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile.sgi ==============
if test -f 'Makefile.sgi' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.sgi' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.sgi' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.sgi' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lMesaaux -lMesatk -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=cc
X
TARGET = simple
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LDFLAGS)
X
lorenz:    lorenz.o
X	$(CC) $(CFLAGS) -o $@ $? $(LIBS)
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0206194597 'Makefile.sgi' &&
  chmod 0644 'Makefile.sgi' ||
  $echo 'restore of' 'Makefile.sgi' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.sgi:' 'MD5 check failed'
a911ac703d77657be3fecce582d7478a  Makefile.sgi
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.sgi'`"
    test 898 -eq "$shar_count" ||
    $echo 'Makefile.sgi:' 'original size' '898,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* Landon Clark */
/* Adv. Computer Graphics */
/* HW1 */
X
X
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
float cub_x_trans = 0, cub_y_trans = 0, cub_z_trans = 0; /* Placement of the square */  
float cub_x_spin=0, cub_y_spin=0;
float cub_sca = 1.0;
float tea_x_trans = -2, tea_y_trans = 0, tea_z_trans = 0; /* Placement of the square */  
float tea_x_spin=0, tea_y_spin=0;
float tea_sca = 0.6;
float sph_x_trans = 2, sph_y_trans = 0, sph_z_trans = 0; /* Placement of the square */  
float sph_x_spin=0, sph_y_spin=0;
float sph_sca = .6;
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X  GLfloat color_sph[] = { 0.0, 0.0, 1.0, 1.0 };
X  GLfloat color_tea[] = { .4, .4, 0.0, .25 };
X  GLfloat color_cub[] = { 1.0, 0.0, 0.0, 1.0 };
X
X  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X  glPushMatrix();
X  glTranslatef(cub_x_trans, cub_y_trans, cub_z_trans);
X  glRotatef(cub_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(cub_y_spin, 0.0, 1.0, 0.0);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 100.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_cub);
X  glutSolidCube(cub_sca);   /*  draw the cube       */
X  glPopMatrix();
X
X  glPushMatrix();
X  glTranslatef(tea_x_trans, tea_y_trans, tea_z_trans); 
X  glRotatef(tea_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(tea_y_spin, 0.0, 1.0, 0.0);
X  glColor4f(0.0, 0.0, 0.0, .25);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_tea);
X  glutSolidTeapot(tea_sca);   /*  draw the teapot       */
X  glPopMatrix();
X
X  glPushMatrix();
X  glTranslatef(sph_x_trans, sph_y_trans, sph_z_trans);
X  glRotatef(sph_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(sph_y_spin, 0.0, 1.0, 0.0);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_sph);
X  glutSolidSphere(sph_sca, 100, 100);   /*  draw the teapot       */
X  glPopMatrix();
X
X  glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor4f(1.0, 0.0, 0.0, .75);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DITHER); 
X      glEnable(GL_DEPTH_TEST);
X      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
/*      glShadeModel (GL_FLAT);
*     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 1.0,0.0,0.0);
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 0.0,1.0,0.0);
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    case 2:
X	glutKeyboardFunc(Key);
X	break;
X    default:
X	break;
X      }
}
X
void key_cub_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_y_spin+=15;
X    break;
X  case 'j':
X    cub_x_spin+=15;
X    break;
X  case 'k':
X    cub_x_spin+=-15;
X    break;
X  case 'l':
X    cub_y_spin+=-15;
X    break;
X  }
X  if (cub_x_spin > 360)
X    cub_x_spin -= 360;
X  if (cub_y_spin > 360)
X    cub_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_tea_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_y_spin+=15;
X    break;
X  case 'j':
X    tea_x_spin+=15;
X    break;
X  case 'k':
X    tea_x_spin+=-15;
X    break;
X  case 'l':
X    tea_y_spin+=-15;
X    break;
X  }
X  if (tea_x_spin > 360)
X    tea_x_spin -= 360;
X  if (tea_y_spin > 360)
X    tea_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_sph_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_y_spin+=15;
X    break;
X  case 'j':
X    sph_x_spin+=15;
X    break;
X  case 'k':
X    sph_x_spin+=-15;
X    break;
X  case 'l':
X    sph_y_spin+=-15;
X    break;
X  }
X  if (sph_x_spin > 360)
X    sph_x_spin -= 360;
X  if (sph_y_spin > 360)
X    sph_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_cub_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_sca += 1.0;
X    break;
X  case 'j':
X    cub_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_tea_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_sca += 1.0;
X    break;
X  case 'j':
X    tea_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_sph_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_sca += 1.0;
X    break;
X  case 'j':
X    sph_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_cub_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_x_trans -= .5;
X    break;
X  case 'y':
X    cub_x_trans += .5;
X    break;
X  case 'u':
X    cub_y_trans += .5;
X    break;
X  case 'j':
X    cub_y_trans -= .5;
X    break;
X  case 'i':
X    cub_z_trans += .5;
X    break;
X  case 'k':
X    cub_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_tea_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_x_trans -= .5;
X    break;
X  case 'y':
X    tea_x_trans += .5;
X    break;
X  case 'u':
X    tea_y_trans += .5;
X    break;
X  case 'j':
X    tea_y_trans -= .5;
X    break;
X  case 'i':
X    tea_z_trans += .5;
X    break;
X  case 'k':
X    tea_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_sph_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_x_trans -= .5;
X    break;
X  case 'y':
X    sph_x_trans += .5;
X    break;
X  case 'u':
X    sph_y_trans += .5;
X    break;
X  case 'j':
X    sph_y_trans -= .5;
X    break;
X  case 'i':
X    sph_z_trans += .5;
X    break;
X  case 'k':
X    sph_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void cub_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_cub_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_cub_sca);
X  break;
X
X case 3:
X  glutKeyboardFunc(key_cub_mov);
X  break;
X   }
X
}
X
void tea_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_tea_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_tea_sca);
X  break;
X
X case 3:
X  glutKeyboardFunc(key_tea_mov);
X  break;
X   } 
}
X
void sph_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_sph_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_sph_sca);
X  break;
X case 3:
X  glutKeyboardFunc(key_sph_mov);
X  break;  
X   }
X
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      int tea, cub, sph;  /*Sub Menus */
X
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowSize(750, 300);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X
X      cub = glutCreateMenu(cub_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      tea = glutCreateMenu(tea_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      sph = glutCreateMenu(sph_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Quit", 1);
X      glutAddMenuEntry("ViewPoint", 2);
X      glutAddSubMenu("Cube", cub);
X      glutAddSubMenu("Teapot", tea);
X      glutAddSubMenu("Sphere", sph);
X
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206194497 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
fbb0dff2c098acbe389341e70b0d9a44  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8946 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8946,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh52801
exit 0

From ???@??? Fri Feb 07 07:33:26 1997
Received: from vccsouth-03.its.rpi.edu (conway@vccsouth-03.its.rpi.edu [128.113.28.13])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id TAA44096
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 19:55:01 -0500
From: Laurie Conway <conway>
Received: (conway@localhost) by vccsouth-03.its.rpi.edu (951211.SGI.8.6.12.PATCH1042/8.6.4) id TAA26004 for citrit@rpi.edu; Thu, 6 Feb 1997 19:55:00 -0500
Date: Thu, 6 Feb 1997 19:55:00 -0500
Message-Id: <199702070055.TAA26004@vccsouth-03.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: c82afce07c4c8c334b30c869df7d0c8b

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:54 EST by <conway@vccsouth-03>.
# Source directory was `/afs/rpi.edu/home/17/conway/DataVis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  11057 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh26000; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *  Laurie Conway
X *  Advanced Computer Graphics and Data Visualization
X *  Homework 1, February 6, 1997
X *
X *  hw1.c
X *
X *  Using OpenGL and GLUT library...
X *  Draw shiney cube, solid blue sphere and yellow Teapot
X *
X *  This was successfully compiled and tested on Irix 5.3
X *  On AIX 4.1.4, it built after I changed the Makefile to find 
X *  glut includes in /campus/visualization/mesa-ogl/1.2.7/distrib/src/include
X *  On Solaris 2.5, it failed to build because it couldn't find -lGL and -lGLU
X */
X
/* Includes required */
X
#include <GL/gl.h>
#include <GL/glut.h>
X
void ShowPosition(int);
X
#define TEAPOT 0
#define CUBE   1
#define SPHERE 2 
#define CAMERA 3
#define NUMOBJECTS 4
#define W_WIDTH  500
#define W_HEIGHT 250
#define TEAPOT_TRANSPARENT 5
#define DEBUG 99
X
int CurrentObject = SPHERE;
int TransparentTeapot = 1;
int Debug = 0;
static char *curr_buff = "Current object: ";
char menu_item[24];
X
char *object_names[] = {"teapot", "cube", "sphere", "camera" }; 
X
X
/* Notes from Insight:
X   Diffuse reflectance plays the most important role in determining 
X   what you perceive the color of an object to be.
*/
X
struct My {
X	float x;
X	float y;
X	float z;
X	float rotx;
X	float roty;
X	float rotz;
X	float size; 
X	float shiny[2];  /* Set to 2 so initialization works better */
X	float amb_diff[4];
X	float specular[4];
} My[NUMOBJECTS] = { {-2.0, 0.0, 0.0,  0.0, 0.0, 0.0,  1.0, 
X					  0.6, 0.6, 0.8, 0.8, 0.0, 0.7, 0.0, 0.0, 0.0, 1.0},
X                     {0.0, 0.0, 0.0,  90.0, 105.0, -30.0,  1.0, 
X					  127.0, 127.0, 0.9, 0.0, 0.0, 1.0, 0.9, 0.9, 0.9, 1.0},
X                     {2.0, 0.0, 0.0,  0.0, 0.0, 0.0,  1.0, 
X					  0.0, 0.0, 0.0, 0.1, 0.8, 1.0, 0.0, 0.0, 0.0, 1.0,} };
X
void SetMaterialProperties(int object)
{
X	  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, My[object].amb_diff);
X	  glMaterialfv(GL_FRONT, GL_SPECULAR, My[object].specular);
X	  glMaterialfv(GL_FRONT, GL_SHININESS, My[object].shiny);
}
void display_sphere(void)
{
X	if (Debug) ShowPosition(SPHERE);
X	SetMaterialProperties(SPHERE);
X	glMatrixMode (GL_MODELVIEW);
X	glPushMatrix();
X	glTranslatef(My[SPHERE].x,My[SPHERE].y,My[SPHERE].z);
X	glRotatef(My[SPHERE].rotx, 1.0, 0.0, 0.0);
X	glRotatef(My[SPHERE].roty, 0.0, 1.0, 0.0);
X	glRotatef(My[SPHERE].rotz, 0.0, 0.0, 1.0);
X	glutSolidSphere(My[SPHERE].size, 16, 16);
X	glPopMatrix();
}
X
void display_cube(void)
{
X	if (Debug) ShowPosition(CUBE);
X	SetMaterialProperties(CUBE);
X	glMatrixMode (GL_MODELVIEW);
X	glPushMatrix();
X	glTranslatef(My[CUBE].x,My[CUBE].y,My[CUBE].z);
X	glRotatef(My[CUBE].rotx, 1.0, 0.0, 0.0);
X	glRotatef(My[CUBE].roty, 0.0, 1.0, 0.0);
X	glRotatef(My[CUBE].rotz, 0.0, 0.0, 1.0);
X	glutSolidCube(My[CUBE].size);	/*  draw the cube       */
X	glPopMatrix();
}
X
void display_teapot(void)
{
int i;
X
X	if (TransparentTeapot)
X		glEnable(GL_BLEND);
X
X	if (Debug) ShowPosition(TEAPOT);
X	SetMaterialProperties(TEAPOT);
X	glMatrixMode (GL_MODELVIEW);
X	glPushMatrix();
X	glTranslatef(My[TEAPOT].x,My[TEAPOT].y,My[TEAPOT].z);
X	glRotatef(My[TEAPOT].rotx, 1.0, 0.0, 0.0);
X	glRotatef(My[TEAPOT].roty, 0.0, 1.0, 0.0);
X	glRotatef(My[TEAPOT].rotz, 0.0, 0.0, 1.0);
X	glutSolidTeapot(My[TEAPOT].size);   
X	glDisable(GL_BLEND);
X	glPopMatrix();
}
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X	display_cube();
X	display_sphere();
X	display_teapot();
X	glutSwapBuffers(); 
}
X
void ShowPosition(int object)
{
X	
X	  printf("%s:\t", object_names[object]);
X	  printf("translation: %3.1f,%3.1f,%3.1f\t", My[object].x,
X	  		My[object].y,My[object].z);
X	  printf("rotation: %3.0f,%3.0f,%3.0f\t", My[object].rotx,
X	  		My[object].roty,My[object].rotz);
X	  printf("size: %3.1f\n", My[object].size); 
X
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {-2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.6, 0.6, 0.6, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X	  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X      glShadeModel (GL_FLAT);
X      glClearColor (0.0, 0.0, 0.0, 1.0);
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X	if (CurrentObject == CAMERA)
X		glMatrixMode(GL_PROJECTION);
X
X    switch (key) {
X    case 'x':   /* Rotate about X axis in positive direction */
X		if (CurrentObject != CAMERA) 
X			My[CurrentObject].rotx = (int) (My[CurrentObject].rotx+15.0) % 360;
X		else 
X			glRotatef(15.0, 1.0,0.0,0.0);
X		break;
X    case 'X':   /* Rotate about X axis in negative direction */
X		if (CurrentObject != CAMERA)
X			My[CurrentObject].rotx = (int) (My[CurrentObject].rotx-15.0) % 360;
X		else 
X			glRotatef(-15.0, 1.0,0.0,0.0);
X		break;
X    case 'y':   /* Rotate about Y axis in positive direction */
X		if (CurrentObject != CAMERA)
X			My[CurrentObject].roty = (int) (My[CurrentObject].roty+15.0) % 360;
X		else
X			glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 'Y':  /* Rotate about Y axis in negative direction */
X		if (CurrentObject != CAMERA) 
X			My[CurrentObject].roty = (int) (My[CurrentObject].roty-15.0) % 360;
X		else 
X			glRotatef(-15.0, 0.0,1.0,0.0);
X		break;
X    case 'z':  /* Rotate about Z axis in positive direction */
X		if (CurrentObject != CAMERA) 
X			My[CurrentObject].rotz = (int) (My[CurrentObject].rotz+15.0) % 360;
X		else
X			glRotatef(15.0, 0.0,0.0,1.0);
X		break;
X    case 'Z':  /* Rotate about Z axis in negative direction */
X		if (CurrentObject != CAMERA) 
X			My[CurrentObject].rotz = (int) (My[CurrentObject].rotz-15.0) % 360;
X		else 
X			glRotatef(-15.0, 0.0,0.0,1.0);
X		break;
X	case 45:  /* '-' and '_' scale object down */
X	case 95:
X		My[CurrentObject].size *= .9;
X		break;
X	case 43:  /* '+' and '=' scale object up */
X	case 61:
X		My[CurrentObject].size *= 1.1;
X		break;
X	case 'h':  /* Move object -.1 along x  */
X		My[CurrentObject].x -= .1;
X		break;
X	case 'l':  /* Move object .1 along x */
X		My[CurrentObject].x += .1;
X		break;
X	case 'k':  /* Move object up .1 along y */
X		My[CurrentObject].y += .1;
X		break;
X	case 'j':  /* Move object down .1 along y */
X		My[CurrentObject].y -= .1;
X		break;
X	case 'o':  /* Move object up .1 along z */
X		My[CurrentObject].z += .1;
X		break;
X	case 'i':  /* Move object down .1 along z */
X		My[CurrentObject].z -= .1;
X		break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case -1:
X        exit(0);
X        break;
X	case SPHERE:		/* Set ViewPort as the active thing to move */
X		CurrentObject = SPHERE;
X	  	strcpy(menu_item, curr_buff);
X	  	strcat(menu_item, object_names[CurrentObject]);
X      	glutChangeToMenuEntry(1, menu_item, 88);
X		break;
X	case CUBE:	
X		CurrentObject = CUBE;
X	  	strcpy(menu_item, curr_buff);
X	  	strcat(menu_item, object_names[CurrentObject]);
X      	glutChangeToMenuEntry(1, menu_item, 88);
X		break;
X	case TEAPOT:	
X		CurrentObject = TEAPOT;
X	  	strcpy(menu_item, curr_buff);
X	  	strcat(menu_item, object_names[CurrentObject]);
X      	glutChangeToMenuEntry(1, menu_item, 88);
X		break;
X	case CAMERA:		
X		CurrentObject = CAMERA;
X	  	strcpy(menu_item, curr_buff);
X	  	strcat(menu_item, object_names[CurrentObject]);
X      	glutChangeToMenuEntry(1, menu_item, 88);
X		break;
X	case TEAPOT_TRANSPARENT:
X		TransparentTeapot = TransparentTeapot?0:1;
X    	glutPostRedisplay();
X		break;
X	case DEBUG:
X		Debug = Debug?0:1;
X		break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X int help_menu;
X int mat_menu;
X
X	  printf("\n\nAdvanced Computer Graphics and Data Visualization\n");
X	  printf("Laurie Conway\t\tHomework 1\n\n");
X	  printf("Use the menu attached to the right mouse button to select\n");
X	  printf("the active object. Then control the movement as shown below.\n"); 
X	  printf("Note: xyz/XYZ keys are used for camera rotation about origin.\n\n");
X	  printf("Key   Funct   Axis\n");
X	  printf("------------------\n");
X	  printf(" x    rotate+    x\n");
X	  printf(" X    rotate-    x\n");
X	  printf(" y    rotate+    y\n");
X	  printf(" Y    rotate-    y\n");
X	  printf(" z    rotate+    z\n");
X	  printf(" Z    rotate-    z\n");
X	  printf(" h   translate-  x\n");
X	  printf(" l   translate+  x\n");
X	  printf(" k   translate+  y\n");
X	  printf(" j   translate-  y\n");
X	  printf(" o   translate+  z\n");
X	  printf(" i   translate-  z\n");
X	  printf("+/- scale up/down\n\n");
X	  glutInitWindowSize(W_WIDTH,W_HEIGHT);
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow ("Laurie's Homework 1");
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X	  help_menu = glutCreateMenu(Select);
X	  glutAddMenuEntry("Key  Funct   Axis", 88);
X	  glutAddMenuEntry("---------------", 88);
X	  glutAddMenuEntry(" x    rotate+   x", 88);
X	  glutAddMenuEntry(" X    rotate-   x", 88);
X	  glutAddMenuEntry(" y    rotate+   y", 88);
X	  glutAddMenuEntry(" Y    rotate-   y", 88);
X	  glutAddMenuEntry(" z    rotate+   z", 88);
X	  glutAddMenuEntry(" Z    rotate-   z", 88);
X	  glutAddMenuEntry(" h   translate-  x", 88);
X	  glutAddMenuEntry(" l    translate+  x", 88);
X	  glutAddMenuEntry(" k   translate+  y", 88);
X	  glutAddMenuEntry(" j   translate-  y", 88);
X	  glutAddMenuEntry(" o   translate+  z", 88);
X	  glutAddMenuEntry(" i   translate-  z", 88);
X	  glutAddMenuEntry("+/- scale up/down", 88);
X      glutCreateMenu(Select);
X	  strcpy(menu_item, curr_buff);
X	  strcat(menu_item, object_names[CurrentObject]);
X      glutAddMenuEntry(menu_item, 88);
X      glutAddMenuEntry("-----------------------", 88);
X      glutAddMenuEntry("Select Teapot", TEAPOT);
X      glutAddMenuEntry("Select Cube", CUBE);
X      glutAddMenuEntry("Select Sphere", SPHERE);
X      glutAddMenuEntry("Rotate Camera", CAMERA);
X      glutAddMenuEntry("Toggle Teapot Transparancy", TEAPOT_TRANSPARENT);
X      glutAddMenuEntry("Toggle Debug Output", DEBUG);
X	  glutAddSubMenu("Help Keys", help_menu);
X      glutAddMenuEntry("Quit", -1);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206195497 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
90d3dc2996e346959a9dd6e1fe0776fa  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 11057 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '11057,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh26000
exit 0

From ???@??? Fri Feb 07 07:34:26 1997
Received: from vccnorth28.its.rpi.edu (stefanm@vccnorth28.its.rpi.edu [128.113.69.138])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA49262
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:50:37 -0500
From: Magnus Stefansson <stefanm>
Received: (stefanm@localhost) by vccnorth28.its.rpi.edu (8.6.9/8.6.4) id XAA20556 for citrit@rpi.edu; Thu, 6 Feb 1997 23:50:28 -0500
Date: Thu, 6 Feb 1997 23:50:28 -0500
Message-Id: <199702070450.XAA20556@vccnorth28.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 24b457a26e2167f745e480ba33bef850

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:50 EST by <stefanm@vccnorth28>.
# Source directory was `/afs/rpi.edu/home/29/stefanm/Class/Vis/HW1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    879 -rw------- Makefile
#   7576 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh15172; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=cc
X
TARGET = simple
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LDFLAGS)
X
lorenz:    lorenz.o
X	$(CC) $(CFLAGS) -o $@ $? $(LIBS)
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0206233697 'Makefile' &&
  chmod 0600 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
8bfa1c81d2d168508ae125163712a893  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 879 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '879,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X *  Simple2.c 
X *
X *  Simple example of programming using the OpenGL graphics library
X *  Taken from the "OpenGL Programming Guide"
X *
X *
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
#include <math.h>
X
X
#define  HW_VIEWPOINT 0
#define  HW_SPHERE 1
#define  HW_CUBE  2
#define  HW_TEAPOT 3
X
X      int active = HW_VIEWPOINT;
/*       active keeps track of which object (HW_VIEWPOINT, */
/*       HW_SPHERE..) the user can rotate at the moment. */
X
X     GLfloat rotation[4][16]=
X         {   { 1.0, 0.0, 0.0, 0.0, 
X               0.0, 1.0, 0.0, 0.0,
X               0.0, 0.0, 1.0, 0.0,
X               0.0, 0.0, 0.0, 1.0 } ,
X             { 1.0, 0.0, 0.0, 0.0, 
X               0.0, 1.0, 0.0, 0.0,
X               0.0, 0.0, 1.0, 0.0,
X               0.0, 0.0, 0.0, 1.0 } ,
X             { 1.0, 0.0, 0.0, 0.0, 
X               0.0, 1.0, 0.0, 0.0,
X               0.0, 0.0, 1.0, 0.0,
X               0.0, 0.0, 0.0, 1.0 } ,
X             { 1.0, 0.0, 0.0, 0.0, 
X               0.0, 1.0, 0.0, 0.0,
X               0.0, 0.0, 1.0, 0.0,
X               0.0, 0.0, 0.0, 1.0 }   };
/*        rotation[HW_xxxx] keeps the transformation matrix */
/*        for object HW_xxxx.  Note, do not use matrix for */
/*        the viewpoint, but decided to keep it for  the  */
/*        sake of consistency  */
X
X
X
X
X
/*       PRE:   none */
/*       POST:  list number HW_xxxx draws object HW_xxxx */
/*              on the place defined by the modelview */
/*              Matrix */
void buildlists(void)
{
X      static float sphereAmbDiff[4] = {0.1, 0.8, 0.1, 1.0}; 
X      static float sphereSpec[4] = { 0.1, 0.1, 0.1, 1.0};   
X      static float sphereShine[1] = {10.0};                
X
X      static float cubeAmbDiff[4] = {0.9, 0.1, 0.1, 1.0}; 
X      static float cubeSpec[4] = { 0.8, 0.8, 0.8, 1.0};   
X      static float cubeShine[1] = {100.0};                
X
X
X      static float teapotAmbDiff[4] = {0.9, 0.9, 0.1, 1.0}; 
X      static float teapotSpec[4] = { 1.0, 1.0, 1.0, 1.0};   
X      static float teapotShine[1] = {100.0};                
X
X
X  glNewList(HW_TEAPOT, GL_COMPILE);
X      glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, teapotAmbDiff);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, teapotSpec);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, teapotSpec);
X      glMaterialfv(GL_FRONT, GL_SHININESS, teapotShine);
X      glutSolidTeapot(0.5); 
X  glEndList();
X
X  glNewList(HW_SPHERE, GL_COMPILE);
X      glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, sphereAmbDiff);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, sphereSpec);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, sphereSpec);
X      glMaterialfv(GL_FRONT, GL_SHININESS, sphereShine);
X      glutSolidSphere(0.5,20,20);   /*  draw a sphere      */
X  glEndList();
X
X  glNewList(HW_CUBE, GL_COMPILE);
X      glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, cubeAmbDiff);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, cubeSpec);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, cubeSpec);
X      glMaterialfv(GL_FRONT, GL_SHININESS, cubeShine);
X      glutSolidCube(1.0);   /*  draw a sphere      */
X  glEndList();
X
}
X
X
X    
/*   Draw objects on screen */
void display(void)
{
X
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X      glMatrixMode (GL_MODELVIEW);
X
X      glPushMatrix();
X      glTranslatef(-2.0, 0.0, 0.0);
X      glMultMatrixf(rotation[HW_TEAPOT]);
X      glCallList(HW_TEAPOT);
X      glPopMatrix();
X
X      glPushMatrix();
X      glMultMatrixf(rotation[HW_CUBE]);
X      glCallList(HW_CUBE);
X      glPopMatrix();
X
X      glPushMatrix();
X      glTranslatef(2.0, 0.0, 0.0);
X      glMultMatrixf(rotation[HW_SPHERE]);
X      glCallList(HW_SPHERE);
X      glPopMatrix();
X
X      glutSwapBuffers(); 
}
X
X
/* Initialize shading model */
void myInit(void)
{
X
X      static float lightPos[4] = {8.0, 16.0, 8.0, 1.0};
X      static float lightDir[4] = {-8.0, -16.0, -8.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = { 1.0, 1.0, 1.0, 1.0};
X
X      buildlists();
X
X      glOrtho( -2.0, 2.0, -2.0, 2.0, -2.0, 2.0);
X
X
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X      glEnable(GL_DITHER);
X
X      
X
X
/*     glShadeModel (GL_FLAT);
X *     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
X
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X
X      int i,j;
X      glViewport (0, 0, w, h);            /*  define the viewport */
X
X      for(i=0; i<4; i++)
X        for(j=0; j<16; j++)
X          rotation[i][j] =
X            (j==0 || j==5 || j==10 || j==15) ? 1.0: 0.0;
X
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    if ( active == HW_VIEWPOINT){
X      glMatrixMode(GL_PROJECTION);
X      switch (key) { 
X      case 'h': 
X	glRotatef(-15.0, 0.0,1.0,0.0); 
X	break; 
X      case 'j': 
X	glRotatef(-15.0, 1.0,0.0,0.0); 
X	break; 
X      case 'k': 
X	glRotatef(15.0, 1.0,0.0,0.0); 
X	break; 
X      case 'l': 
X	glRotatef(15.0, 0.0,1.0,0.0); 
X	break; 
X      case 27:          
X	exit(1); 
X	break; 
X      default:
X	break; 
X      }
X      glMatrixMode(GL_MODELVIEW);
X      glGetFloatv(GL_PROJECTION_MATRIX, rotation[active]);
X
X    }      
X    else{
X      glMatrixMode(GL_MODELVIEW);
X      glPushMatrix();
X      glLoadMatrixf(rotation[active]); 
X      switch (key) { 
X      case 'h': 
X	glRotatef(15.0, 0.0,1.0,0.0); 
X	break; 
X      case 'j': 
X	glRotatef(15.0, 1.0,0.0,0.0); 
X	break; 
X      case 'k': 
X	glRotatef(-15.0, 1.0,0.0,0.0); 
X	break; 
X      case 'l': 
X	glRotatef(-15.0, 0.0,1.0,0.0); 
X	break; 
X      case 27:          
X	exit(1); 
X	break; 
X      default:
X	break; 
X      }
X      glGetFloatv(GL_MODELVIEW_MATRIX, rotation[active]);
X      glPopMatrix();
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    int i,j;
X    switch (value) {
X    case 1:
X        active = HW_VIEWPOINT;
X        break;
X    case 2:
X        active = HW_SPHERE;
X        break;
X    case 3:
X        active = HW_CUBE;
X        break;
X    case 4:
X        active = HW_TEAPOT;
X        break;
X    case 5:
X	for(i=0; i<4; i++)
X	  for(j=0; j<16; j++)
X	    rotation[i][j] =
X	      (j==0 || j==5 || j==10 || j==15) ? 1.0: 0.0;
X        glMatrixMode(GL_PROJECTION);
X        glLoadIdentity();
X	myInit();
X	glutPostRedisplay();
X	glMatrixMode(GL_MODELVIEW);
X	break;
X    case 6:
X        exit(0);
X        break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      glutCreateMenu(Select);
X      glutAddMenuEntry("ViewPoint", 1);
X      glutAddMenuEntry("Sphere", 2);
X      glutAddMenuEntry("Cube", 3);
X      glutAddMenuEntry("Tea Pot", 4);
X      glutAddMenuEntry("Restart", 5);
X      glutAddMenuEntry("Quit", 6);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
X
X
X
X
X
X
X
X
SHAR_EOF
  $shar_touch -am 0206234297 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
6dd5737d020b7ef81e226a4bd91c8dde  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 7576 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '7576,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh15172
exit 0

From ???@??? Fri Feb 07 07:33:33 1997
Received: from cortez.sss.rpi.edu (boothj@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id WAA39694
	for <citrit>; Thu, 6 Feb 1997 22:27:56 -0500
From: Mail Delivery Subsystem <boothj>
Received: (boothj@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id WAA127244 for citrit; Thu, 6 Feb 1997 22:27:55 -0500
Date: Thu, 6 Feb 1997 22:27:55 -0500
Message-Id: <199702070327.WAA127244@cortez.sss.rpi.edu>
To: citrit
Subject: Homework 1
X-UIDL: 5202d5daac43828d04fd4c5bc9aca96c

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 22:18 EST by <boothj@cortez>.
# Source directory was `/afs/rpi.edu/home/27/boothj/gfx'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   8943 -rw-r----- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh137116; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 hw1.c
M+RH-"B`J($%D=F%N8V5D($=R87!H:6-S(&%N9"!6:7-U86QI>F%T:6]N#0H@
M*B!*97-S92!";V]T:"`H8F]O=&AJ0')P:2YE9'4I#0H@*B!(;VUE=V]R:R`C
M,0T*("HO#0H-"B\J(%=I;F1O=W,@.34O3E0@:6YC;'5D97,@*B\-"B-I9F1E
M9B!?5TE.,S(-"B-I;F-L=61E(#QW:6YD;W=S+F@^#0HC96YD:68-"@HC:6YC
M;'5D92`\<W1D:6\N:#X*"B\J($]P96Y'3"!I;F-L=61E<R`J+PHC:6YC;'5D
M92`\1TPO9VPN:#X*(VEN8VQU9&4@/$=,+V=L=70N:#X*#0IE;G5M('L@345.
M55]154E4+"!-14Y57U-02$5215]!0U1)5D4L($U%3E5?0U5"15]!0U1)5D4L
M($U%3E5?5$5!4$]47T%#5$E612P-"B`@("`@("!-14Y57T-!345205]!0U1)
M5D4L($U%3E5?4D53150@?3L-"@T*+RH@1&%T82!S=')U8W1U<F4@9F]R(&]B
M:F5C=',@86YD(&-A;65R82`J+R`@("`@("`-"G1Y<&5D968@<W1R=6-T(%]O
M8FIE8W0-"GL-"B`@1TQF;&]A="!L;V-?>"P@;&]C7WDL(&QO8U]Z.PT*("!'
M3&9L;V%T(&%M8FEE;G1;-%T[#0H@($=,9FQO870@<W!E8W5L87);-%T[("`-
M"B`@1TQF;&]A="!S:&EN:6YE<W,[#0H@($=,9FQO870@<F]T6&%N9VQE+"!R
M;W1986YG;&4L(')O=%IA;F=L93L-"B`@1TQF;&]A="!S8V%L95@L('-C86QE
M62P@<V-A;&5:.PT*?2!/8FIE8W0[#0H-"D]B:F5C="!3<&AE<F4L($-U8F4L
M(%1E87!O="P@0V%M97)A.PT*#0I/8FIE8W0@*F-U<E]O8FH@/2`F0W5B93L-
M"@T*1TQI;G0@=VEN7W<L('=I;E]H.PT*#0IV;VED(&UY26YI="AV;VED*0I[
M#0H@('-T871I8R!F;&]A="!L:6=H=%!O<ULT72`]('LQ+C`L(#(N,"P@,2XP
M+"`Q+C!].PT*("`O*B!S=&%T:6,@9FQO870@;&EG:'1$:7);-%T@/2![+3(N
M,"P@+30N,"P@+3(N,"P@,2XP?3L@*B\*("!S=&%T:6,@9FQO870@;&EG:'1!
M;6);-%T@/2![,"XW+"`P+C<L(#`N-RP@,2XP?3L*("!S=&%T:6,@9FQO870@
M;&EG:'1$:69F6S1=(#T@>S`N."P@,"XX+"`P+C@L(#$N,'T["B`@<W1A=&EC
M(&9L;V%T(&QI9VAT4W!E8ULT72`]('LQ+C`L(#$N,"P@,2XP+"`Q+C!].PH-
M"B`@+RH@<V5T('5P(&QI9VAT:6YG("HO"B`@9VQ%;F%B;&4H1TQ?3$E'2%1)
M3D<I.PH@(&=L16YA8FQE*$=,7TQ)1TA4,"D["B`@9VQ,:6=H=&9V*$=,7TQ)
M1TA4,"P@1TQ?4$]3251)3TXL(&QI9VAT4&]S*3L*("!G;$QI9VAT9G8H1TQ?
M3$E'2%0P+"!'3%]!34))14Y4+"!L:6=H=$%M8BD["B`@9VQ,:6=H=&9V*$=,
M7TQ)1TA4,"P@1TQ?1$E&1E5312P@;&EG:'1$:69F*3L*("!G;$QI9VAT9G8H
M1TQ?3$E'2%0P+"!'3%]34$5#54Q!4BP@;&EG:'13<&5C*3L*("`-"B`@9VQ%
M;F%B;&4H1TQ?1$505$A?5$535"D["B`@9VQ3:&%D94UO9&5L("A'3%]334]/
M5$@I.R`@+RH@<V5T('-H861I;F<@;6]D96P@*B\*("`-"B`@9VQ#;&5A<D-O
M;&]R("@P+C`L(#`N,"P@,"XP+"`P+C`I.PH-"B`@+RH@:6YI=&EA;&EZ92!D
M871A(&9O<B!S<&AE<F4@*B\-"B`@4W!H97)E+FQO8U]X(#T@,BXP.R`@4W!H
M97)E+FQO8U]Y(#T@,"XP.R`@4W!H97)E+FQO8U]Z(#T@,"XP.PT*("!3<&AE
M<F4N86UB:65N=%LP72`](#`N,#L@(%-P:&5R92YA;6)I96YT6S%=(#T@,"XP
M.R`@4W!H97)E+F%M8FEE;G1;,ET@/2`P+C@[#0H@(%-P:&5R92YA;6)I96YT
M6S-=(#T@,2XP.PT*("!3<&AE<F4N<W!E8W5L87);,%T@/2`P+C([("!3<&AE
M<F4N<W!E8W5L87);,5T@/2`P+C([("!3<&AE<F4N<W!E8W5L87);,ET@/2`P
M+C([#0H@(%-P:&5R92YS<&5C=6QA<ELS72`](#$N,#L-"B`@4W!H97)E+G-H
M:6YI;F5S<R`](#`N,#L-"B`@4W!H97)E+G)O=%AA;F=L92`](#`N,#L@4W!H
M97)E+G)O=%EA;F=L92`](#`N,#L@4W!H97)E+G)O=%IA;F=L92`](#`N,#L-
M"B`@4W!H97)E+G-C86QE6"`](#$N,#L@(%-P:&5R92YS8V%L95D@/2`Q+C`[
M(%-P:&5R92YS8V%L95H@/2`Q+C`[#0H-"B`@+RH@:6YI=&EA;&EZ92!D871A
M(&9O<B!C=6)E("HO#0H@($-U8F4N;&]C7W@@/2`P+C`[("!#=6)E+FQO8U]Y
M(#T@,"XP.R`@0W5B92YL;V-?>B`](#`N,#L-"B`@0W5B92YA;6)I96YT6S!=
M(#T@,"XX.R`@0W5B92YA;6)I96YT6S%=(#T@,"XP.R`@0W5B92YA;6)I96YT
M6S)=(#T@,"XP.PT*("!#=6)E+F%M8FEE;G1;,UT@/2`Q+C`[#0H@($-U8F4N
M<W!E8W5L87);,%T@/2`P+C@[("!#=6)E+G-P96-U;&%R6S%=(#T@,"XX.R`@
M0W5B92YS<&5C=6QA<ELR72`](#`N.#L-"B`@0W5B92YS<&5C=6QA<ELS72`]
M(#$N,#L-"B`@0W5B92YS:&EN:6YE<W,@/2`Q,C@N,#L-"B`@0W5B92YR;W18
M86YG;&4@/2`P+C`[($-U8F4N<F]T66%N9VQE(#T@,"XP.R!#=6)E+G)O=%IA
M;F=L92`](#`N,#L-"B`@0W5B92YS8V%L95@@/2`Q+C`[("!#=6)E+G-C86QE
M62`](#$N,#L@0W5B92YS8V%L95H@/2`Q+C`[#0H-"B`@+RH@:6YI=&EA;&EZ
M92!D871A(&9O<B!T96%P;W0@*B\-"B`@5&5A<&]T+FQO8U]X(#T@+3(N,#L@
M(%1E87!O="YL;V-?>2`](#`N,#L@(%1E87!O="YL;V-?>B`](#`N,#L-"B`@
M5&5A<&]T+F%M8FEE;G1;,%T@/2`P+C@[("!496%P;W0N86UB:65N=%LQ72`]
M(#`N.#L@(%1E87!O="YA;6)I96YT6S)=(#T@,"XP.PT*("!496%P;W0N86UB
M:65N=%LS72`](#$N,#L-"B`@5&5A<&]T+G-P96-U;&%R6S!=(#T@,"XX.R`@
M5&5A<&]T+G-P96-U;&%R6S%=(#T@,"XX.R`@5&5A<&]T+G-P96-U;&%R6S)=
M(#T@,"XX.PT*("!496%P;W0N<W!E8W5L87);,UT@/2`Q+C`[#0H@(%1E87!O
M="YS:&EN:6YE<W,@/2`Q,#`N,#L-"B`@5&5A<&]T+G)O=%AA;F=L92`](#`N
M,#L@5&5A<&]T+G)O=%EA;F=L92`](#`N,#L@5&5A<&]T+G)O=%IA;F=L92`]
M(#`N,#L-"B`@5&5A<&]T+G-C86QE6"`](#$N,#L@(%1E87!O="YS8V%L95D@
M/2`Q+C`[(%1E87!O="YS8V%L95H@/2`Q+C`[("`*#0H@("\J(&EN:71I86QI
M>F4@9&%T82!F;W(@8V%M97)A("HO#0H@($-A;65R82YL;V-?>"`](#`N,#L@
M($-A;65R82YL;V-?>2`](#`N,#L@($-A;65R82YL;V-?>B`]("TW+C`[#0H@
M($-A;65R82YR;W1886YG;&4@/2`P+C`[($-A;65R82YR;W1986YG;&4@/2`P
M+C`[($-A;65R82YR;W1:86YG;&4@/2`P+C`[("`-"GT*#0HO*B!D:7-P;&%Y
M(&9U;F-T:6]N("HO#0IV;VED(&1I<W!L87DH=F]I9"D*>PT*("!G;$-L96%R
M*$=,7T-/3$]27T)51D9%4E]"250@?"!'3%]$15!42%]"549&15)?0DE4*3L*
M("`-"B`@9VQ%;F%B;&4H1TQ?0U5,3%]&04-%*3L@("\J(&5N86)L92!B86-K
M+69A8V4@8W5L;&EN9R`J+PT*("!G;$-U;&Q&86-E*$=,7T)!0TLI.R`@(`T*
M(`T*("`O*B!C;VYF:6=U<F4@=FEE=W!O:6YT("AC86UE<F$@=FEE=RD@*B\@
M#0H@(&=L36%T<FEX36]D92`H1TQ?4%)/2D5#5$E/3BD[#0H@(&=L3&]A9$ED
M96YT:71Y*"D[#0H@(&=L=5!E<G-P96-T:79E*#0U+C`L(#$N,"HH1TQF;&]A
M="EW:6Y?=R\H1TQF;&]A="EW:6Y?:"P@,2XP+"`Q,"XP*3L-"B`@9VQ4<F%N
M<VQA=&5F("A#86UE<F$N;&]C7W@L($-A;65R82YL;V-?>2P@0V%M97)A+FQO
M8U]Z*3L-"B`@9VQ2;W1A=&5F("A#86UE<F$N<F]T6&%N9VQE+"`Q+C`L(#`N
M,"P@,"XP*3L)#0H@(&=L4F]T871E9B`H0V%M97)A+G)O=%EA;F=L92P@,"XP
M+"`Q+C`L(#`N,"D[#0H-"B`@+RH@<&QA>2!W:71H('1H92!M;V1E;'9I97<@
M;6%T<FEX("HO#0H@(&=L36%T<FEX36]D92`H1TQ?34]$14Q62457*3L-"B`@
M9VQ,;V%D261E;G1I='DH*3L@(`T*("`@(`T*("`O*B!D<F%W(')E9"!C=6)E
M("HO#0H@(&=L4'5S:$UA=')I>"@I.PT*("`@(&=L5')A;G-L871E9B`H0W5B
M92YL;V-?>"P@0W5B92YL;V-?>2P@0W5B92YL;V-?>BD[#0H)9VQ2;W1A=&5F
M("A#=6)E+G)O=%AA;F=L92P@,2XP+"`P+C`L(#`N,"D["0T*"6=L4F]T871E
M9B`H0W5B92YR;W1986YG;&4L(#`N,"P@,2XP+"`P+C`I.PT*"6=L4V-A;&5F
M("A#=6)E+G-C86QE6"P@0W5B92YS8V%L95DL($-U8F4N<V-A;&5:*3L-"@EG
M;$UA=&5R:6%L9G8@*$=,7T923TY4+"!'3%]!34))14Y47T%.1%]$249&55-%
M+"!#=6)E+F%M8FEE;G0I.PT*"6=L36%T97)I86QF=B`H1TQ?1E)/3E0L($=,
M7U-014-53$%2+"!#=6)E+G-P96-U;&%R*3L-"@EG;$UA=&5R:6%L9B`H1TQ?
M1E)/3E0L($=,7U-(24Y)3D534RP@0W5B92YS:&EN:6YE<W,I.PT*("`@(&=L
M=713;VQI9$-U8F4H,2XP*3L-"B`@9VQ0;W!-871R:7@H*3L-"@T*("`O*B!D
M<F%W(&)L=64@<W!H97)E("HO#0H@(&=L4'5S:$UA=')I>"@I.R`@("`-"B`@
M("!G;%1R86YS;&%T968@*%-P:&5R92YL;V-?>"P@4W!H97)E+FQO8U]Y+"!3
M<&AE<F4N;&]C7WHI.PT*"6=L4F]T871E9B`H4W!H97)E+G)O=%AA;F=L92P@
M,2XP+"`P+C`L(#`N,"D["0T*"6=L4F]T871E9B`H4W!H97)E+G)O=%EA;F=L
M92P@,"XP+"`Q+C`L(#`N,"D["0T*"6=L4V-A;&5F("A3<&AE<F4N<V-A;&58
M+"!3<&AE<F4N<V-A;&59+"!3<&AE<F4N<V-A;&5:*3L-"@EG;$UA=&5R:6%L
M9G8@*$=,7T923TY4+"!'3%]!34))14Y47T%.1%]$249&55-%+"!3<&AE<F4N
M86UB:65N="D[#0H)9VQ-871E<FEA;&9V("A'3%]&4D].5"P@1TQ?4U!%0U5,
M05(L(%-P:&5R92YS<&5C=6QA<BD[#0H)9VQ-871E<FEA;&8@*$=,7T923TY4
M+"!'3%]32$E.24Y%4U,L(%-P:&5R92YS:&EN:6YE<W,I.PD-"@EG;'5T4V]L
M:613<&AE<F4@*#`N-2P@,C`L(#(P*3L@("\J(&1R87<@8FQU92!S<&AE<F4@
M*B\-"B`@9VQ0;W!-871R:7@H*3L-"@T*("`O*B!D<F%W('EE;&QO=R!T96%P
M;W0@*B\-"B`@9VQ0=7-H36%T<FEX*"D[("`@(`T*("`@(&=L5')A;G-L871E
M9B`H5&5A<&]T+FQO8U]X+"!496%P;W0N;&]C7WDL(%1E87!O="YL;V-?>BD[
M#0H)9VQ2;W1A=&5F("A496%P;W0N<F]T6&%N9VQE+"`Q+C`L(#`N,"P@,"XP
M*3L-"@EG;%)O=&%T968@*%1E87!O="YR;W1986YG;&4L(#`N,"P@,2XP+"`P
M+C`I.PT*"6=L4V-A;&5F("A496%P;W0N<V-A;&58+"!496%P;W0N<V-A;&59
M+"!496%P;W0N<V-A;&5:*3L-"@EG;$UA=&5R:6%L9G8@*$=,7T923TY47T%.
M1%]"04-++"!'3%]!34))14Y47T%.1%]$249&55-%+"!496%P;W0N86UB:65N
M="D[#0H)9VQ-871E<FEA;&9V("A'3%]&4D].5%]!3D1?0D%#2RP@1TQ?4U!%
M0U5,05(L(%1E87!O="YS<&5C=6QA<BD[#0H)9VQ-871E<FEA;&8@*$=,7T92
M3TY47T%.1%]"04-++"!'3%]32$E.24Y%4U,L(%1E87!O="YS:&EN:6YE<W,I
M.PD-"@EG;'5T4V]L:61496%P;W0@*#`N-2D[#0H@(&=L4&]P36%T<FEX*"D[
M#0H*("!G;'5T4W=A<$)U9F9E<G,H*3L@"GT-"@T*+RH*("H@($-A;&QE9"!W
M:&5N('1H92!W:6YD;W<@:7,@9FER<W0@;W!E;F5D(&%N9"!W:&5N979E<B`*
M("H@('1H92!W:6YD;W<@:7,@<F5C;VYF:6=U<F5D("AM;W9E9"!O<B!R97-I
M>F5D*2X*("HO"G9O:60@;7E297-H87!E*$=,:6YT('<L($=,:6YT(&@I"GL-
M"B`@=VEN7W<@/2!W.PT*("!W:6Y?:"`](&@[#0H*("!G;%9I97=P;W)T("@P
M+"`P+"!W+"!H*3L@("`@("`@("`@("`O*B`@9&5F:6YE('1H92!V:65W<&]R
M="`J+PT*("`O*B!S971U<"!U<"!T:&4@=FEE=W!O:6YT+V-A;65R82`J+PH@
M(&=L36%T<FEX36]D92A'3%]04D]*14-424].*3L*("!G;$QO861)9&5N=&ET
M>2@I.PH@(&=L=5!E<G-P96-T:79E*#0U+C`L(#$N,"HH1TQF;&]A="EW+RA'
M3&9L;V%T*6@L(#$N,"P@,3`N,"D[#0H@(&=L5')A;G-L871E9B`H0V%M97)A
M+FQO8U]X+"!#86UE<F$N;&]C7WDL($-A;65R82YL;V-?>BD[#0H@(&=L4F]T
M871E9B`H0V%M97)A+G)O=%AA;F=L92P@,2XP+"`P+C`L(#`N,"D["0T*("!G
M;%)O=&%T968@*$-A;65R82YR;W1986YG;&4L(#`N,"P@,2XP+"`P+C`I.PT*
M#0H@(&=L36%T<FEX36]D92`H1TQ?34]$14Q62457*3L@("`@("`@("\J(&)A
M8VL@=&\@;6]D96QV:65W(&UA=')I>"`@*B\-"B`@9VQ,;V%D261E;G1I='DH
M*3L@(`I]#0H-"B\J"B`J($ME>6)O87)D(&AA;F1L97(*("HO"G9O:60*2V5Y
M*'5N<VEG;F5D(&-H87(@:V5Y+"!I;G0@>"P@:6YT('DI"GL*("`@('-W:71C
M:"`H:V5Y*2!["@EC87-E("=D)SH@("\J(&UO=F4@<FEG:'0@*B\-"@D)8W5R
M7V]B:BT^;&]C7W@@*ST@,"XU.R!B<F5A:SL-"@EC87-E("=S)SH@("\J(&UO
M=F4@;&5F="`J+PT*"0EC=7)?;V)J+3YL;V-?>"`M/2`P+C4[(&)R96%K.PT*
M"6-A<V4@)V4G.B`@+RH@;6]V92!U<"`J+PT*"0EC=7)?;V)J+3YL;V-?>2`K
M/2`P+C4[(&)R96%K.PT*"6-A<V4@)W@G.B`@+RH@;6]V92!D;W=N("HO#0H)
M"6-U<E]O8FHM/FQO8U]Y("T](#`N-3L@8G)E86L[#0H)8V%S92`G9R<Z("`O
M*B!S8V%L92!U<"`J+PT*"0EC=7)?;V)J+3YS8V%L95@@*ST@,"XQ.PT*"0EC
M=7)?;V)J+3YS8V%L95D@*ST@,"XQ.PT*"0EC=7)?;V)J+3YS8V%L95H@*ST@
M,"XQ.PT*"2`@("!B<F5A:SL-"@EC87-E("=F)SH@("\J('-C86QE(&1O=VX@
M*B\-"@D)8W5R7V]B:BT^<V-A;&58("T](#`N,3L@:68@*&-U<E]O8FHM/G-C
M86QE6"`\/2`P+C`I(&-U<E]O8FHM/G-C86QE6"`](#`N,3L-"@D)8W5R7V]B
M:BT^<V-A;&59("T](#`N,3L@:68@*&-U<E]O8FHM/G-C86QE62`\/2`P+C`I
M(&-U<E]O8FHM/G-C86QE62`](#`N,3L-"@D)8W5R7V]B:BT^<V-A;&5:("T]
M(#`N,3L@:68@*&-U<E]O8FHM/G-C86QE6B`\/2`P+C`I(&-U<E]O8FHM/G-C
M86QE6B`](#`N,3L-"B`@("!C87-E("=H)SH@("\J(')O=&%T92!X('!O<VET
M:79E("HO#0H@("`@("!C=7)?;V)J+3YR;W1886YG;&4@*ST@,34N,#L-"@D@
M(&EF("AC=7)?;V)J+3YR;W1886YG;&4@/B`S-C`N,"D@8W5R7V]B:BT^<F]T
M6&%N9VQE("T](#,V,"XP.R`@("`@(`T*"2`@8G)E86L["B`@("!C87-E("=J
M)SH@("\J(')O=&%T92!Y('!O<VET:79E("HO"B`@("`@(&-U<E]O8FHM/G)O
M=%EA;F=L92`K/2`Q-2XP.PT*"2`@:68@*&-U<E]O8FHM/G)O=%EA;F=L92`^
M(#,V,"XP*2!C=7)?;V)J+3YR;W1986YG;&4@+3T@,S8P+C`["B`@("`@(&)R
M96%K.PH@("`@8V%S92`G:R<Z("`O*B!R;W1A=&4@>2!N96=A=&EV92`J+PT*
M"2`@8W5R7V]B:BT^<F]T66%N9VQE("T](#$U+C`[#0H)("!I9B`H8W5R7V]B
M:BT^<F]T66%N9VQE(#P@,"XP*2!C=7)?;V)J+3YR;W1986YG;&4@*ST@,S8P
M+C`[("`@("`@"B`@("`@(&)R96%K.PH@("`@8V%S92`G;"<Z("`O*B!R;W1A
M=&4@>"!N96=A=&EV92`J+PT*"2`@8W5R7V]B:BT^<F]T6&%N9VQE("T](#$U
M+C`[#0H)("!I9B`H8W5R7V]B:BT^<F]T6&%N9VQE(#P@,"XP*2!C=7)?;V)J
M+3YR;W1886YG;&4@*ST@,S8P+C`[("`@("`@"B`@("`@(&)R96%K.PT*"6-A
M<V4@)W$G.@H@("`@8V%S92`R-SH@("`@("`@("`@("\J($5S8R!W:6QL('%U
M:70@*B\*("`@("`@("!E>&ET*#$I.PH@("`@("`@(&)R96%K.PH@("`@9&5F
M875L=#H*("`@("`@8G)E86L["B`@("!]"B`@("!G;'5T4&]S=%)E9&ES<&QA
M>2@I.PI]#0H-"@T*+RH*("H@($AA;F1L92!-96YU<PH@*B\*=F]I9`I396QE
M8W0H:6YT('9A;'5E*0I["B`@("!S=VET8V@@*'9A;'5E*2!["B`@("!C87-E
M($U%3E5?455)5#H*("`@("`@("!E>&ET*#`I.PH@("`@("`@(&)R96%K.PT*
M"6-A<V4@345.55]215-%5#H-"@D);7E);FET*"D[(&1I<W!L87DH*3L-"@D)
M8G)E86L[#0H)8V%S92!-14Y57U-02$5215]!0U1)5D4Z#0H)("!C=7)?;V)J
M(#T@)E-P:&5R93L-"@D@(&)R96%K.PT*"6-A<V4@345.55]#54)%7T%#5$E6
M13H-"@D@(&-U<E]O8FH@/2`F0W5B93L-"@D@(&)R96%K.PT*"6-A<V4@345.
M55]414%03U1?04-4259%.@T*"2`@8W5R7V]B:B`]("9496%P;W0[#0H)("!B
M<F5A:SL-"@EC87-E($U%3E5?0T%-15)!7T%#5$E613H-"@D@(&-U<E]O8FH@
M/2`F0V%M97)A.PT*"2`@8G)E86L[#0H@("`@"B`@("!]"GT*#0HO*@H@*B`@
M36%I;B!,;V]P"B`J("!/<&5N('=I;F1O=R!W:71H(&EN:71I86P@=VEN9&]W
M('-I>F4L('1I=&QE(&)A<BP@"B`J("!21T)!(&1I<W!L87D@;6]D92P@86YD
M(&AA;F1L92!I;G!U="!E=F5N=',N"B`J+PIV;VED(&UA:6XH:6YT(&%R9V,L
M(&-H87(J*B!A<F=V*2`*>PH@('!R:6YT9B`H(E5S92!R:6=H="!B=71T;VX@
M;65N=2!T;R!S96QE8W0@;V)J96-T+EQN(BD[#0H@('!R:6YT9B`H(B=H)R`F
M("=L)R!T;R!R;W1A=&4@86)O=70@=&AE(%@M87AI<UQN(BD[#0H@('!R:6YT
M9B`H(B=J)R`F("=K)R!T;R!R;W1A=&4@86)O=70@=&AE(%DM87AI<UQN(BD[
M("`-"B`@<')I;G1F("@B)V8G('1O('-C86QE(&1O=VY<;B(I.PT*("!P<FEN
M=&8@*"(G9R<@=&\@<V-A;&4@=7!<;B(I.PT*("!P<FEN=&8@*"(G92<O)W@G
M('1O(&UO=F4@=7`O9&]W;EQN(BD[#0H@('!R:6YT9B`H(B=S)R\G9"<@=&\@
M;6]V92!L969T+W)I9VAT7&XB*3L-"B`@<')I;G1F("@B)W$G('1O('%U:71<
M;B(I.PT*#0H@(&=L=71);FET*"9A<F=C+"!A<F=V*3L-"B`@9VQU=$EN:71$
M:7-P;&%Y36]D92`H1TQ55%]$3U5"3$4@?"!'3%547U)'0D$I.PT*"2`@#0H@
M(&=L=71);FET5VEN9&]W4VEZ92`H-C`P+"`T,#`I.R`@(`T*("!G;'5T0W)E
M871E5VEN9&]W("AA<F=V6S!=*3L*("`-"B`@;7E);FET("@I.PT*"B`@9VQU
M=$ME>6)O87)D1G5N8RA+97DI.PH@(&=L=71297-H87!E1G5N8R`H;7E297-H
M87!E*3L*("!G;'5T1&ES<&QA>49U;F,H9&ES<&QA>2D["B`-"B`@9VQU=$-R
M96%T94UE;G4H4V5L96-T*3L-"B`@9VQU=$%D9$UE;G5%;G1R>2`H(E-E;&5C
M="!#=6)E(BP@345.55]#54)%7T%#5$E612D[#0H@(&=L=71!9&1-96YU16YT
M<GD@*")396QE8W0@4W!H97)E(BP@345.55]34$A%4D5?04-4259%*3L-"B`@
M9VQU=$%D9$UE;G5%;G1R>2`H(E-E;&5C="!496%P;W0B+"!-14Y57U1%05!/
M5%]!0U1)5D4I.PT*("!G;'5T061D365N=45N=')Y("@B4V5L96-T($-A;65R
M82(L($U%3E5?0T%-15)!7T%#5$E612D[#0H@(&=L=71!9&1-96YU16YT<GD@
M*")297-E="(L($U%3E5?4D53150I.PT*("!G;'5T061D365N=45N=')Y*")1
M=6ET(BP@345.55]154E4*3L*("!G;'5T071T86-H365N=2A'3%547TQ%1E1?
A0E545$].*3L*("`-"B`@9VQU=$UA:6Y,;V]P*"D["GT*
`
end
SHAR_EOF
  $shar_touch -am 0206221797 'hw1.c' &&
  chmod 0640 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
150bc364124f8166b928cb30147f1eb5  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8943 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8943,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh137116
exit 0

From ???@??? Fri Feb 07 07:34:30 1997
Received: from magritte.its.rpi.edu (platom@magritte.its.rpi.edu [128.113.113.19])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id AAA19282
	for <citrit>; Fri, 7 Feb 1997 00:43:07 -0500
From: Mark Steven Platosh <platom>
Received: (platom@localhost) by magritte.its.rpi.edu (8.6.9/8.6.4) id AAA91582 for citrit; Fri, 7 Feb 1997 00:43:05 -0500
Date: Fri, 7 Feb 1997 00:43:05 -0500
Message-Id: <199702070543.AAA91582@magritte.its.rpi.edu>
To: citrit
X-UIDL: d67df65c3116deddd57ad21e29cdcd1f

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-07 00:42 EST by <platom@magritte>.
# Source directory was `/afs/rpi.edu/home/08/platom/vis'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    272 -rw------- read.me
#  11705 -rw------- my.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh91046; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= read.me ==============
if test -f 'read.me' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'read.me' '(file already exists)'
else
  $echo 'x -' extracting 'read.me' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'read.me' &&
To control input control to the modes for each object, do the following
X
scale = l for larger, and j for smaller
X
move = l k j and their opposite directions o i u
X
rotate l j and opposite directions o u
X
camera controls l k j
X
toggle transparency l for on, and j for off
X
SHAR_EOF
  $shar_touch -am 0207004297 'read.me' &&
  chmod 0600 'read.me' ||
  $echo 'restore of' 'read.me' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'read.me:' 'MD5 check failed'
9f9cc9e895c7eee3241df15de9dcd343  read.me
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'read.me'`"
    test 272 -eq "$shar_count" ||
    $echo 'read.me:' 'original size' '272,' 'current size' "$shar_count!"
  fi
fi
# ============= my.c ==============
if test -f 'my.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'my.c' '(file already exists)'
else
  $echo 'x -' extracting 'my.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'my.c' &&
#include <GL/gl.h>
#include <GL/glut.h>
X
float 	x_s = 0.0,
X	y_s = 0.0,
X	z_s = 0.0,
X	x_t = 0.0,
X	y_t = 0.0,
X	z_t = 0.0,
X	x_sq = 0.0,
X	y_sq = 0.0,
X	z_sq = 0.0,
X	x_s_move = 2.0,
X	y_s_move = 0.0,
X	z_s_move = 0.0,
X	x_t_move = -2.0,
X	y_t_move = 0.0,
X	z_t_move = 0.0,
X	x_sq_move = 0.0,
X	y_sq_move = 0.0,
X	z_sq_move = 0.0,
X	tea_scale = 1.0, sphere_scale = 1.0, square_scale = 1.0,
X	tea_x_rotate = 0.0, tea_y_rotate = 0.0, 
X	square_x_rotate = 0.0, square_y_rotate = 0.0, 
X	sphere_x_rotate = 0.0, sphere_y_rotate = 0.0, pot_trans = 1.0; 
int ro = 0, sphere = 0;
X	
void display(void)
{
X 	GLfloat mat_sphere[] = { 0.0, 0.0, 1.0, 1.0 };
X 	GLfloat mat_teapot[] = { 0.40, 0.40, 0.0, 1.0 };
X 	GLfloat mat_square[] = { 1.0, 0.0, 0.0, 1.0 };
X        GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 }; 
X        GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 }; 
X        GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 }; 
X        GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 }; 
X        GLfloat no_shininess[] = { 1.0 }; 
X        GLfloat low_shininess[] = { 5.0 }; 
X        GLfloat high_shininess[] = { 100.0 }; 
X        GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0}; 
X
X
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X 
X     
X    glPushMatrix();
X    glTranslatef(x_sq_move, y_sq_move, z_sq_move);
X    glRotatef(square_x_rotate, 1.0, 0.0, 0.0);
X    glRotatef(square_y_rotate, 0.0, 1.0, 0.0);
X    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_square); /* Set Materials... */    
X    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
X    glScalef(square_scale, square_scale, square_scale);
X    glutSolidCube(1.0);   /*  draw the cube       */
X    glPopMatrix();
X   
X   
X    
X    glPushMatrix();
X    if(pot_trans)
X    	glEnable(GL_BLEND);
X    else
X    	glDisable(GL_BLEND);
X    	
X    /*glColor4f(0.50, 0.50, 0.0, pot_trans);*/
X    glBlendFunc(GL_SRC_ALPHA, GL_DST_ALPHA);
X    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_teapot); /* Set Materials... */
X    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_teapot);
X    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X    glTranslatef(x_t_move, y_t_move, z_t_move);
X    glRotatef(tea_x_rotate, 1.0, 0.0, 0.0);
X    glRotatef(tea_y_rotate, 0.0, 1.0, 0.0);
X    glScalef(tea_scale, tea_scale, tea_scale);
X    glutSolidTeapot(0.75); 
X    glDisable(GL_BLEND);
X    glPopMatrix();
X     
X    glPushMatrix();
X    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_sphere);
X    glTranslatef(x_s_move, y_s_move, z_s_move);/*x y and z.  for this, x - rt. y up z frnt*/
X    glRotatef(sphere_x_rotate, 1.0, 0.0, 0.0);
X    glRotatef(sphere_y_rotate, 0.0, 1.0, 0.0);
X    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_sphere);
X    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X    glScalef(sphere_scale, sphere_scale, sphere_scale);
X    glutSolidSphere(0.75, 5.0, 5.0); 
X    glPopMatrix();
X    
X    glutSwapBuffers(); 
X    glFlush();
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {1.0, 1.0, 1.0, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X      
X      glEnable(GL_BLEND);
X      glColor3f(1.0, 1.0, 1.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X   
/*     glShadeModel (GL_FLAT);
X *     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
X
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);      /*  used to w h define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,0.0,1.0);
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
void
Key_pot_rotate(unsigned char key, int x, int y)
{
X
X    switch (key) {
X    case 'l':
X      tea_x_rotate += 15;
X      break;
X      
X    case 'o':
X      tea_x_rotate -= 15;
X      break;
X      
X    case 'j':
X      tea_y_rotate += 15;
X      break;
X      
X     case 'u':
X      tea_y_rotate -= 15;
X      break;
X      
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X      
X    default:
X    break;
X    }
X  glutPostRedisplay();
}   
X
void
Key_pot_scale(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'j':
X    	tea_scale = tea_scale - 0.05;
X    	break;
X    case 'l':
X    	tea_scale = tea_scale + 0.05;
X    	break;	
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X    default:
X    	
X      break;
X    }
X    glutPostRedisplay();
}
X
X
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    case 2:
X    	glutKeyboardFunc(Key);
X    	break;
X    default:
X    	break;
X    	}
}
X
X
void
Key_pot_move(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'l':
X   	z_t_move = z_t_move + 0.75;
X   	break;
X   case 'k':
X   	y_t_move = y_t_move + 0.75;
X   	break;
X   case 'j':
X   	x_t_move = x_t_move + 0.75;
X   	break;
X    case 'o':
X   	z_t_move = z_t_move - 0.75;
X   	break;
X   case 'i':
X   	y_t_move = y_t_move - 0.75;
X   	break;
X   case 'u':
X   	x_t_move = x_t_move - 0.75;
X   	break;
X   default:
X   	break;
X   	}
X    glutPostRedisplay();
}
X
X
void
Key_pot_trans(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'l':
X   	pot_trans = 1.0;
X   	break;
X   case 'j':
X   	pot_trans = 0.0;
X   	break;
X   default:
X   	break;
X   	}
X    glutPostRedisplay();
}
X
void
teapot_menu(int value)
{
X	switch (value) {
X	case 1:
X		glutKeyboardFunc(Key_pot_rotate);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 2:
X		glutKeyboardFunc(Key_pot_scale);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 3:
X		glutKeyboardFunc(Key_pot_move);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 4:
X		glutKeyboardFunc(Key_pot_trans);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	default:
X		break;
X		}
X		}
X
void
Key_sphere_rotate(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'l':
X      sphere_x_rotate += 15;
X      break;
X      
X    case 'o':
X      sphere_x_rotate -= 15;
X      break;
X      
X    case 'j':
X      sphere_y_rotate += 15;
X      break;
X      
X     case 'u':
X      sphere_y_rotate -= 15;
X      break;
X     
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X      
X    default:
X    break;
X    }
X  glutPostRedisplay();
}   
X
void
Key_sphere_scale(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'j':
X    	sphere_scale = sphere_scale - 0.05;
X    	break;
X    case 'l':
X    	sphere_scale = sphere_scale + 0.05;
X    	break;	
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X    default:
X    	
X      break;
X    }
X    glutPostRedisplay();
}
X
void
Key_sphere_move(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'l':
X   	z_s_move = z_s_move + 0.75;
X   	break;
X   case 'k':
X   	y_s_move = y_s_move + 0.75;
X   	break;
X   case 'j':
X   	x_s_move = x_s_move + 0.75;
X   	break;
X    case 'o':
X   	z_s_move = z_s_move - 0.75;
X   	break;
X   case 'i':
X   	y_s_move = y_s_move - 0.75;
X   	break;
X   case 'u':
X   	x_s_move = x_s_move - 0.75;
X   	break;
X   default:
X   	break;
X   	}
X    glutPostRedisplay();
}
X
void
sphere_menu(int value)
{
X	switch (value) {
X	case 1:
X		glutKeyboardFunc(Key_sphere_rotate);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 2:
X		glutKeyboardFunc(Key_sphere_scale);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 3:
X		glutKeyboardFunc(Key_sphere_move);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	default:
X		break;
X		}
X		}
X
X
void
Key_square_rotate(unsigned char key, int x, int y)
{
X
X    switch (key) {
X    case 'l':
X      square_x_rotate += 15;
X      break;
X      
X    case 'o':
X      square_x_rotate -= 15;
X      break;
X      
X    case 'j':
X      square_y_rotate += 15;
X      break;
X      
X     case 'u':
X      square_y_rotate -= 15;
X      break;
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X      
X    default:
X    break;
X    }
X  glutPostRedisplay();
}   
X
void
Key_square_scale(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'j':
X    	square_scale = square_scale - 0.05;
X    	break;
X    case 'l':
X    	square_scale = square_scale + 0.05;
X    	break;	
X    case 27:           /* Esc will quit */
X      exit(1);
X      break;
X    default:
X    	
X      break;
X    }
X    glutPostRedisplay();
}
X
void
Key_square_move(unsigned char key, int x, int y)
{
X
X    switch (key) {
X   case 'l':
X   	z_sq_move = z_sq_move + 0.75;
X   	break;
X   case 'k':
X   	y_sq_move = y_sq_move + 0.75;
X   	break;
X   case 'j':
X   	x_sq_move = x_sq_move + 0.75;
X   	break;
X    case 'o':
X   	z_sq_move = z_sq_move - 0.75;
X   	break;
X   case 'i':
X   	y_sq_move = y_sq_move - 0.75;
X   	break;
X   case 'u':
X   	x_sq_move = x_sq_move - 0.75;
X   	break;
X   default:
X   	break;
X   	}
X    glutPostRedisplay();
}		
X   	
void
square_menu(int value)
{
X	switch (value) {
X	case 1:
X		glutKeyboardFunc(Key_square_rotate);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 2:
X		glutKeyboardFunc(Key_square_scale);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	case 3:
X		glutKeyboardFunc(Key_square_move);
X        	glutReshapeFunc (myReshape);
X        	glutDisplayFunc(display);
X		break;
X	
X	default:
X		break;
X		}
X		}
X
int main(int argc, char** argv) 
{
int teapot_submenu, sphere_submenu, square_submenu;
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowSize(500, 200);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      
X
X      /*glutKeyboardFunc(Key);*/
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      
X      teapot_submenu = glutCreateMenu(teapot_menu);
X      glutAddMenuEntry("Rotate - teapot", 1);
X      glutAddMenuEntry("Scale - teapot", 2);
X      glutAddMenuEntry("Move - teapot", 3);
X      glutAddMenuEntry("Toggle Transparency", 4);
X      
X      sphere_submenu = glutCreateMenu(sphere_menu);
X      glutAddMenuEntry("Rotate - sphere", 1);
X      glutAddMenuEntry("Scale - sphere", 2);
X      glutAddMenuEntry("Move - sphere", 3);
X      
X      square_submenu = glutCreateMenu(square_menu);
X      glutAddMenuEntry("Rotate - square", 1);
X      glutAddMenuEntry("Scale - square", 2);
X      glutAddMenuEntry("Move - square", 3);
X      
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Camera", 2);
X      glutAddSubMenu("Teapot", teapot_submenu);
X      glutAddSubMenu("Square", square_submenu);
X      glutAddSubMenu("Sphere", sphere_submenu);
X      glutAddMenuEntry("Quit", 1);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);      
X      
X      
X      glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206153097 'my.c' &&
  chmod 0600 'my.c' ||
  $echo 'restore of' 'my.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'my.c:' 'MD5 check failed'
4f6630df15d7eee987d4f85bfe8c3c10  my.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'my.c'`"
    test 11705 -eq "$shar_count" ||
    $echo 'my.c:' 'original size' '11705,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh91046
exit 0

From ???@??? Fri Feb 07 07:34:28 1997
Received: from linux1.acm.rpi.edu (linux1.acm.rpi.edu [128.213.5.20])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id AAA36098
	for <citrit@rpi.edu>; Fri, 7 Feb 1997 00:04:30 -0500
Received: (from mjr@localhost) by linux1.acm.rpi.edu (8.7.6/8.7.3) id AAA03785 for citrit@rpi.edu; Fri, 7 Feb 1997 00:03:55 -0500
Date: Fri, 7 Feb 1997 00:03:55 -0500
From: "Matthew J. Ryan" <mjr@linux1.acm.rpi.edu>
Message-Id: <199702070503.AAA03785@linux1.acm.rpi.edu>
To: citrit@rpi.edu
Subject: Homework #1
X-UIDL: 9a3e708d03f7414987c7801aed239878

#!/bin/sh
# This is a shell archive (produced by GNU sharut 4.2.1).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:59 EST by <mjr@vir>.
# Source directory was `/home/mjr/class/gv/proj1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    800 -rw-r--r-- Makefile
#   9819 -rw-r--r-- proj1.c
#    296 -rw-rw-r-- proj1.h
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
    shar_n= shar_c='
'
  else
    shar_n=-n shar_c=
  fi
else
  shar_n= shar_c='\c'
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
$echo $shar_n 'x -' 'lock directory' "\`_sh00902': "$shar_c
if mkdir _sh00902; then
  $echo 'created'
else
  $echo 'failed to create'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
CC=gcc
LDFLAGS= -L/usr/X11R6/lib -lglut -lMesaGLU -lMesaGL -lXmu -lXi -lXext -lXt -lX11 -lm
CFLAGS= -g -I/usr/include/mesa -I/usr/include/glut
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
proj1.o: p1.h
SHAR_EOF
  $shar_touch -am 0206123797 'Makefile' &&
  chmod 0644 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
1eccc571bdf0ddb3e6dc7ddd22300dd4  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'Makefile'`"
    test 800 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '800,' 'current size' "$shar_count!"
  fi
fi
# ============= proj1.c ==============
if test -f 'proj1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'proj1.c' '(file already exists)'
else
  $echo 'x -' extracting 'proj1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'proj1.c' &&
/*
X *
X *  Simple2.c 
X *
X *  Simple example of programming using the OpenGL graphics library
X *  Taken from the "OpenGL Programming Guide"
X *
X *
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
#include <stdio.h>
#include "proj1.h"
X
/* Global State Variables */
static objState worldInitial = {0.0, 0.0, -5.0, 0.0, 0.0, 0.0, 1.0,
X	{{0.0, 0.0, 0.0, 0.0},
X	 {0.0},
X	 {0.0, 0.0, 0.0, 0.0},
X	 {0.0, 0.0, 0.0, 0.0}}};
static objState world;
static objState cubeInitial = {0,0,0,0,0,0,1,
X	{{0.7, 0.2, 0.2, 1.0},
X	 {120.0},
X	 {0.9, 0.0, 0.0, 1.0},
X	 {1.0, 1.0, 1.0, 1.0}}};
static objState cube;
static objState sphereInitial = {2,0,0,0,0,0,1,
X	{{0.1, 0.1, 1.1, 1.0},
X	 {0.0},
X	 {1.0, 1.0, 1.0, 1.0},
X	 {0.0, 0.0, 1.0, 1.0}}};
static objState sphere;
static objState teapotInitial = {-2,0,0,0,0,0,1,
X	{{0.7, 0.7, 0.0, 1.0},
X	 {100.0},
X	 {0.6, 0.6, 0.1, 1.0},
X	 {1.0, 1.0, 0.5, 1.0}}};
static objState teapot;
X
static int sBufWin;
static int dBufWin;
X
void copyState(objState *src, objState *dest) {
X  bcopy(src, dest, sizeof(GLfloat)*7);
X  bcopy(src->mat.amb, dest->mat.amb, sizeof(float)*4);
X  bcopy(src->mat.shiny, dest->mat.shiny, sizeof(float)*1);
X  bcopy(src->mat.diff, dest->mat.diff, sizeof(float)*4);
X  bcopy(src->mat.spec, dest->mat.spec, sizeof(float)*4);
}
/*
X * Reset the program to it's initial state. 
X */
void resetWorld(void){
X  copyState(&worldInitial, &world);
X  copyState(&cubeInitial, &cube);
X  copyState(&sphereInitial, &sphere);
X  copyState(&teapotInitial, &teapot);
X  glutHideWindow();
X  glutSetWindow(dBufWin);
X  glutShowWindow();
}
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X  static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X  static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X  static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X  static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X  static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X  glPushMatrix();
X    /* Do world transformations */
X    glScalef(world.size, world.size, world.size);
X    glTranslatef(world.x, world.y, world.z);
X    glRotatef(world.rotX, 1.0, 0.0, 0.0);
X    glRotatef(world.rotY, 0.0, 1.0, 0.0);
X    glRotatef(world.rotZ, 0.0, 0.0, 1.0);
X
X    /* Set up lighting */
X    glEnable(GL_LIGHTING);
X    glEnable(GL_LIGHT0);
X    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X    glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X    glEnable(GL_DEPTH_TEST);
X
X    glPushMatrix();
X      glScalef(cube.size, cube.size, cube.size);
X      glTranslatef(cube.x/cube.size, cube.y/cube.size, cube.z/cube.size);
X      glRotatef(cube.rotX, 1.0, 0.0, 0.0);
X      glRotatef(cube.rotY, 0.0, 1.0, 0.0);
X      glRotatef(cube.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the cube */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, cube.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, cube.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, cube.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, cube.mat.shiny);
X        
X      glutSolidCube(1.0);   /*  draw the cube       */
X    glPopMatrix();
X
X    glPushMatrix();
X      glShadeModel(GL_FLAT);
X      glScalef(sphere.size, sphere.size, sphere.size);
X      glTranslatef(sphere.x/sphere.size, sphere.y/sphere.size, sphere.z/sphere.size);
X      glRotatef(sphere.rotX, 1.0, 0.0, 0.0);
X      glRotatef(sphere.rotY, 0.0, 1.0, 0.0);
X      glRotatef(sphere.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the sphere */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, sphere.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, sphere.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, sphere.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, sphere.mat.shiny);
X        
X      glutSolidSphere(0.5, 20, 20);   /*  draw the sphere       */
X      glShadeModel(GL_SMOOTH);
X    glPopMatrix();
X
X    glPushMatrix();
X      glScalef(teapot.size, teapot.size, teapot.size);
X      glTranslatef(teapot.x, teapot.y, teapot.z);
X      glRotatef(teapot.rotX, 1.0, 0.0, 0.0);
X      glRotatef(teapot.rotY, 0.0, 1.0, 0.0);
X      glRotatef(teapot.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the teapot */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, teapot.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, teapot.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, teapot.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, teapot.mat.shiny);
X        
X      glutSolidCube(1.0);   /*  draw the teapot       */
X    glPopMatrix();
X
X 
X  glPopMatrix();
X  glutSwapBuffers(); 
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 20.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X  static objState *currObj = &world;
X
X  switch (key) {
X  case '0':
X    currObj = &world;
X    break;
X  case '1':
X    currObj = &sphere;
X    break;
X  case '2':
X    currObj = &cube;
X    break;
X  case '3':
X    currObj = &teapot;
X    break;
X  case 'h':
X    currObj->x -= DEF_TRANSLATE_INC;
X    break;
X  case 'l':
X    currObj->x += DEF_TRANSLATE_INC;
X    break;
X  case 'j':
X    currObj->y -= DEF_TRANSLATE_INC;
X    break;
X  case 'k':
X    currObj->y += DEF_TRANSLATE_INC;
X    break;
X  case 'i':  
X    currObj->z -= DEF_TRANSLATE_INC;
X    break;
X  case 'm':
X    currObj->z += DEF_TRANSLATE_INC;
X    break;
X  case 'x':
X    currObj->rotX -= DEF_ROTATE_INC;
X    break;
X  case 'X':
X    currObj->rotX += DEF_ROTATE_INC;
X    break;
X  case 'y':
X    currObj->rotY -= DEF_ROTATE_INC;
X    break;
X  case 'Y':
X    currObj->rotY += DEF_ROTATE_INC;
X    break;
X  case 'z':
X    currObj->rotZ -= DEF_ROTATE_INC;
X    break;
X  case 'Z':
X    currObj->rotZ += DEF_ROTATE_INC;
X    break;
X  case '+':
X    currObj->size += DEF_SCALE_INC;
X    break;
X  case '-':
X    currObj->size -= DEF_SCALE_INC;
X    break;
#ifdef DEBUG
X  case 'd':
X    fprintf(stderr, "World: %f %f %f %f %f %f\n", world.x, world.y, world.z,
X		world.rotX, world.rotY, world.rotZ);
X    fprintf(stderr, "Cube: %f %f %f %f %f %f\n", cube.x, cube.y, cube.z,
X		cube.rotX, cube.rotY, cube.rotZ);
X    fprintf(stderr, "Sphere: %f %f %f %f %f %f\n", sphere.x, sphere.y, sphere.z,
X		sphere.rotX, sphere.rotY, sphere.rotZ);
X    fprintf(stderr, "Teapot: %f %f %f %f %f %f\n", teapot.x, teapot.y, teapot.z,
X		teapot.rotX, teapot.rotY, teapot.rotZ);
X    break;
#endif
X  case 'q':	/* 'q' will exit */
X  case 27:	/* Esc will exit */
X    exit(1);
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
/* Callback for the main menu */
void
menuMain(int value)
{
X  switch (value) {
X  case 1: /* Change to single buffered mode. */
X    glutChangeToMenuEntry(1, "Set doublebuffer", 2);
X    glutHideWindow();
X    glutSetWindow(sBufWin);
X    glutShowWindow();
X    break;
X  case 2: /* Change to double buffered mode. */
X    glutChangeToMenuEntry(1, "Set singlebuffer", 1);
X    glutHideWindow();
X    glutSetWindow(dBufWin);
X    glutShowWindow();
X    break;
X  case 3:
X    resetWorld();
X    glutPostRedisplay;
X    break;
X  case 4:
X    exit(0);
X    break;
X  }
}
X
/* Callback for the Selection submenu. */
void menuSelection(int value)
{
X  switch(value) {
X  case 0:
X    Key('0', 0, 0);
X    break;
X  case 1:
X    Key('1', 0, 0);
X    break;
X  case 2:
X    Key('2', 0, 0);
X    break;
X  case 3:
X    Key('3', 0, 0);
X    break;
X  }
}
X
void printDoc(void) {
X  printf("The Selection submenu let's you choose which (or all) objects to move.\n");
X  printf("Use the set {single|double}buffer menu item to switch between single\nand double buffering.\n");
X  printf("Keys:\n");
X  printf("x = Pos. X axis rotation        X = Neg. X axis rotation\n");
X  printf("y = Pos. Y axis rotation        Y = Neg. Y axis rotation\n");
X  printf("z = Pos. Z axis rotation        Z = Neg. Z axis rotation\n");
X  printf("h = Neg. X axis translation     l = Pos. X axis translation\n");
X  printf("j = Neg. Y axis translation     k = Pos. Y axis translation\n");
X  printf("i = Neg. Z axis translation     m = Pos. Z axis translation\n");
X  printf("+ = Increase object(s) size     - = Decrease object(s) size\n");
}
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X  int menuSelectionId;
X
X  printDoc();
X  glutInit(&argc, argv);
X
X  /* Set up menu structure */
X  menuSelectionId = glutCreateMenu(menuSelection);
X  glutAddMenuEntry("All", 0);
X  glutAddMenuEntry("Sphere", 1);
X  glutAddMenuEntry("Cube", 2);
X  glutAddMenuEntry("Teapot", 3);
X  glutCreateMenu(menuMain);
X  glutAddSubMenu("Selection", menuSelectionId);
X  glutAddMenuEntry("Framebuffer: single", 1);
X  glutAddMenuEntry("Reset", 3);
X  glutAddMenuEntry("Quit", 4);
X
X  /* Set up single buffered window. */
X  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGBA);
X  sBufWin = glutCreateWindow(argv[0]);
X  glutKeyboardFunc(Key);
X  glutReshapeFunc(myReshape);
X  glutDisplayFunc(display);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X  glutHideWindow();
X
X  /* Set up double buffered window */
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X  dBufWin = glutCreateWindow(argv[0]);
X  glutKeyboardFunc(Key);
X  glutReshapeFunc(myReshape);
X  glutDisplayFunc(display);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X  /* Reset the world */
X  resetWorld();
X
X  /* We're off! */
X  glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206235897 'proj1.c' &&
  chmod 0644 'proj1.c' ||
  $echo 'restore of' 'proj1.c' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'proj1.c:' 'MD5 check failed'
eff707f9081dda03850a86c0d036d00b  proj1.c
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'proj1.c'`"
    test 9819 -eq "$shar_count" ||
    $echo 'proj1.c:' 'original size' '9819,' 'current size' "$shar_count!"
  fi
fi
# ============= proj1.h ==============
if test -f 'proj1.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'proj1.h' '(file already exists)'
else
  $echo 'x -' extracting 'proj1.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'proj1.h' &&
#define DEF_ROTATE_INC 15.0
#define DEF_TRANSLATE_INC 0.1
#define DEF_SCALE_INC 0.1
X
typedef struct {
X	GLfloat x;
X	GLfloat y;
X	GLfloat z;
X	GLfloat rotX;
X	GLfloat rotY;
X	GLfloat rotZ;
X	GLfloat size;
X	struct {
X		float amb[4];
X		float shiny[1];
X		float diff[4];
X		float spec[4];
X	} mat;
} objState;
SHAR_EOF
  $shar_touch -am 0206191197 'proj1.h' &&
  chmod 0664 'proj1.h' ||
  $echo 'restore of' 'proj1.h' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'proj1.h:' 'MD5 check failed'
59ec2c9b6a988542e005111e9e19980e  proj1.h
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'proj1.h'`"
    test 296 -eq "$shar_count" ||
    $echo 'proj1.h:' 'original size' '296,' 'current size' "$shar_count!"
  fi
fi
$echo $shar_n 'x -' 'lock directory' '_sh00902:' $shar_c
if rm -fr _sh00902; then
  $echo 'removed'
else
  $echo 'failed to remove'
fi
exit 0

From ???@??? Fri Feb 07 07:33:34 1997
Received: from cortez.sss.rpi.edu (schnem@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA28512
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 23:10:18 -0500
From: Matthew Schnee <schnem>
Received: (schnem@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id XAA87526 for citrit@rpi.edu; Thu, 6 Feb 1997 23:10:17 -0500
Date: Thu, 6 Feb 1997 23:10:17 -0500
Message-Id: <199702070410.XAA87526@cortez.sss.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: 4f56ba4a0e330bb11a9ddd9548660e78

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 23:09 EST by <schnem@cortez>.
# Source directory was `/afs/rpi.edu/home/89/schnem/private/graphvis'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  14390 -rw------- proj1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh123114; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= proj1.c ==============
if test -f 'proj1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'proj1.c' '(file already exists)'
else
  $echo 'x -' extracting 'proj1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'proj1.c' &&
/* Matthew Schnee */
/* Advanced Computer Graphics and Data Visualization */
/* RCS userid: schnem */
X
/* keys to operate motion */
/*
X * s rotates +x
X * x rotates -x
X * d rotates +y
X * c rotates -y
X * a rotates +z
X * z rotates -z
X *
X * k moves +x
X * . moves -x
X * j moves +y
X * m moves -y
X * l moves +z
X * . moves -z
X *
X * g increases object size
X * b decreases object size
X */
X
X
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
#include <stdlib.h>
#include <stdio.h>
X
X
#define rotate_inc 15.0
#define translate_inc 0.25
#define scale_inc 0.125
X
/* this state variable tells the keyboard handler which object to rotate */
int obj_to_rot = 0;
X
X
/* strucutre definition for the objects and their rotations */
X
struct obj_rot_pos_s
{
X  GLfloat x;
X  GLfloat y;
X  GLfloat z;
X  GLfloat xpos;
X  GLfloat ypos;
X  GLfloat zpos;
X  GLfloat scale;
};
X
/* these are to be bale to reset the objects to their original positions */
X
struct obj_rot_pos_s save_cube_rot = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};
struct obj_rot_pos_s save_sphere_rot = {0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.60};
struct obj_rot_pos_s save_teapot_rot = {0.0, 0.0, 0.0, -2.0, 0.0, 0.0, 0.60};
struct obj_rot_pos_s save_observer_rot = {0.0, 0.0, 0.0, 0.0, 0.0, -6.0, 0.0};
X
/* the objects original positiions */
/* the observer is treated as an object because it has the same 
X   properties as the other objects */
X
struct obj_rot_pos_s cube_rot = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};
struct obj_rot_pos_s sphere_rot = {0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.60};
struct obj_rot_pos_s teapot_rot = {0.0, 0.0, 0.0, -2.0, 0.0, 0.0, 0.60};
struct obj_rot_pos_s observer_rot = {0.0, 0.0, 0.0, 0.0, 0.0, -6.0, 0.0};
X
X
/*
X *  Clear the screen.
X *  Draw the objects and the lights with the proper rotations and 
X *  positions.
X */
void display(void)
{
X  /* material properties for the cube */
X  static float cube_amb[4] = {0.5, 0.2, 0.2, 1.0};
X  static float cube_shiny[1] = {120.0};
X  static float cube_diff[4] = {0.9, 0.0 ,0.0 ,1.0 };
X  static float cube_spec[4] = {1.0 , 1.0 ,1.0 ,1.0};
X
X  /* material properties for the sphere */
X  static float sphere_amb[4] = {0.1, 0.1, 0.6, 1.0};
X  static float sphere_shiny[1] = {0.0};
X  static float sphere_diff[4] = {0.0, 0.0 ,0.6 ,1.0 };
X  static float sphere_spec[4] = {0.0 , 0.0 ,0.0 ,1.0};
X  
X  /* material propertoes for the teapot */
X  static float teapot_amb[4] = {0.2, 0.2, 0.0, 1.0};
X  static float teapot_shiny[1] = {100.0};
X  static float teapot_diff[4] = {0.6, 0.6 ,0.1 ,1.0 };
X  static float teapot_spec[4] = {1.0 , 1.0 ,0.5 ,1.0};
X  
X  /* properties for the first light */
X  static float lightPos[4] = {0.0, 3.0, 8.0, 1.0};
X  static float lightDir[4] = {0.0, 0.0, -1.0};
X  static float lightAmb[4] = {0.4, 0.4, 0.4, 1.0};
X  static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X  static float lightSpec[4] = {0.5, 0.5, 0.5, 1.0};
X  
X  /* properties fo rthe second light */
X  /* 
X   *  the second light is a spot light that initially shines directly 
X   *  on the teapot 
X   */
X  static float lightPos1[4] = {-2.0, 0.0, 15.0, 1.0};
X  static float lightDir1[4] = {0.0, 0.0, -1.0};
X  static float lightAmb1[4] = {0.1, 0.1, 0.1, 1.0};
X  static float lightDiff1[4] = {0.5, 0.5, 0.5, 1.0};
X  static float lightSpec1[4] = {0.3, 0.3 ,0.3 , 1.0};
X
X  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X      
X  glPushMatrix();
X
X    glPushMatrix();
X
X      /* Move the world around for the observer position */
X      glTranslatef(observer_rot.xpos, observer_rot.ypos, observer_rot.zpos);
X
X      glRotatef(observer_rot.x, 1.0,0.0,0.0);
X      glRotatef(observer_rot.y, 0.0,1.0,0.0);
X      glRotatef(observer_rot.z, 0.0,0.0,1.0);
X
X      /* add the lights to the world */
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X
X      glLightfv(GL_LIGHT1, GL_POSITION, lightPos1);
X      glLightfv(GL_LIGHT1, GL_AMBIENT, lightAmb1);
X      glLightfv(GL_LIGHT1, GL_DIFFUSE, lightDiff1);
X      glLightfv(GL_LIGHT1, GL_SPECULAR, lightSpec1);
X      glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, lightDir1);
X      glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, 8.0);
X
X      glPushMatrix();
X    
X        /* do the translation and rotations for the cube */
X
X        glTranslatef(cube_rot.xpos, cube_rot.ypos, cube_rot.zpos);
X
X        glRotatef(cube_rot.x, 1.0,0.0,0.0);
X        glRotatef(cube_rot.y, 0.0,1.0,0.0);
X        glRotatef(cube_rot.z, 0.0,0.0,1.0);
X
X        /* set the material properties for the cube */
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, cube_amb);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, cube_diff);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, cube_spec);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, cube_shiny);
X        
X        /* draw the cube */
X        glutSolidCube(cube_rot.scale);   /*  draw the cube       */
X
X      glPopMatrix();
X
X      glPushMatrix();
X
X        /* set the shading model to flat so the sphere looks bumpy 
X	 * (in 64k or 16M colors 
X	 */
X        glShadeModel (GL_FLAT);
X
X        /* translation and ritations for the sphere */
X        glTranslatef(sphere_rot.xpos, sphere_rot.ypos, sphere_rot.zpos);
X 
X        glRotatef(sphere_rot.x, 1.0,0.0,0.0);
X        glRotatef(sphere_rot.y, 0.0,1.0,0.0);
X        glRotatef(sphere_rot.z, 0.0,0.0,1.0);
X
X        /* set the material properties for the sphere */
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, sphere_amb);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, sphere_diff);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, sphere_spec);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, sphere_shiny);
X
X        /* draw the sphere */
X        glutSolidSphere(sphere_rot.scale,25,25); /* draw the sphere */
X
X        /* set the shade model back to smooth for the teapot */
X        glShadeModel (GL_SMOOTH);
X
X      glPopMatrix();
X
X      glPushMatrix();
X
X        /* translate and rotate for the teapot */
X        glTranslatef(teapot_rot.xpos, teapot_rot.ypos, teapot_rot.zpos);
X
X        glRotatef(teapot_rot.x, 1.0,0.0,0.0);
X        glRotatef(teapot_rot.y, 0.0,1.0,0.0);
X        glRotatef(teapot_rot.z, 0.0,0.0,1.0);
X
X        /* set the material properties for the teapot.  It is shiny */
X        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, teapot_amb);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, teapot_diff);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, teapot_spec);
X        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, teapot_shiny);
X
X        /* draw the teapot */
X        glutSolidTeapot(teapot_rot.scale);
X        /* shile developing the code I used a torus instead of a teapot
X	   because it was much faster to render */
/*        glutSolidTorus(teapot_rot.scale/(GLfloat)2,teapot_rot.scale,10,20); */
X
X      glPopMatrix();
X
X    glPopMatrix();
X
X  glPopMatrix();
X
X  glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
X      glLoadIdentity();
X      glPushMatrix();
X      
X      glColor3f(1.0, 1.0, 1.0);
X
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glEnable(GL_LIGHT1);
X
X      glEnable(GL_DEPTH_TEST);
/*     glShadeModel (GL_FLAT);
X *     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 20.0);
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 's':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.x+=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.x+=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.x+=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.x+=rotate_inc;
X	  break;
X	}
X      break;
X    case 'x':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.x-=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.x-=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.x-=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.x-=rotate_inc;
X	  break;
X	}
X      break;
X    case 'd':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.y+=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.y+=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.y+=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.y+=rotate_inc;
X	  break;
X	}
X      break;
X    case 'c':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.y-=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.y-=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.y-=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.y-=rotate_inc;
X	  break;
X	}
X      break;
X    case 'a':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.z+=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.z+=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.z+=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.z+=rotate_inc;
X	  break;
X	}
X      break;
X    case 'z':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.z-=rotate_inc;
X	  break;
X	case 1:
X	  sphere_rot.z-=rotate_inc;
X	  break;
X	case 2:
X	  teapot_rot.z-=rotate_inc;
X	  break;
X	case 3:
X	  observer_rot.z-=rotate_inc;
X	  break;
X	}
X      break;
X    case 'k':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.xpos+=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.xpos+=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.xpos+=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.xpos+=translate_inc;
X	  break;
X	}
X      break;
X    case ',':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.xpos-=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.xpos-=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.xpos-=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.xpos-=translate_inc;
X	  break;
X	}
X      break;
X    case 'j':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.ypos+=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.ypos+=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.ypos+=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.ypos+=translate_inc;
X	  break;
X	}
X      break;
X    case 'm':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.ypos-=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.ypos-=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.ypos-=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.ypos-=translate_inc;
X	  break;
X	}
X      break;
X    case 'l':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.zpos+=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.zpos+=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.zpos+=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.zpos+=translate_inc;
X	  break;
X	}
X      break;
X    case '.':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.zpos-=translate_inc;
X	  break;
X	case 1:
X	  sphere_rot.zpos-=translate_inc;
X	  break;
X	case 2:
X	  teapot_rot.zpos-=translate_inc;
X	  break;
X	case 3:
X	  observer_rot.zpos-=translate_inc;
X	  break;
X	}
X      break;
X    case 'g':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.scale+=scale_inc;
X	  break;
X	case 1:
X	  sphere_rot.scale+=scale_inc;
X	  break;
X	case 2:
X	  teapot_rot.scale+=scale_inc;
X	  break;
X	case 3:
X	  observer_rot.scale+=scale_inc;
X	  break;
X	}
X      break;
X    case 'b':
X      switch (obj_to_rot)
X	{
X	case 0:
X	  cube_rot.scale-=scale_inc;
X	  break;
X	case 1:
X	  sphere_rot.scale-=scale_inc;
X	  break;
X	case 2:
X	  teapot_rot.scale-=scale_inc;
X	  break;
X	case 3:
X	  observer_rot.scale-=scale_inc;
X	  break;
X	}
X      break;
X
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    case 2:
X	obj_to_rot = 0;
X	break;
X    case 3:
X	obj_to_rot = 1;
X	break;
X    case 4:
X	obj_to_rot = 2;
X	break;
X    case 5:
X	obj_to_rot = 3;
X	break;
X    case 6:
X	/* reset the objects to their original positions in the world */
X
X 	cube_rot.x=save_cube_rot.x;
X	cube_rot.y=save_cube_rot.y;
X	cube_rot.z=save_cube_rot.z;
X	cube_rot.xpos=save_cube_rot.xpos;
X	cube_rot.ypos=save_cube_rot.ypos;
X	cube_rot.zpos=save_cube_rot.zpos;
X	cube_rot.scale=save_cube_rot.scale;
X
X	sphere_rot.x=save_sphere_rot.x;
X	sphere_rot.y=save_sphere_rot.y;
X	sphere_rot.z=save_sphere_rot.z;
X	sphere_rot.xpos=save_sphere_rot.xpos;
X	sphere_rot.ypos=save_sphere_rot.ypos;
X	sphere_rot.zpos=save_sphere_rot.zpos;
X	sphere_rot.scale=save_sphere_rot.scale;
X
X	teapot_rot.x=save_teapot_rot.x;
X	teapot_rot.y=save_teapot_rot.y;
X	teapot_rot.z=save_teapot_rot.z;
X	teapot_rot.xpos=save_teapot_rot.xpos;
X	teapot_rot.ypos=save_teapot_rot.ypos;
X	teapot_rot.zpos=save_teapot_rot.zpos;
X	teapot_rot.scale=save_teapot_rot.scale;
X
X	observer_rot.x=save_observer_rot.x;
X	observer_rot.y=save_observer_rot.y;
X	observer_rot.z=save_observer_rot.z;
X	observer_rot.xpos=save_observer_rot.xpos;
X	observer_rot.ypos=save_observer_rot.ypos;
X	observer_rot.zpos=save_observer_rot.zpos;
X	observer_rot.scale=save_observer_rot.scale;
X
X	obj_to_rot = 0;
X
X	glutPostRedisplay();	
X	break;
X    }
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X  /* print out the help information to tell how to use it */
X  printf("The object to be manipulated is selected by the menu\n");
X  printf("Tho model can be reset using the menu by pressing the right mouse button\n");
X  printf("The keys to operate the model and their meanings are\n");
X  printf("s rotates +x\t\tx rotates -x\n");
X  printf("d rotates +y\t\tc rotates -y\n");
X  printf("a rotates +z\t\tz rotates -z\n");
X  printf("k moves +x\t\t, moves -x\n");
X  printf("j moves +y\t\tm moves -y\n");
X  printf("l moves +z\t\t. moves -z\n");
X  printf("g increases object size\tb decreases object size\n\n");
X
X
X  glutInitWindowSize(600,400);
X  glutInit(&argc, argv);
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X  glutCreateWindow (argv[0]);
X  myInit ();
X  glutKeyboardFunc(Key);
X  glutReshapeFunc (myReshape);
X  glutDisplayFunc(display);
X  glutCreateMenu(Select);
X  /* add entries to the menu */
X  glutAddMenuEntry("Quit", 1);
X  glutAddMenuEntry("Manipulate Cube", 2);
X  glutAddMenuEntry("Manipulate Sphere", 3);
X  glutAddMenuEntry("Manipulate Teapot", 4);
X  glutAddMenuEntry("Manipulate Observer", 5);
X  glutAddMenuEntry("Reset Objects",6);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X  glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0204223697 'proj1.c' &&
  chmod 0600 'proj1.c' ||
  $echo 'restore of' 'proj1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'proj1.c:' 'MD5 check failed'
42cdba5a6e45fd8acf3d687a3470d052  proj1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'proj1.c'`"
    test 14390 -eq "$shar_count" ||
    $echo 'proj1.c:' 'original size' '14390,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh123114
exit 0

From ???@??? Fri Feb 07 07:33:09 1997
Received: from marcus.its.rpi.edu (wangm@marcus.its.rpi.edu [128.113.113.16])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id SAA29012
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 18:11:37 -0500
From: Michael Wang <wangm>
Received: (wangm@localhost) by marcus.its.rpi.edu (8.6.9/8.6.4) id SAA60896 for citrit@rpi.edu; Thu, 6 Feb 1997 18:11:34 -0500
Date: Thu, 6 Feb 1997 18:11:34 -0500
Message-Id: <199702062311.SAA60896@marcus.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 884441356f2de186ebe4c80429dd2691

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 18:11 EST by <wangm@marcus>.
# Source directory was `/afs/rpi.edu/home/36/wangm/DataVis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  11196 -rw-rw-r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh85929; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 hw1.c
M(VEF9&5F(%=)3C,R#0HC:6YC;'5D92`\=VEN9&]W<RYH/@T*(V5N9&EF#0H-
M"B-I;F-L=61E(#Q'3"]G;"YH/@T*(VEN8VQU9&4@/$=,+V=L=70N:#X-"@T*
M=F]I9"!396QE8W0H:6YT*3L-"@T*:6YT(&)U9CL-"FEN="!T<F%N<SL-"FEN
M="!O8FIE8W0[#0H-"F9L;V%T($%M8FEE;G1#6S1=(#T@>R`P+C(U+"`P+C(U
M+"`P+C(U+"`Q+C`@?3L-"F9L;V%T($1I9F9U<V5#6S1=(#T@>R`P+C0L(#`N
M-"P@,"XT+"`Q+C`@?3L-"F9L;V%T(%-P96-U;&%R0ULT72`]('L@.2XP+"`Y
M+C`L(#DN,"P@,2XP('T[#0IF;&]A="!3:&EN:6YE<W-#6S%=(#T@>R`W,"XP
M('T[#0IF;&]A="!L:6=H=%!O<T-;-%T@/2![+C4L(#`N-2P@,2XP+"`Q+C!]
M.PT*#0IF;&]A="!!;6)I96YT4ULT72`]('L@+C4L("XU+"`N-2P@,2XP('T[
M#0IF;&]A="!$:69F=7-E4ULT72`]('L@,2XT+"`Q+C0L(#$N-"P@,2XP('T[
M#0IF;&]A="!3<&5C=6QA<E-;-%T@/2![(#`N,"P@,"XP+"`P+C`L(#$N,"!]
M.PT*9FQO870@4VAI;FEN97-S4ULQ72`]('L@,3`N,"!].PT*9FQO870@;&EG
M:'10;W-36S1=(#T@>S$N,"P@,2XP+"`P+C(L(#$N,'T[#0H-"G1Y<&5D968@
M<W1R=6-T#0I[#0H)9FQO870@86YG;&5X.PT*"69L;V%T(&%N9VQE>3L-"@EF
M;&]A="!A;F=L97H[#0H)9FQO870@<&]S>#L-"@EF;&]A="!P;W-Y.PT*"69L
M;V%T('!O<WH[#0H)9FQO870@<VEZ93L-"GT@4&%R86UE=&5R<SL-"@T*4&%R
M86UE=&5R<R!#=6)E.PT*4&%R86UE=&5R<R!3<&AE<F4[#0I087)A;65T97)S
M(%1E87!O=#L-"E!A<F%M971E<G,@06QT97([#0H-"G9O:60@9&ES<&QA>5]I
M;G-T<G5C=&EO;G,H=F]I9"D-"GL-"@EP<FEN=&8H(DUI8VAA96P@5V%N9R`M
M($AO;65W;W)K($%S<VEG;FUE;G0@(S%<;EQN(BD[#0H)<')I;G1F*")4<F%N
M<VQA=&EO;B!#;VYT<F]L($ME>7,Z7&XB*3L-"@EP<FEN=&8H(BM8+RU8.B`@
M;"]J7&XB*3L-"@EP<FEN=&8H(BM9+RU9.B`@:2]K7&XB*3L-"@EP<FEN=&8H
M(BM:+RU:.B`@=2]O7&Y<;B(I.PT*#0H)<')I;G1F*")2;W1A=&EO;B!#;VYT
M<F]L($ME>7,Z7&XB*3L-"@EP<FEN=&8H(BM8+RU8.B`@<R]F7&XB*3L-"@EP
M<FEN=&8H(BM9+RU9.B`@92]D7&XB*3L-"@EP<FEN=&8H(BM:+RU:.B`@=R]R
M7&Y<;B(I.PT*#0H)<')I;G1F*")38V%L92!#;VYT<F]L($ME>7,Z7&XB*3L-
M"@EP<FEN=&8H(DEN8W)E87-E('-I>F4Z("`N("AP97)I;V0I7&XB*3L-"@EP
M<FEN=&8H(D1E8W)E87-E('-I>F4Z("`L("AC;VUM82E<;EQN(BD[#0H-"@EP
M<FEN=&8H(E1O9V=L92!T<F%N<W!A<F5N="]S;VQI9"!T96%P;W0Z("!T7&XB
M*3L-"@EP<FEN=&8H(E1O9V=L92!S:6YG;&4O9&]U8FQE(&)U9F9E<FEN9R!B
M=69F97)I;F<Z("!B7&Y<;B(I.PT*#0H)<')I;G1F*").;W1E.B`@5&\@<V5L
M96-T('=H:6-H(&]B:F5C="!T;R!M86YI<'5L871E+"!O<B!T;UQN(BD[#0H)
M<')I;G1F*")C:&%N9V4@=&AE(&-A;65R82!V:65W+"!D97!R97-S(')I9VAT
M+6UO=7-E(&)U='1O;BY<;B(I.PT*?0T*#0IV;VED(&EN:71?<&%R86UE=&5R
M<RAV;VED*0T*>PT*"4%L=&5R+F%N9VQE>"`](#`[#0H)06QT97(N86YG;&5Y
M(#T@,#L-"@E!;'1E<BYA;F=L97H@/2`P.PT*"4%L=&5R+G!O<W@@/2`P.PT*
M"4%L=&5R+G!O<WD@/2`P.PT*"4%L=&5R+G!O<WH@/2`P.PT*#0H)0W5B92YA
M;F=L97@@/2`P.PT*"4-U8F4N86YG;&5Y(#T@,#L-"@E#=6)E+F%N9VQE>B`]
M(#`[#0H)0W5B92YP;W-X(#T@,#L-"@E#=6)E+G!O<WD@/2`P.PT*"4-U8F4N
M<&]S>B`](#`[#0H)0W5B92YS:7IE(#T@,"XW-3L-"@T*"5-P:&5R92YA;F=L
M97@@/2`P.PT*"5-P:&5R92YA;F=L97D@/2`P.PT*"5-P:&5R92YA;F=L97H@
M/2`P.PT*"5-P:&5R92YP;W-X(#T@,CL-"@E3<&AE<F4N<&]S>2`](#`[#0H)
M4W!H97)E+G!O<WH@/2`P.PT*"5-P:&5R92YS:7IE(#T@,"XU.PT*#0H)5&5A
M<&]T+F%N9VQE>"`](#`[#0H)5&5A<&]T+F%N9VQE>2`](#`[#0H)5&5A<&]T
M+F%N9VQE>B`](#`[#0H)5&5A<&]T+G!O<W@@/2`M,CL-"@E496%P;W0N<&]S
M>2`](#`[#0H)5&5A<&]T+G!O<WH@/2`P.PT*"51E87!O="YS:7IE(#T@,"XU
M.PT*#0H);V)J96-T(#T@,#L-"@ET<F%N<R`](#`[#0I]#0H-"G9O:60@9&ES
M<&QA>2AV;VED*0T*>PT*"6EN="!I.PT*"0T*"6=L0VQE87(H1TQ?0T],3U)?
M0E5&1D527T))5"!\($=,7T1%4%1(7T)51D9%4E]"250I.PT*#0H)9VQ%;F%B
M;&4H1TQ?3$E'2%1)3D<I.PT*#0H)9VQ,:6=H=&9V*$=,7TQ)1TA4,"P@1TQ?
M4$]3251)3TXL(&QI9VAT4&]S0RD[#0H)9VQ,:6=H=&9V*$=,7TQ)1TA4,"P@
M1TQ?04U"245.5"P@06UB:65N=$,I.PT*"6=L3&EG:'1F=BA'3%],24=(5#`L
M($=,7T1)1D954T4L($1I9F9U<V5#*3L-"@EG;$QI9VAT9G8H1TQ?3$E'2%0P
M+"!'3%]34$5#54Q!4BP@4W!E8W5L87)#*3L-"@T*"6=L3&EG:'1F=BA'3%],
M24=(5#$L($=,7U!/4TE424].+"!L:6=H=%!O<U,I.PT*"6=L3&EG:'1F=BA'
M3%],24=(5#$L($=,7T%-0DE%3E0L($%M8FEE;G13*3L-"@EG;$QI9VAT9G8H
M1TQ?3$E'2%0Q+"!'3%]$249&55-%+"!$:69F=7-E4RD[#0H)9VQ,:6=H=&9V
M*$=,7TQ)1TA4,2P@1TQ?4U!%0U5,05(L(%-P96-U;&%R4RD[#0H-"B\O861J
M=7-T('1H92!C86UE<F$@=FEE=PT*"6EF*&]B:F5C=#T],"D-"@E[#0H)"6=L
M4'5S:$UA=')I>"@I.PT*"0EG;$UA=')I>$UO9&4H1TQ?4%)/2D5#5$E/3BD[
M#0H)"6=L5')A;G-L871E9BA!;'1E<BYP;W-X+"!!;'1E<BYP;W-Y+"!!;'1E
M<BYP;W-Z*3L-"@D)9VQ2;W1A=&5F*$%L=&5R+F%N9VQE>"P@,2P@,"P@,"D[
M#0H)"6=L4F]T871E9BA!;'1E<BYA;F=L97DL(#`L(#$L(#`I.PT*"0EG;%)O
M=&%T968H06QT97(N86YG;&5Z+"`P+"`P+"`Q*3L-"@D)9VQ0;W!-871R:7@H
M*3L-"@D)9VQ-871R:7A-;V1E*$=,7TU/1$5,5DE%5RD[#0H)?0T*#0HO+V1R
M87<@=&AE(&-U8F4-"@EG;$5N86)L92A'3%]#3TQ/4E]-051%4DE!3"D[#0H)
M9VQ#;VQO<DUA=&5R:6%L*$=,7T923TY47T%.1%]"04-++"!'3%]!34))14Y4
M7T%.1%]$249&55-%*3L-"@EG;$-O;&]R,V8H,2XP+"`P+C`L(#`N,"D[#0H)
M9VQ%;F%B;&4H1TQ?3$E'2%0P*3L-"@EG;$UA=&5R:6%L9G8H1TQ?1E)/3E1?
M04Y$7T)!0TLL($=,7T%-0DE%3E0L($%M8FEE;G1#*3L-"@EG;$UA=&5R:6%L
M9G8H1TQ?1E)/3E1?04Y$7T)!0TLL($=,7T1)1D954T4L($1I9F9U<V5#*3L-
M"@EG;$UA=&5R:6%L9G8H1TQ?1E)/3E1?04Y$7T)!0TLL($=,7U-014-53$%2
M+"!3<&5C=6QA<D,I.PT*"6=L36%T97)I86QF=BA'3%]&4D].5%]!3D1?0D%#
M2RP@1TQ?4TA)3DE.15-3+"!3:&EN:6YE<W-#*3L-"@EG;%!U<VA-871R:7@H
M*3L-"@EI9BAO8FIE8W0]/3$I#0H)>PT*"0E#=6)E+F%N9VQE>"`K/2!!;'1E
M<BYA;F=L97@[#0H)"4-U8F4N86YG;&5Y("L]($%L=&5R+F%N9VQE>3L-"@D)
M0W5B92YA;F=L97H@*ST@06QT97(N86YG;&5Z.PT*"0E#=6)E+G!O<W@@*ST@
M06QT97(N<&]S>#L-"@D)0W5B92YP;W-Y("L]($%L=&5R+G!O<WD[#0H)"4-U
M8F4N<&]S>B`K/2!!;'1E<BYP;W-Z.PT*#0H)"4%L=&5R+F%N9VQE>"`](#`[
M#0H)"4%L=&5R+F%N9VQE>2`](#`[#0H)"4%L=&5R+F%N9VQE>B`](#`[#0H)
M"4%L=&5R+G!O<W@@/2`P.PT*"0E!;'1E<BYP;W-Y(#T@,#L-"@D)06QT97(N
M<&]S>B`](#`[#0H)?0T*"6=L5')A;G-L871E9BA#=6)E+G!O<W@L($-U8F4N
M<&]S>2P@0W5B92YP;W-Z*3L-"@EG;%)O=&%T968H0W5B92YA;F=L97@L(#$L
M(#`L(#`I.PT*"6=L4F]T871E9BA#=6)E+F%N9VQE>2P@,"P@,2P@,"D[#0H)
M9VQ2;W1A=&5F*$-U8F4N86YG;&5Z+"`P+"`P+"`Q*3L-"@EG;'5T4V]L:61#
M=6)E*$-U8F4N<VEZ92D[#0H)9VQ0;W!-871R:7@H*3L-"@T*+R]D<F%W('1H
M92!S<&AE<F4-"@EG;%!U<VA-871R:7@H*3L-"@EG;$1I<V%B;&4H1TQ?3$E'
M2%0P*3L-"@EG;$5N86)L92A'3%],24=(5#$I.PT*"6=L36%T97)I86QF=BA'
M3%]&4D].5%]!3D1?0D%#2RP@1TQ?04U"245.5"P@06UB:65N=%,I.PT*"6=L
M36%T97)I86QF=BA'3%]&4D].5%]!3D1?0D%#2RP@1TQ?1$E&1E5312P@1&EF
M9G5S95,I.PT*"6=L36%T97)I86QF=BA'3%]&4D].5%]!3D1?0D%#2RP@1TQ?
M4U!%0U5,05(L(%-P96-U;&%R4RD[#0H)9VQ-871E<FEA;&9V*$=,7T923TY4
M7T%.1%]"04-++"!'3%]32$E.24Y%4U,L(%-H:6YI;F5S<U,I.PT*"6EF*&]B
M:F5C=#T],RD-"@E[#0H)"5-P:&5R92YA;F=L97@@*ST@06QT97(N86YG;&5X
M.PT*"0E3<&AE<F4N86YG;&5Y("L]($%L=&5R+F%N9VQE>3L-"@D)4W!H97)E
M+F%N9VQE>B`K/2!!;'1E<BYA;F=L97H[#0H)"5-P:&5R92YP;W-X("L]($%L
M=&5R+G!O<W@[#0H)"5-P:&5R92YP;W-Y("L]($%L=&5R+G!O<WD[#0H)"5-P
M:&5R92YP;W-Z("L]($%L=&5R+G!O<WH[#0H-"@D)06QT97(N86YG;&5X(#T@
M,#L-"@D)06QT97(N86YG;&5Y(#T@,#L-"@D)06QT97(N86YG;&5Z(#T@,#L-
M"@D)06QT97(N<&]S>"`](#`[#0H)"4%L=&5R+G!O<WD@/2`P.PT*"0E!;'1E
M<BYP;W-Z(#T@,#L-"@E]#0H)9VQ4<F%N<VQA=&5F*%-P:&5R92YP;W-X+"!3
M<&AE<F4N<&]S>2P@4W!H97)E+G!O<WHI.PT*"6=L4F]T871E9BA3<&AE<F4N
M86YG;&5X+"`Q+"`P+"`P*3L-"@EG;%)O=&%T968H4W!H97)E+F%N9VQE>2P@
M,"P@,2P@,"D[#0H)9VQ2;W1A=&5F*%-P:&5R92YA;F=L97HL(#`L(#`L(#$I
M.PT*"6=L0V]L;W(S9B@P+C`L(#`N,"P@,2XP*3L-"@EG;'5T4V]L:613<&AE
M<F4H4W!H97)E+G-I>F4L(#(U+"`R-2D[#0H)9VQ0;W!-871R:7@H*3L-"@T*
M+R]D<F%W('1H92!T96%P;W0-"@EG;%!U<VA-871R:7@H*3L-"@EG;$1I<V%B
M;&4H1TQ?3$E'2%0Q*3L-"@EG;$5N86)L92A'3%],24=(5#`I.PT*"6EF*&]B
M:F5C=#T],BD-"@E[#0H)"51E87!O="YA;F=L97@@*ST@06QT97(N86YG;&5X
M.PT*"0E496%P;W0N86YG;&5Y("L]($%L=&5R+F%N9VQE>3L-"@D)5&5A<&]T
M+F%N9VQE>B`K/2!!;'1E<BYA;F=L97H[#0H)"51E87!O="YP;W-X("L]($%L
M=&5R+G!O<W@[#0H)"51E87!O="YP;W-Y("L]($%L=&5R+G!O<WD[#0H)"51E
M87!O="YP;W-Z("L]($%L=&5R+G!O<WH[#0H-"@D)06QT97(N86YG;&5X(#T@
M,#L-"@D)06QT97(N86YG;&5Y(#T@,#L-"@D)06QT97(N86YG;&5Z(#T@,#L-
M"@D)06QT97(N<&]S>"`](#`[#0H)"4%L=&5R+G!O<WD@/2`P.PT*"0E!;'1E
M<BYP;W-Z(#T@,#L-"@E]#0H)9VQ4<F%N<VQA=&5F*%1E87!O="YP;W-X+"!4
M96%P;W0N<&]S>2P@5&5A<&]T+G!O<WHI.PT*"6=L4F]T871E9BA496%P;W0N
M86YG;&5X+"`Q+"`P+"`P*3L-"@EG;%)O=&%T968H5&5A<&]T+F%N9VQE>2P@
M,"P@,2P@,"D[#0H)9VQ2;W1A=&5F*%1E87!O="YA;F=L97HL(#`L(#`L(#$I
M.PT*"6=L0V]L;W(T9B@Q+C`L(#$N,"P@,"XP+"`P+C4I.PT*#0H):68H=')A
M;G,I#0H)>PT*"0EG;$)L96YD1G5N8RA'3%]34D-?04Q02$$L($=,7T].15]-
M24Y54U]34D-?04Q02$$I.PT*"0EG;$5N86)L92A'3%]"3$5.1"D[#0H)?0T*
M#0H)9VQU=%-O;&ED5&5A<&]T*%1E87!O="YS:7IE*3L-"@T*"6EF*'1R86YS
M*0T*"0EG;$1I<V%B;&4H1TQ?0DQ%3D0I.PT*#0H)9VQ0;W!-871R:7@H*3L-
M"@T*"6=L=713=V%P0G5F9F5R<R@I.R`-"GT-"@T*=F]I9"!M>5)E<VAA<&4H
M:6YT('<L(&EN="!H*0T*>PT*"6=L5FEE=W!O<G0@*#`L(#`L('<L(&@I.PT*
M"6=L36%T<FEX36]D92A'3%]04D]*14-424].*3L-"@EG;$QO861)9&5N=&ET
M>2@I.PT*"6=L=5!E<G-P96-T:79E*#0U+C`L(#$N,"HH1TQF;&]A="EW+RA'
M3&9L;V%T*6@L(#$N,"P@,3`N,"D[#0H)9VQ4<F%N<VQA=&5F("@P+"`P+"`M
M-2D[#0H)9VQ-871R:7A-;V1E("A'3%]-3T1%3%9)15<I.PT*?0T*#0IV;VED
M($ME>2AU;G-I9VYE9"!C:&%R(&ME>2P@:6YT('@L(&EN="!Y*0T*>PT*("`@
M('-W:71C:"AK97DI#0H)>PT*"6-A<V4@)VHG.@T*"6-A<V4@)THG.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E
M<BYA;F=L97H@/2`P.PT*"0E!;'1E<BYP;W-X(#T@+2XU.PT*"0E!;'1E<BYP
M;W-Y(#T@,#L-"@D)06QT97(N<&]S>B`](#`[#0H)"6)R96%K.PT*#0H)8V%S
M92`G;"<Z#0H)8V%S92`G3"<Z#0H)"4%L=&5R+F%N9VQE>"`](#`[#0H)"4%L
M=&5R+F%N9VQE>2`](#`[#0H)"4%L=&5R+F%N9VQE>B`](#`[#0H)"4%L=&5R
M+G!O<W@@/2`N-3L-"@D)06QT97(N<&]S>2`](#`[#0H)"4%L=&5R+G!O<WH@
M/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)VDG.@T*"6-A<V4@)TDG.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E
M<BYA;F=L97H@/2`P.PT*"0E!;'1E<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S
M>2`]("XU.PT*"0E!;'1E<BYP;W-Z(#T@,#L-"@D)8G)E86L[#0H-"@EC87-E
M("=K)SH-"@EC87-E("=+)SH-"@D)06QT97(N86YG;&5X(#T@,#L-"@D)06QT
M97(N86YG;&5Y(#T@,#L-"@D)06QT97(N86YG;&5Z(#T@,#L-"@D)06QT97(N
M<&]S>"`](#`[#0H)"4%L=&5R+G!O<WD@/2`M+C4[#0H)"4%L=&5R+G!O<WH@
M/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)W4G.@T*"6-A<V4@)U4G.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E
M<BYA;F=L97H@/2`P.PT*"0E!;'1E<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S
M>2`](#`[#0H)"4%L=&5R+G!O<WH@/2`N-3L-"@D)8G)E86L[#0H-"@EC87-E
M("=O)SH-"@EC87-E("=/)SH-"@D)06QT97(N86YG;&5X(#T@,#L-"@D)06QT
M97(N86YG;&5Y(#T@,#L-"@D)06QT97(N86YG;&5Z(#T@,#L-"@D)06QT97(N
M<&]S>"`](#`[#0H)"4%L=&5R+G!O<WD@/2`P.PT*"0E!;'1E<BYP;W-Z(#T@
M+2XU.PT*"0EB<F5A:SL-"@T*"6-A<V4@)W,G.@T*"6-A<V4@)U,G.@T*"0E!
M;'1E<BYA;F=L97@@/2`Q,#L-"@D)06QT97(N86YG;&5Y(#T@,#L-"@D)06QT
M97(N86YG;&5Z(#T@,#L-"@D)06QT97(N<&]S>"`](#`[#0H)"4%L=&5R+G!O
M<WD@/2`P.PT*"0E!;'1E<BYP;W-Z(#T@,#L-"@D)8G)E86L[#0H-"@EC87-E
M("=F)SH-"@EC87-E("=&)SH-"@D)06QT97(N86YG;&5X(#T@+3$P.PT*"0E!
M;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E<BYA;F=L97H@/2`P.PT*"0E!;'1E
M<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S>2`](#`[#0H)"4%L=&5R+G!O<WH@
M/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)V4G.@T*"6-A<V4@)T4G.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`Q,#L-"@D)06QT
M97(N86YG;&5Z(#T@,#L-"@D)06QT97(N<&]S>"`](#`[#0H)"4%L=&5R+G!O
M<WD@/2`P.PT*"0E!;'1E<BYP;W-Z(#T@,#L-"@D)8G)E86L[#0H-"@EC87-E
M("=D)SH-"@EC87-E("=$)SH-"@D)06QT97(N86YG;&5X(#T@,#L-"@D)06QT
M97(N86YG;&5Y(#T@+3$P.PT*"0E!;'1E<BYA;F=L97H@/2`P.PT*"0E!;'1E
M<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S>2`](#`[#0H)"4%L=&5R+G!O<WH@
M/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)W<G.@T*"6-A<V4@)U<G.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E
M<BYA;F=L97H@/2`Q,#L-"@D)06QT97(N<&]S>"`](#`[#0H)"4%L=&5R+G!O
M<WD@/2`P.PT*"0E!;'1E<BYP;W-Z(#T@,#L-"@D)8G)E86L[#0H-"@EC87-E
M("=R)SH-"@EC87-E("=2)SH-"@D)06QT97(N86YG;&5X(#T@,#L-"@D)06QT
M97(N86YG;&5Y(#T@,#L-"@D)06QT97(N86YG;&5Z(#T@+3$P.PT*"0E!;'1E
M<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S>2`](#`[#0H)"4%L=&5R+G!O<WH@
M/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)RPG.@T*"6-A<V4@)SPG.@T*"0ES
M=VET8V@H;V)J96-T*0T*"0E[#0H)"6-A<V4@,3H-"@D)"4-U8F4N<VEZ92`M
M/2`P+C$[#0H)"0EB<F5A:SL-"@T*"0EC87-E(#(Z#0H)"0E496%P;W0N<VEZ
M92`M/2`P+C$[#0H)"0EB<F5A:SL-"@T*"0EC87-E(#,Z#0H)"0E3<&AE<F4N
M<VEZ92`M/2`P+C$[#0H)"0EB<F5A:SL-"@D)?0T*"0E!;'1E<BYA;F=L97@@
M/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E<BYA;F=L97H@/2`P
M.PT*"0E!;'1E<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S>2`](#`[#0H)"4%L
M=&5R+G!O<WH@/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@)RXG.@T*"6-A<V4@
M)SXG.@T*"0ES=VET8V@H;V)J96-T*0T*"0E[#0H)"6-A<V4@,3H-"@D)"4-U
M8F4N<VEZ92`K/2`P+C$[#0H)"0EB<F5A:SL-"@T*"0EC87-E(#(Z#0H)"0E4
M96%P;W0N<VEZ92`K/2`P+C$[#0H)"0EB<F5A:SL-"@T*"0EC87-E(#,Z#0H)
M"0E3<&AE<F4N<VEZ92`K/2`P+C$[#0H)"0EB<F5A:SL-"@D)?0T*"0E!;'1E
M<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E<BYA
M;F=L97H@/2`P.PT*"0E!;'1E<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S>2`]
M(#`[#0H)"4%L=&5R+G!O<WH@/2`P.PT*"0EB<F5A:SL-"@T*"6-A<V4@,C<Z
M#0H)"65X:70H,"D[#0H)"6)R96%K.PT*#0H)8V%S92`G="<Z#0H)8V%S92`G
M5"<Z#0H)"71R86YS(%X](#$[#0H)"4%L=&5R+F%N9VQE>"`](#`[#0H)"4%L
M=&5R+F%N9VQE>2`](#`[#0H)"4%L=&5R+F%N9VQE>B`](#`[#0H)"4%L=&5R
M+G!O<W@@/2`P.PT*"0E!;'1E<BYP;W-Y(#T@,#L-"@D)06QT97(N<&]S>B`]
M(#`[#0H)"6)R96%K.PT*#0H)8V%S92`G8B<Z#0H)8V%S92`G0B<Z#0H)"6EF
M*&)U9CT],BD-"@D)>PT*"0D)8G5F(#T@,3L-"@D)"6=L=71(:61E5VEN9&]W
M*"D[#0H)"0EG;'5T1V5T5VEN9&]W*"D[#0H)"0EI;FET7W!A<F%M971E<G,H
M*3L-"@D)"6=L4VAA9&5-;V1E;"A'3%]&3$%4*3L-"@D)"6=L=71);FET1&ES
M<&QA>4UO9&4H1TQ55%]324Y'3$5\1TQ55%]21T)!*3L-"@D)"6=L=71);FET
M5VEN9&]W4VEZ92@S,#`L(#(P,"D[#0H)"0EG;'5T26YI=%=I;F1O=U!O<VET
M:6]N*#$P,"P@,3`P*3L-"@D)"6=L=71#<F5A=&57:6YD;W<H(DAO;65W;W)K
M(#$B*3L-"@D)"6=L=71+97EB;V%R9$9U;F,H2V5Y*3L-"@D)"6=L=71297-H
M87!E1G5N8RAM>5)E<VAA<&4I.PT*"0D)9VQU=$1I<W!L87E&=6YC*&1I<W!L
M87DI.PT*"0D)9VQ%;F%B;&4H1TQ?1$505$A?5$535"D[#0H)"0EG;'5T4&]S
M=%)E9&ES<&QA>2@I.PT*"0D)9VQU=$-R96%T94UE;G4H4V5L96-T*3L-"@D)
M"6=L=71!9&1-96YU16YT<GDH(D-A;65R82(L(#$I.PT*"0D)9VQU=$%D9$UE
M;G5%;G1R>2@B0W5B92(L(#(I.PT*"0D)9VQU=$%D9$UE;G5%;G1R>2@B5&5A
M<&]T(BP@,RD[#0H)"0EG;'5T061D365N=45N=')Y*")3<&AE<F4B+"`T*3L-
M"@D)"6=L=71!9&1-96YU16YT<GDH(E%U:70B+"`P*3L-"@D)"6=L=71!='1A
M8VA-96YU*$=,551?4DE'2%1?0E545$].*3L-"@D)"6=L=71-86EN3&]O<"@I
M.PT*"0E]#0H)"65L<V4-"@D)>PT*"0D)8G5F(#T@,CL-"@D)"6=L=71(:61E
M5VEN9&]W*"D[#0H)"0EG;'5T1V5T5VEN9&]W*"D[#0H)"0EI;FET7W!A<F%M
M971E<G,H*3L-"@D)"6=L4VAA9&5-;V1E;"A'3%]&3$%4*3L-"@D)"6=L=71)
M;FET1&ES<&QA>4UO9&4H1TQ55%]$3U5"3$5\1TQ55%]21T)!*3L-"@D)"6=L
M=71);FET5VEN9&]W4VEZ92@S,#`L(#(P,"D[#0H)"0EG;'5T26YI=%=I;F1O
M=U!O<VET:6]N*#$P,"P@,3`P*3L-"@D)"6=L=71#<F5A=&57:6YD;W<H(DAO
M;65W;W)K(#$B*3L-"@D)"6=L=71+97EB;V%R9$9U;F,H2V5Y*3L-"@D)"6=L
M=71297-H87!E1G5N8RAM>5)E<VAA<&4I.PT*"0D)9VQU=$1I<W!L87E&=6YC
M*&1I<W!L87DI.PT*"0D)9VQ%;F%B;&4H1TQ?1$505$A?5$535"D[#0H)"0EG
M;'5T4&]S=%)E9&ES<&QA>2@I.PT*"0D)9VQU=$-R96%T94UE;G4H4V5L96-T
M*3L-"@D)"6=L=71!9&1-96YU16YT<GDH(D-A;65R82(L(#$I.PT*"0D)9VQU
M=$%D9$UE;G5%;G1R>2@B0W5B92(L(#(I.PT*"0D)9VQU=$%D9$UE;G5%;G1R
M>2@B5&5A<&]T(BP@,RD[#0H)"0EG;'5T061D365N=45N=')Y*")3<&AE<F4B
M+"`T*3L-"@D)"6=L=71!9&1-96YU16YT<GDH(E%U:70B+"`P*3L-"@D)"6=L
M=71!='1A8VA-96YU*$=,551?4DE'2%1?0E545$].*3L-"@D)"6=L=71-86EN
M3&]O<"@I.PT*"0E]"0D-"@D)8G)E86L[#0H-"B`@("!D969A=6QT.@T*"0E!
M;'1E<BYA;F=L97@@/2`P.PT*"0E!;'1E<BYA;F=L97D@/2`P.PT*"0E!;'1E
M<BYA;F=L97H@/2`P.PT*"0E!;'1E<BYP;W-X(#T@,#L-"@D)06QT97(N<&]S
M>2`](#`[#0H)"4%L=&5R+G!O<WH@/2`P.PT*("`@("`@8G)E86L[#0H@("`@
M?0T*#0H)9VQU=%!O<W12961I<W!L87DH*3L-"GT-"@T*=F]I9"!396QE8W0H
M:6YT('9A;'5E*0T*>PT*"7-W:71C:"AV86QU92D-"@E[#0H@("`@8V%S92`P
M.@T*("`@("`@("!E>&ET*#`I.PT*("`@("`@("!B<F5A:SL-"@T*"6-A<V4@
M,3H-"@D);V)J96-T(#T@,#L-"@D)8G)E86L[#0H-"@EC87-E(#(Z#0H)"6]B
M:F5C="`](#$[#0H)"6)R96%K.PT*#0H)8V%S92`S.@T*"0EO8FIE8W0@/2`R
M.PT*"0EB<F5A:SL-"@T*"6-A<V4@-#H-"@D);V)J96-T(#T@,SL-"@D)8G)E
M86L[#0H-"@ED969A=6QT.@T*"0EB<F5A:SL-"B`@("!]#0I]#0H-"FEN="!M
M86EN*&EN="!A<F=C+"!C:&%R*BH@87)G=BD@#0I[#0H)8G5F(#T@,CL-"@EI
M;FET7W!A<F%M971E<G,H*3L-"@EG;%-H861E36]D96PH1TQ?1DQ!5"D[#0H)
M9VQU=$EN:70H)F%R9V,L(&%R9W8I.PT*"6=L=71);FET1&ES<&QA>4UO9&4H
M1TQ55%]$3U5"3$5\1TQ55%]21T)!*3L-"@EG;'5T26YI=%=I;F1O=U-I>F4H
M,S`P+"`R,#`I.PT*"6=L=71);FET5VEN9&]W4&]S:71I;VXH,3`P+"`Q,#`I
M.PT*"6=L=71#<F5A=&57:6YD;W<H(DAO;65W;W)K(#$B*3L-"@EG;'5T2V5Y
M8F]A<F1&=6YC*$ME>2D[#0H)9VQU=%)E<VAA<&5&=6YC*&UY4F5S:&%P92D[
M#0H)9VQU=$1I<W!L87E&=6YC*&1I<W!L87DI.PT*"6=L16YA8FQE*$=,7T1%
M4%1(7U1%4U0I.PT*"61I<W!L87E?:6YS=')U8W1I;VYS*"D[#0H)9VQU=%!O
M<W12961I<W!L87DH*3L-"@EG;'5T0W)E871E365N=2A396QE8W0I.PT*"6=L
M=71!9&1-96YU16YT<GDH(D-A;65R82(L(#$I.PT*"6=L=71!9&1-96YU16YT
M<GDH(D-U8F4B+"`R*3L-"@EG;'5T061D365N=45N=')Y*")496%P;W0B+"`S
M*3L-"@EG;'5T061D365N=45N=')Y*")3<&AE<F4B+"`T*3L-"@EG;'5T061D
M365N=45N=')Y*")1=6ET(BP@,"D[#0H)9VQU=$%T=&%C:$UE;G4H1TQ55%]2
D24=(5%]"55143TXI.PT*"6=L=71-86EN3&]O<"@I.PT*?0T*
`
end
SHAR_EOF
  $shar_touch -am 0206180997 'hw1.c' &&
  chmod 0664 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
32647473fd460bac75fbc4d254add73a  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 11196 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '11196,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh85929
exit 0

From ???@??? Fri Feb 07 07:34:29 1997
Received: from vcmr-13.rcs.rpi.edu (tehrani@vcmr-13.rcs.rpi.edu [128.113.113.34])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id AAA19336
	for <citrit@rpi.edu>; Fri, 7 Feb 1997 00:05:07 -0500
From: Mohammad Reza Taei Tehrani <tehrani>
Received: (tehrani@localhost) by vcmr-13.rcs.rpi.edu (SMI-8.6/8.6.4) id AAA20392 for citrit@rpi.edu; Fri, 7 Feb 1997 00:05:04 -0500
Date: Fri, 7 Feb 1997 00:05:04 -0500
Message-Id: <199702070505.AAA20392@vcmr-13.rcs.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: efbfa2c87c15a5e1a23a428082ba1863

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-07 00:03 EST by <tehrani@vcmr-13.rcs.rpi.edu>.
# Source directory was `/afs/rpi.edu/locker/68/000868/class/visual'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   8053 -rw-r--r-- hm1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh20133; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hm1.c ==============
if test -f 'hm1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hm1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hm1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hm1.c' &&
/*********************/
/* Homework Number 1 */
/* Mohammad Tehrani  */
/* tehrani@rpi.edu   */
/*********************/
X
/******************HELP***************************/
/*						 */
/* USE L, K, J, H  TO ROTATE THE CHOSEN OBJECT BY*/
/* USE <, > to SCALE  
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
#include  <stdio.h>
X
#define TEAPOT 1 
#define CUBE 2 
#define SPHERE 3
#define END 4
#define VIEW 5
X
X
X int object_rotate=0;
X int object_scale=0;
X int object_translate=0;
X
X float spin=0;
X float rx=0, ry=0, rz=0; /* for rotation */
X float sx=1, sy=1, sz=1; /* for scaling  */
X float tx=0, ty=0, tz=0; /* for translating */
X
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X      GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
X      GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 }; 
X      GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 }; 
X      GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 }; 
X      GLfloat mat_specular[] = { 0.6, 0.3, 0.6, 0.6 }; 
X      GLfloat no_shininess[] = { 0.0 }; 
X      GLfloat low_shininess[] = { 5.0 }; 
X      GLfloat high_shininess[] = { 160.0 }; 
X      GLfloat mat_emission[] = {0.3, 0.8, 0.2, 0.0};  
X
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X      glPushMatrix();
X      glScalef (0.3,0.3,0.3);
X
X      glEnable(GL_COLOR_MATERIAL);
X	
X      glPushMatrix();
X      glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X      glColor3f(1.0, 1.0, 0.0);
X      glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
X      glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X      glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
X    if(object_scale==TEAPOT)
X	{
X      glScalef(sx,sy,sz );
X	}
X    if(object_translate==TEAPOT)
X	{
X      glTranslatef(tx,ty ,tz );
X	}
X      glTranslatef(-3,0 ,0 );
X    if(object_rotate==TEAPOT)
X	{
X      glRotatef(spin,rx,ry,rz);
X	}
X      glutSolidTeapot(1.0);   /*  draw the teapot  */
X      glPopMatrix();
X
X      glPushMatrix();
X      glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X      glColor3f(1.0, 0.0, 0.0);
X      glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
X      glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
X      glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
X    if(object_scale==CUBE)
X	{
X      glScalef(sx,sy,sz );
X	}
X    if(object_translate==CUBE)
X	{
X      glTranslatef(tx,ty ,tz );
X	}
X    if(object_rotate == CUBE)
X	{
X      glRotatef(spin,rx,ry,rz);
X	}
X      glTranslatef(0.0, 0.0, 0.0);
X      glutSolidCube(1.0);   /*  draw the cube       */
X      glPopMatrix();
X
X      glPushMatrix();
X      glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
X      glColor3f(0.0, 0.0, 1.0);
X      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X      glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
X    if(object_scale==SPHERE)
X	{
X      glScalef(sx,sy,sz );
X	}
X    if(object_translate==SPHERE)
X	{
X      glTranslatef(tx,ty,tz );
X	}
X    glTranslatef(3,0,0);
X    if(object_rotate==SPHERE)
X	{
X      glRotatef(spin,rx,ry,rz);
X	}
X      glutSolidSphere(1.0,50,50);   /*  draw the sphere     */
X      glPopMatrix();
X
X      glDisable(GL_COLOR_MATERIAL);
X      glPopMatrix();
X
X      glutSwapBuffers(); 
}
X
X
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':                	 /****  Rotate           ****/
X	spin+=10;
X	rx=0;
X	ry=1;
X	rz=0;
X	break;
X    case 'j':			 /****   Rotate           ****/
X	spin+=10;
X	rx=1;
X	ry=0;
X	rz=0;
X	break;
X    case 'k': 			 /****     Rotate         ****/
X	spin+=10;
X	rx=1;
X	ry=0;
X	rz=0;
X	break; 
X    case 'l':			 /****     Rotate         ****/
X	spin+=10;
X	rx=0;
X	ry=1;
X	rz=0;
X	break;
X    case '<':			 /****    Scale         ****/
X	sx/=1.2;
X	sy/=1.2;
X	sz/=1.2;
X	break;
X    case '>':			 /****      Scale         ****/
X	sx*=1.2;
X	sy*=1.2;
X	sz*=1.2;
X	break;
X    case 'm':			 /****   Translate          ****/
X	tx+=0.2;
X	ty+=0.2;
X	tz+=0.2;
X	break;
X    case 'n':			 /****    Translate           ****/
X	tx-=.2;
X	ty-=.2;
X	tz-=.2;
X	break;
X    case 27: 
X        exit(1);
X        break;
X    default:
X      break;
X
X    }
X   display(); 
}
X
X
X
X
X
X
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 2.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X      glClearColor (0.0, 0.0, 0.0, 0.0);
X
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case VIEW:
printf(" USE l,k,j,h to ROTATE the chosen object\n");
printf(" USE < , >   to SCALE  the chosen object\n");
printf(" USE  n, m   to TRANSLATE the chosen object\n");
X        break;
X
X    case END:
X        exit(0);
X        break;
X    }
}
X
void
Tranlate_select(int value)
{
X    switch (value) {
X    case TEAPOT:
X        object_translate=TEAPOT;
X        break;
X    case CUBE:
X        object_translate=CUBE;
X        break;
X    case SPHERE:
X        object_translate=SPHERE;
X        break;
X    }
}
X
void
Rotate_select(int value)
{
X    switch (value) {
X    case TEAPOT:
X        object_rotate=TEAPOT;
X        break;
X    case CUBE:
X        object_rotate=CUBE;
X        break;
X    case SPHERE:
X        object_rotate=SPHERE;
X        break;
X    }
}
X
void
Scale_select(int value)
{
X    switch (value) {
X    case TEAPOT:
X        object_scale=TEAPOT;
X        break;
X    case CUBE:
X        object_scale=CUBE;
X        break;
X    case SPHERE:
X        object_scale=SPHERE;
X        break;
X
X    }
}
X
X
X
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
int rotate_menu, scale_menu, translate_menu;
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowPosition(500, 500);
X      glutInitWindowSize(500, 500);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X
X      rotate_menu=glutCreateMenu(Rotate_select);
X      glutAddMenuEntry("Teapot",TEAPOT);
X      glutAddMenuEntry("Cube",  CUBE);
X      glutAddMenuEntry("Sphere", SPHERE);
X
X      translate_menu=glutCreateMenu(Tranlate_select);
X      glutAddMenuEntry("Teapot",TEAPOT);
X      glutAddMenuEntry("Cube",  CUBE);
X      glutAddMenuEntry("Sphere", SPHERE);
X
X
X      scale_menu=glutCreateMenu(Scale_select);
X      glutAddMenuEntry("Teapot", TEAPOT);
X      glutAddMenuEntry("Cube", CUBE);
X      glutAddMenuEntry("Sphere", SPHERE);
X
X      glutCreateMenu(Select);
X      glutAddSubMenu("Rotate", rotate_menu);
X      glutAddSubMenu("Translate", translate_menu);
X      glutAddSubMenu("Scale", scale_menu);
X      glutAddMenuEntry("HELP", VIEW);
X      glutAddMenuEntry("Quit", END);
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206235897 'hm1.c' &&
  chmod 0644 'hm1.c' ||
  $echo 'restore of' 'hm1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hm1.c:' 'MD5 check failed'
d86fc09f3e2b56e363965ed56dd89bd6  hm1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hm1.c'`"
    test 8053 -eq "$shar_count" ||
    $echo 'hm1.c:' 'original size' '8053,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh20133
exit 0

From ???@??? Thu Feb 06 11:38:48 1997
Received: from cs.rpi.edu (root@cs.rpi.edu [128.213.1.1])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id LAA36644
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 11:37:18 -0500
Received: from icemaker.cs.rpi.edu (kramer2@icemaker.cs.rpi.edu [128.213.2.53])
	by cs.rpi.edu (8.8.5/8.8.5) with ESMTP id LAA13507
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 11:37:13 -0500 (EST)
From: Richard Kramer <kramer2@cs.rpi.edu>
Received: (from kramer2@localhost)
	by icemaker.cs.rpi.edu (8.8.5/8.8.5) id LAA21032
	for citrit@rpi.edu; Thu, 6 Feb 1997 11:37:13 -0500 (EST)
Date: Thu, 6 Feb 1997 11:37:13 -0500 (EST)
Message-Id: <199702061637.LAA21032@icemaker.cs.rpi.edu>
Content-Type: text
To: undisclosed-recipients:;
X-UIDL: 314281a04816d5467aff16aa7ba164eb

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  hw1.c
# Wrapped by kramer2@icemaker.cs.rpi.edu on Thu Feb  6 11:36:55 1997
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive."'
if test -f 'hw1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hw1.c'\"
else
  echo shar: Extracting \"'hw1.c'\" \(7181 characters\)
  sed "s/^X//" >'hw1.c' <<'END_OF_FILE'
X/**
X * Homework 1
X */
X
X/* Includes required */
X#include <GL/gl.h>
X#include <GL/glut.h>
X#include <stdio.h>
X/**
X * something because of windows
X */
Xvoid __eprintf() {
X}
X
X/**
X * our data structure of choice
X */
Xtypedef struct obj {
X    /* translation in x, y, z */
X    float tx, ty, tz;
X
X    /* rotation in x, y, z */
X    float rx, ry, rz;
X
X    /* uniform scaling */
X    float scale;
X
X    /* ambient & diffuse color */
X    float color[4];
X
X    /* display list to draw the thing */
X    int list;
X} Obj;
X
X/**
X * our global variables
X */
XObj scene;
XObj cube;
XObj sphere;
XObj teapot;
XObj* current; 
X
X/**
X * this will initialize the display lists for the objects
X */
Xvoid initialize_objects() {
X    float tmp[4];
X
X    /* scene */
X    scene.tx = scene.ty = scene.tz = 0.0;
X    scene.rx = scene.ry = scene.rz = 0.0;
X    scene.scale = 1.0;
X    
X    /* first the cube */
X    current = &cube;
X    cube.tx = cube.ty = cube.tz = 0.0;
X    cube.rx = cube.ry = cube.rz = 0.0;
X    cube.color[0] = 0.8;
X    cube.color[1] = 0.0;
X    cube.color[2] = 0.0;
X    cube.color[3] = 1.0;
X    cube.scale = 1.0;
X    cube.list = 1;
X    glNewList(1, GL_COMPILE);
X    tmp[0] = 1.0;
X    tmp[1] = 1.0;
X    tmp[2] = 1.0;
X    tmp[3] = 1.0;
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, tmp);
X    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 10.0);
X    glutSolidCube(1.0);
X    glEndList();
X
X    /* then the sphere */
X    sphere.tx = 2.0;
X    sphere.ty = sphere.tz = 0.0;
X    sphere.rx = sphere.ry = sphere.rz = 0.0;
X    sphere.color[0] = 0.0;
X    sphere.color[1] = 0.0;
X    sphere.color[2] = 0.8;
X    sphere.color[3] = 1.0;
X    sphere.scale = 1.0;
X    sphere.list = 2;
X    glNewList(2, GL_COMPILE);
X    tmp[0] = 0.0;
X    tmp[1] = 0.0;
X    tmp[2] = 0.0;
X    tmp[3] = 1.0;
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, tmp);
X    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0);
X    glutSolidSphere(1.0, 10, 10);
X
X    glEndList();
X
X    /* and the teapot */
X    teapot.tx = -2.0;
X    teapot.ty = teapot.tz = 0.0;
X    teapot.rx = teapot.ry = teapot.rz = 0.0;
X    teapot.color[0] = 0.8;
X    teapot.color[1] = 0.8;
X    teapot.color[2] = 0.0;
X    teapot.color[3] = 0.3;
X    teapot.scale = 1.0;
X    teapot.list = 3;
X    glNewList(3, GL_COMPILE);
X    glEnable(GL_BLEND);
X    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, tmp);
X    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0); 
X    glutSolidTeapot(.75);
X    glDisable(GL_BLEND);
X    glEndList();;
X}
X
X/**
X * draw an object
X */
Xvoid drawObject(Obj* obj) {
X    float tmp[4];
X    glPushMatrix();
X    glTranslatef(obj->tx, obj->ty, obj->tz);
X    glRotatef(obj->rx, 1.0, 0.0, 0.0);
X    glRotatef(obj->ry, 0.0, 1.0, 0.0);
X    glRotatef(obj->rz, 0.0, 0.0, 1.0);
X    glScalef(obj->scale, obj->scale, obj->scale);
X    if (obj == current) {
X	tmp[0] = obj->color[0] + 0.2;
X	tmp[1] = obj->color[1] + 0.2;
X	tmp[2] = obj->color[2] + 0.2;
X	tmp[3] = obj->color[3]; 
X	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, tmp); 
X    } else {
X	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, obj->color);
X    }
X    glCallList(obj->list);
X    glPopMatrix();
X}
X
X/*
X *  Clear the screen. draw the objects
X */
Xvoid display()
X{
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X    /* adjust for scene orientation */
X    glMatrixMode(GL_PROJECTION);
X    glPushMatrix();
X    glTranslatef(scene.tx, scene.ty, scene.tz);
X    glRotatef(scene.rx, 1.0, 0.0, 0.0);
X    glRotatef(scene.ry, 0.0, 1.0, 0.0);
X    glRotatef(scene.rz, 0.0, 0.0, 1.0);
X    glScalef(scene.scale, scene.scale, scene.scale);
X    glMatrixMode(GL_MODELVIEW);
X
X    /* draw our three objects */
X    drawObject(&cube);
X    drawObject(&sphere);
X    drawObject(&teapot);
X
X    glMatrixMode(GL_PROJECTION);
X    glPopMatrix();
X    glutSwapBuffers();
X}
X
X/*
X *  Handle Menus
X */
X#define M_QUIT 1
X#define M_CUBE 2
X#define M_SPHERE 3
X#define M_TEAPOT 4
X#define M_SCENE 5
Xvoid Select(int value)
X{
X    switch (value) {
X    case M_SCENE:
X	current = &scene;
X	break;
X    case M_CUBE:
X	current = &cube;
X	break;
X    case M_SPHERE:
X	current = &sphere;
X	break;
X    case M_TEAPOT:
X	current = &teapot;
X	break;
X    case M_QUIT:
X        exit(0);
X        break;
X    }
X    glutPostRedisplay();
X}
Xvoid create_menu() {
X    fprintf(stderr, "Press ? for help\n");
X    glutCreateMenu(Select);
X    glutAddMenuEntry("Scene", M_SCENE);
X    glutAddMenuEntry("Cube", M_CUBE);
X    glutAddMenuEntry("Sphere", M_SPHERE);
X    glutAddMenuEntry("Teapot", M_TEAPOT);
X    glutAddMenuEntry("Quit", M_QUIT);
X    glutAttachMenu(GLUT_RIGHT_BUTTON);
X}
X
X
X/* Initialize shading model */
Xvoid myInit(void)
X{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.4, 0.4, 0.4, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.8, 0.8, 0.8, 1.0};
X
X      glColor3f(1.0, 0.0, 0.0);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DEPTH_TEST);
X/*      glShadeModel(GL_FLAT);*/
X}
X
X/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
Xvoid myReshape(int w, int h)
X{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 20.0);
X      glTranslatef (0.0, 0.0, -10.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
X}
X
X/*
X * Keyboard handler
X */
Xvoid
XKey(unsigned char key, int x, int y)
X{
X    switch (key) {
X    case 'h':
X	current->ry += 15.0;
X	break;
X    case 'j':
X	current->rx += 15.0;
X	break;
X    case 'k':
X	current->rx -= 15.0;
X	break;
X    case 'l':
X	current->ry -= 15.0;
X	break;
X    case 's':
X	current->scale *= .9;
X	break;
X    case 'S':
X	current->scale *= 1.1;
X	break;
X    case 9:
X	if (current == &scene) {
X	    current = &cube;
X	} else if (current == &cube) {
X	    current = &sphere;
X	} else if (current == &sphere) {
X	    current = &teapot;
X	} else {
X	    current = &scene;
X	}
X	break;
X    case '?':
X	fprintf(stderr, "Right Button Menu or Tab selects object\n");
X	fprintf(stderr, "hjkl - rotate current object\n");
X	fprintf(stderr, "s/S - shrink / grow the object or zoom the scene\n\n");
X	fprintf(stderr, "Escape quits \n\n");
X	break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X/*	fprintf(stderr, "Unbound key - %d\n", key); */
X	break;
X    }
X    glutPostRedisplay();
X}
X
X/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
Xint main(int argc, char** argv) 
X{
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X      create_menu(); 
X      initialize_objects();  
X      glutMainLoop();
X}
END_OF_FILE
  if test 7181 -ne `wc -c <'hw1.c'`; then
    echo shar: \"'hw1.c'\" unpacked with wrong size!
  fi
  # end of 'hw1.c'
fi
echo shar: End of archive.
exit 0


From ???@??? Fri Feb 07 07:33:21 1997
Received: from rebecca.its.rpi.edu (andret@rebecca.its.rpi.edu [128.113.113.14])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id TAA37460
	for <citrit@rpi.edu>; Thu, 6 Feb 1997 19:06:42 -0500
From: Thayer Andrews <andret>
Received: (andret@localhost) by rebecca.its.rpi.edu (SMI-8.6/8.6.4) id TAA25360 for citrit@rpi.edu; Thu, 6 Feb 1997 19:06:38 -0500
Date: Thu, 6 Feb 1997 19:06:38 -0500
Message-Id: <199702070006.TAA25360@rebecca.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: b882531dcf058bee70bd379f932e30ff

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:04 EST by <andret@rebecca.its.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/70/andret/agfx'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  14578 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh25285; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X * FILE: hw1.c
X * AUTHOR: Thayer Andrews
X * DATE: February 6, 1997
X *
X * Advanced Graphics homework 1
X * 
X */
X
#include <stdlib.h>
X
#ifdef _WIN32
#include <windows.h>
#endif
X
#include <GL/gl.h>
#include <GL/glut.h>
#include <math.h>
X
#define TRUE                1
#define FALSE               0
X
/*transformation increments used by the mouseMove function
X  to transform the currently selected object*/
#define TRANSLATE_INCR      0.1
#define ROTATE_INCR         5
#define SCALE_INCR          0.95
X
/*possible menu selections*/
#define ROTATE_SPHERE       1
#define SCALE_SPHERE        2
#define TRANSLATE_SPHERE    3
#define ROTATE_CUBE         4 
#define SCALE_CUBE          5
#define TRANSLATE_CUBE      6
#define ROTATE_TEAPOT       7
#define SCALE_TEAPOT        8
#define TRANSLATE_TEAPOT    9
#define CAMERA	            10
#define TRANSPARENT_TEAPOT  11
#define TOGGLE_SPHERE       12
#define TOGGLE_CUBE         13
#define TOGGLE_TEAPOT       14
#define QUIT                666
X
X
/*
X * object information structure containing all information
X * about an object's position, size, orientation and material.
X */
typedef struct _objectInfo
{
X  /*specify object position*/
X  GLfloat xPos;
X  GLfloat yPos;
X  GLfloat zPos;
X  
X  /*specify object orientation (in degrees)*/
X  GLfloat xAngle;
X  GLfloat yAngle;
X  GLfloat zAngle;
X  
X  /*specify object scale factors*/
X  GLfloat xScale;
X  GLfloat yScale;
X  GLfloat zScale;
X
X  /*float arrays to store material properties*/
X  GLfloat diffuse[4];
X  GLfloat ambient[4];
X  GLfloat specular[4];
X  GLfloat shininess[1];
X
} objectInfo;
X
X
/*Create global state structs for the cube, sphere, teapot and camera*/
objectInfo cubeInfo, sphereInfo, potInfo, cameraInfo;
X
/*more globals...*/
int selected = CAMERA;
int transparentTeapot = FALSE, sphereHidden = FALSE,
X    cubeHidden = FALSE, teapotHidden = FALSE;
GLsizei windowWidth, windowHeight;
X
X
/*
X * display function is responsible for translating geometry and drawing
X * it to the screen.
X */
void display(void)
{   
X  /*enable face culling to speed performance*/
X  glEnable(GL_CULL_FACE);
X  glCullFace(GL_BACK);
X  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X
X  /*Camera transformations*/
X  glMatrixMode(GL_PROJECTION);
X  glLoadIdentity();
X  gluPerspective(45.0,1.0*(GLfloat)windowWidth/(GLfloat)windowHeight,1.0,10.0);
X  glTranslatef(cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos);
X  glRotatef(cameraInfo.xAngle,1.0,0.0,0.0);
X  glRotatef(cameraInfo.yAngle,0.0,1.0,0.0);
X  
X  /*From now on we play with the modelview matrix...*/
X  glMatrixMode(GL_MODELVIEW);
X  glLoadIdentity();
X
X  if(!cubeHidden)
X  {
X    glPushMatrix();
X      /*position, scale and orient the cube*/
X      glTranslatef(cubeInfo.xPos, cubeInfo.yPos, cubeInfo.zPos);
X      glScalef(cubeInfo.xScale, cubeInfo.xScale, cubeInfo.xScale);
X      glRotatef(cubeInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(cubeInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(cubeInfo.zAngle,0.0,0.0,1.0);
X    
X     /*set material properties for and draw the cube*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, cubeInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, cubeInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, cubeInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, cubeInfo.shininess);
X      glutSolidCube(1.0);
X      glPopMatrix();
X  }
X
X  if(!sphereHidden)
X  {
X    glPushMatrix();
X      /*position, scale and orient the sphere*/ 
X      glTranslatef(sphereInfo.xPos, sphereInfo.yPos, sphereInfo.zPos);
X      glScalef(sphereInfo.xScale, sphereInfo.xScale, sphereInfo.xScale);
X      glRotatef(sphereInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(sphereInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(sphereInfo.zAngle,0.0,0.0,1.0);
X    
X      /*set material properties for and draw the sphere*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, sphereInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, sphereInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, sphereInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, sphereInfo.shininess);
X      glutSolidSphere(0.5,10,10);
X    glPopMatrix();
X  }
X
X
X  if(!teapotHidden)
X  {
X    /*If transparency is enabled, enable blending and switch the 
X      z-buffer to read only mode to allow the teapot to be transparent.*/
X    if(transparentTeapot)
X    {
X      glEnable(GL_BLEND);
X      glDepthMask(GL_FALSE);
X      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X    }
X  
X    /*Switch off face culling for the teapot since the faces seem to be defined
X      backwards so front facing polygons are culled when glCullFace(GL_BACK) is
X      called.  Weird...*/
X    glDisable(GL_CULL_FACE);
X    
X    glPushMatrix();
X      /*position, scale and orient the teapot*/ 
X      glTranslatef(potInfo.xPos, potInfo.yPos, potInfo.zPos);
X      glScalef(potInfo.xScale, potInfo.xScale, potInfo.xScale);
X      glRotatef(potInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(potInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(potInfo.zAngle,0.0,0.0,1.0);
X    
X      /*set material properties for and draw the teapot*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, potInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, potInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, potInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, potInfo.shininess);
X      glutSolidTeapot(0.5);
X    glPopMatrix();
X
X    /*now turn off blending and switch z-buffer back to 
X      read/write mode and re-enable culling*/
X    glDepthMask(GL_TRUE); 
X    glDisable(GL_BLEND);
X    glEnable(GL_CULL_FACE);
X  }
X
X  /*force completion of drawing and swap front and back buffers*/
X  glFlush();
X  glutSwapBuffers ();
}
X
X
X
/*
X * initialize lights and object attributes
X */
void myinit (void)
{  
X  /*define light parameters*/
X  float light0Pos[4] = {2.0, 4.0, 2.0, 1.0};
X  float light0Dir[4] = {-2.0, -4.0, -2.0, 1.0};
X  float light0Amb[4] = {0.7, 0.7, 0.7, 1.0};
X  float light0Diff[4] = {0.8, 0.8, 0.8, 1.0};
X  float light0Spec[4] = {0.8, 0.8, 0.8, 1.0};
X
X  /*clear to black when glClear() is called*/
X  glClearColor (0.0, 0.0, 0.0, 1.0);
X  
X  /*enable lighting and set GL_LIGHT0 params to defined values*/
X  glEnable(GL_LIGHTING);
X  glEnable(GL_LIGHT0);
X  glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
X  glLightfv(GL_LIGHT0, GL_AMBIENT, light0Amb);
X  glLightfv(GL_LIGHT0, GL_DIFFUSE, light0Diff);
X  glLightfv(GL_LIGHT0, GL_SPECULAR, light0Spec);
X
X  glEnable(GL_DEPTH_TEST);
X  glShadeModel(GL_SMOOTH);
X
X  /*set initial position and orientation for sphere*/
X  sphereInfo.xPos = 2.0; sphereInfo.yPos = 0.0; sphereInfo.zPos = 0.0;
X  sphereInfo.xAngle = 0.0; sphereInfo.yAngle = 0.0; sphereInfo.zAngle = 0.0;
X  sphereInfo.xScale = 1.0; sphereInfo.yScale = 1.0; sphereInfo.zScale = 1.0;
X
X  /*set material properties for the sphere*/
X  sphereInfo.diffuse[0] = 0.0; 
X  sphereInfo.diffuse[1] = 0.0; 
X  sphereInfo.diffuse[2] = 0.8; 
X  sphereInfo.diffuse[3] = 1.0;
X
X  sphereInfo.ambient[0] = 0.0;
X  sphereInfo.ambient[1] = 0.0;
X  sphereInfo.ambient[2] = 0.4;
X  sphereInfo.ambient[3] = 1.0;
X
X  sphereInfo.specular[0] = 0.0;
X  sphereInfo.specular[1] = 0.0;
X  sphereInfo.specular[2] = 0.3;
X  sphereInfo.specular[3] = 1.0;
X
X  sphereInfo.shininess[0] = 0.0;
X
X
X  /*set position and orientation of the cube*/
X  cubeInfo.xPos = 0.0; cubeInfo.yPos = 0.0; cubeInfo.zPos = 0.0;
X  cubeInfo.xAngle = 0.0; cubeInfo.yAngle = 0.0; cubeInfo.zAngle = 0.0;
X  cubeInfo.xScale = 1.0; cubeInfo.yScale = 1.0; cubeInfo.zScale = 1.0;
X
X  /*set material properties for the cube*/
X  cubeInfo.diffuse[0] = 0.8; 
X  cubeInfo.diffuse[1] = 0.0; 
X  cubeInfo.diffuse[2] = 0.0; 
X  cubeInfo.diffuse[3] = 1.0;
X
X  cubeInfo.ambient[0] = 0.4;
X  cubeInfo.ambient[1] = 0.0;
X  cubeInfo.ambient[2] = 0.0;
X  cubeInfo.ambient[3] = 1.0;
X
X  cubeInfo.specular[0] = 0.8;
X  cubeInfo.specular[1] = 0.8;
X  cubeInfo.specular[2] = 0.8;
X  cubeInfo.specular[3] = 1.0;
X
X  cubeInfo.shininess[0] = 100.0;
X
X  /*set position and orienation of the tea pot*/
X  potInfo.xPos = -2.0; potInfo.yPos = 0.0; potInfo.zPos = 0.0;
X  potInfo.xAngle = 0.0; potInfo.yAngle = 0.0; potInfo.zAngle = 0.0;
X  potInfo.xScale = 1.0; potInfo.yScale = 1.0; potInfo.zScale = 1.0;
X
X  /*set material properties for the cube*/
X  potInfo.diffuse[0] = 0.8; 
X  potInfo.diffuse[1] = 0.8; 
X  potInfo.diffuse[2] = 0.0; 
X  potInfo.diffuse[3] = 0.6;
X
X  potInfo.ambient[0] = 0.4;
X  potInfo.ambient[1] = 0.4;
X  potInfo.ambient[2] = 0.0;
X  potInfo.ambient[3] = 0.6;
X
X  potInfo.specular[0] = 0.3;
X  potInfo.specular[1] = 0.3;
X  potInfo.specular[2] = 0.0;
X  potInfo.specular[3] = 0.6;
X
X  potInfo.shininess[0] = 100.0;
X
X  /*set position and orientation of the camera*/
X  cameraInfo.xPos = 0.0; cameraInfo.yPos = 0.0; cameraInfo.zPos = -8.0;
X  cameraInfo.xAngle = 0.0; cameraInfo.yAngle = 0.0; cameraInfo.zAngle = 0.0;
X  cameraInfo.xScale = 1.0; cameraInfo.yScale = 1.0; cameraInfo.zScale = 1.0;
}
X
X
/*
X * handle window resize and expose events
X */
void myReshape(GLsizei w, GLsizei h)
{
X  /*save the window size in these globals for use
X    in the display function*/
X  windowWidth = w; 
X  windowHeight = h;
X  
X  glViewport(0, 0, w, h);
X  glMatrixMode(GL_PROJECTION);
X  glLoadIdentity();
X  gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X  glTranslatef(cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos);
X  glRotatef(cameraInfo.xAngle,1.0,0.0,0.0);
X  glRotatef(cameraInfo.yAngle,0.0,1.0,0.0);
X  glMatrixMode(GL_MODELVIEW);
X  glLoadIdentity ();
}
X
X
/*
X * Handle pop-up menu events.  Perform transparency and hidden object
X * toggling directly otherwise just assign the input parameter to selected
X * and let the mouse movement callback handle rotation, scaling and 
X * translation.
X */
void
Select(int value)
{
X
X  /*exit when user selects quit*/
X  if(value == QUIT)
X    exit(0);
X  /*if user toggles transparency, invert current transparency state
X    and force redraw*/
X  else if(value == TRANSPARENT_TEAPOT)
X  {
X    if(transparentTeapot)
X      transparentTeapot = FALSE;
X    else 
X      transparentTeapot = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_SPHERE)
X  {
X    if(sphereHidden)
X      sphereHidden = FALSE;
X    else 
X      sphereHidden = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_CUBE)
X  {
X    if(cubeHidden)
X      cubeHidden= FALSE;
X    else 
X      cubeHidden = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_TEAPOT)
X  {
X    if(teapotHidden)
X      teapotHidden = FALSE;
X    else 
X      teapotHidden = TRUE;
X    glutPostRedisplay();
X  }
X  /*...otherwise, set selected global to menu option value*/
X  else
X    selected = value;
}
X
X
/*
X * keys function scales, rotates and translates the
X * currently selected object.
X */ 
void keys(unsigned char key, int x, int y)
{
X
X  GLint deltaX = 0, deltaY = 0;
X  
X  
X  switch(key)
X  {
X  case 'h':
X    deltaX = -1;
X    break;
X  case 'j':
X    deltaX = 1;
X    break;
X  case 'k':
X    deltaY = -1;
X    break;
X  case 'l':
X    deltaY = 1;
X    break;
X  }
X
X  /*as mouse movement callbacks are generated, switch based on the 
X    selected action and execute it*/
X  switch(selected) {
X  case ROTATE_SPHERE:
X    sphereInfo.yAngle += (deltaX*ROTATE_INCR);
X    sphereInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_SPHERE:
X    if(deltaX < 0)
X      sphereInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      sphereInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_SPHERE:
X    sphereInfo.xPos += (deltaX*TRANSLATE_INCR);
X    sphereInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X
X  case ROTATE_CUBE:
X    cubeInfo.yAngle += (deltaX*ROTATE_INCR);
X    cubeInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_CUBE:
X    if(deltaX < 0)
X      cubeInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      cubeInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_CUBE:
X    cubeInfo.xPos += (deltaX*TRANSLATE_INCR);
X    cubeInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X
X  case ROTATE_TEAPOT:
X    potInfo.yAngle += (deltaX*ROTATE_INCR);
X    potInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_TEAPOT:
X    if(deltaX < 0)
X      potInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      potInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_TEAPOT:
X    potInfo.xPos += (deltaX*TRANSLATE_INCR);
X    potInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X    
X  case CAMERA:
X    cameraInfo.yAngle += (deltaX*ROTATE_INCR);
X    cameraInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  }
X  
X  /*force redraw of buffers*/
X  glutPostRedisplay();
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv)
{
X  /*menu id's used below*/
X  int sphereMenu, cubeMenu, potMenu; 
X
X  glutInit(&argc, argv);
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X  glutInitWindowSize (500, 500);
X  glutCreateWindow (argv[0]);
X    
X
X  /*print help messages*/
X  printf("\n\nTo select an action use the right mouse button.\n");
X  printf("Keys:\n");
X  printf("h and j: Transform about/along x-axis\n");
X  printf("k and l: Transform about/along y-axis\n");
X
X  /*initialize stuff*/
X  myinit ();
X    
X  glutDisplayFunc(display);
X  glutReshapeFunc (myReshape);
X  glutIdleFunc (NULL);
X
X  /*
X   * Setup a pop-up menu and bind it to the right
X   * mouse button.  Start by defining the sphere 
X   * submenu
X   */
X  sphereMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Sphere", TOGGLE_SPHERE);
X  glutAddMenuEntry("Rotate Sphere",ROTATE_SPHERE);
X  glutAddMenuEntry("Scale Sphere", SCALE_SPHERE);
X  glutAddMenuEntry("Translate Sphere", TRANSLATE_SPHERE);
X  /*...now define the cube submenu...*/
X  cubeMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Cube", TOGGLE_CUBE);
X  glutAddMenuEntry("Rotate Cube",ROTATE_CUBE);
X  glutAddMenuEntry("Scale Cube", SCALE_CUBE);
X  glutAddMenuEntry("Translate Cube", TRANSLATE_CUBE);
X  /*...now define the teapot submenu...*/
X  potMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Teapot", TOGGLE_TEAPOT);
X  glutAddMenuEntry("Rotate Teapot",ROTATE_TEAPOT);
X  glutAddMenuEntry("Scale Teapot", SCALE_TEAPOT);
X  glutAddMenuEntry("Translate Teapot", TRANSLATE_TEAPOT);
X  /*...now create the main pop-up menu and add the three
X    submenus to it*/
X  glutCreateMenu(Select);
X  glutAddSubMenu("Sphere",sphereMenu);
X  glutAddSubMenu("Cube", cubeMenu);
X  glutAddSubMenu("Teapot", potMenu);
X  /*...finally add two more entries to the main menu
X    and bind it to the right mouse button.*/
X  glutAddMenuEntry("Move Camera", CAMERA);
X  glutAddMenuEntry("Toggle Teapot Transparency", TRANSPARENT_TEAPOT);
X  glutAddMenuEntry("Quit", QUIT);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X  /*bind keyboard events to the keys() function*/
X  glutKeyboardFunc(keys);
X  
X  /*start the main loop*/
X  glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206190397 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
a3719fcf6744aef2acaa49124f27b2d8  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 14578 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '14578,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh25285
exit 0

From ???@??? Thu Feb 06 07:38:12 1997
Received: from chronos.stu.rpi.edu (normat@chronos.stu.rpi.edu [128.113.165.11])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id VAA53114
	for <citrit@rpi.edu>; Wed, 5 Feb 1997 21:34:10 -0500
Received: (from normat@localhost)
	by chronos.stu.rpi.edu (8.8.5/8.8.5) id VAA01388
	for citrit@rpi.edu; Wed, 5 Feb 1997 21:34:09 -0500
Date: Wed, 5 Feb 1997 21:34:09 -0500
From: Tim Norman <normat@chronos.stu.rpi.edu>
Message-Id: <199702060234.VAA01388@chronos.stu.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: 47f4ce5109de0543720d59b40b839055

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-05 21:33 EST by <normat@chronos.stu.rpi.edu>.
# Source directory was `/usr/home/normat/src/tim/datavis/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   8085 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh01382; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* hw1.c
X * Advanced Computer Graphics and Data Visualization
X * Homework #1
X * Tim Norman (normat@rpi.edu)
X * 1-29-97
X */
X
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glut.h>
X
/*
X * struct geometry
X *
X * define a data structure to hold the various state of each object
X */
struct geometry
{
X  GLfloat translate[3];
X  GLfloat xrotate, yrotate;
X  GLfloat size;
} master = { { 0.0, 0.0, 0.0 }, 0.0, 0.0, 0.8 },    /* master view */
X  cube = { { 0.0, 0.0, 0.0 }, 0.0, 0.0, 1.0 },      /* cube object */
X  sphere = { { 2.0, 0.0, 0.0 }, 0.0, 0.0, 1.0 },    /* sphere object */
X  teapot = { { -2.0, 0.0, 0.0 }, 0.0, 0.0, 0.5 };   /* teapot object */
X
/* create an array of objects so we can select them easily */
struct geometry *objects[4] = { &master, &cube, &sphere, &teapot };
X
/* pointer to the currently-selected object */
struct geometry *current;
X
/*
X * drawCube
X *
X * draw the cube in the picture
X */
void drawCube ()
{
X  static float ambient[4] = { 0.0, 0.0, 0.0, 1.0 };
X  static float diffuse[4] = { 1.0, 0.0, 0.0, 1.0 };
X  static float shininess[1] = { 100.0 };
X  static float specular[4] = {1.0, 1.0, 1.0, 1.0 };
X
X  /* set the cube's material properties */
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, shininess);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, ambient);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse);
X
X  /* set up the translation and rotation */
X  glMatrixMode (GL_MODELVIEW);
X  glTranslatef (cube.translate[0], cube.translate[1], cube.translate[2]);
X  glRotatef (cube.xrotate, 1.0, 0.0, 0.0);
X  glRotatef (cube.yrotate, 0.0, 1.0, 0.0);
X  glutSolidCube (cube.size);
}
X
/*
X * drawSphere
X *
X * draw the sphere in the picture
X */
void drawSphere ()
{
X  static float ambient[4] = { 0.0, 0.0, 0.0, 1.0 };
X  static float diffuse[4] = { 0.0, 0.0, 1.0, 1.0 };
X  static float shininess[1] = { 0.0 };
X  static float specular[4] = {1.0, 1.0, 1.0, 1.0 };
X
X  /* set up the sphere's material properties */
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, shininess);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, ambient);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse);
X
X  /* set up the translation and rotation */
X  glMatrixMode (GL_MODELVIEW);
X  glTranslatef (sphere.translate[0], sphere.translate[1], sphere.translate[2]);
X  glRotatef (sphere.xrotate, 1.0, 0.0, 0.0);
X  glRotatef (sphere.yrotate, 0.0, 1.0, 0.0);
X  glutSolidSphere (sphere.size, 20, 20);
}
X
/*
X * drawTeapot
X *
X * draw the teapot in the picture
X */
void drawTeapot ()
{
X  static float ambient[4] = { 0.0, 0.0, 0.0, 1.0 };
X  static float diffuse[4] = { 1.0, 1.0, 0.0, 1.0 };
X  static float shininess[1] = { 100.0 };
X  static float specular[4] = {1.0, 1.0, 1.0, 1.0 };
X
X  /* set up the teapot's properties */
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, shininess);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, ambient);
X  glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse);
X
X  /* set up the translation and rotation */
X  glMatrixMode (GL_MODELVIEW);
X  glTranslatef (teapot.translate[0], teapot.translate[1], teapot.translate[2]);
X  glRotatef (teapot.xrotate, 1.0, 0.0, 0.0);
X  glRotatef (teapot.yrotate, 0.0, 1.0, 0.0);
X  glutSolidTeapot (teapot.size);
}
X
/*
X * display
X *
X * display our graphics
X */
void display ()
{
X  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X  glMatrixMode (GL_MODELVIEW);
X
X  /* load our master transformations into the matrix */
X  glLoadIdentity ();
X  glRotatef (master.xrotate, 1.0, 0.0, 0.0);
X  glRotatef (master.yrotate, 0.0, 1.0, 0.0);
X  glScalef (master.size, master.size, master.size);
X  glTranslatef (master.translate[0], master.translate[1], master.translate[2]);
X
X  /* draw the objects in the scene */
X  glPushMatrix ();
X  drawCube ();
X  glPopMatrix ();
X
X  glPushMatrix ();
X  drawSphere ();
X  glPopMatrix ();
X
X  glPushMatrix ();
X  drawTeapot ();
X  glPopMatrix ();
X
X  /* display the next frame */
X  glutSwapBuffers ();
}
X
/*
X * init
X *
X * do our initialization
X */
void init ()
{
X  static float lightPos[4] = {0.0, 0.0, 4.0, 1.0};
X  static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X  static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X  static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X  
X  /* set up the lighting */
X  glColor3f(1.0, 0.0, 0.0);
X  glEnable(GL_LIGHTING);
X  glEnable(GL_LIGHT0);
X  glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X  glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X  glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X  glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X  glEnable(GL_DEPTH_TEST);
X
X  /* set up the shading model */
X  glShadeModel (GL_SMOOTH);
X
X  /* point 'current' to the default object - the master scene */
X  current = objects[0];
}
X
/*
X * keyboard
X *
X * handle keyboard presses
X */
void keyboard (unsigned char key, int x, int y)
{
X  switch (key)
X    {
X    case 'h':                              /* rotate on y-axis */
X      current->yrotate += 15.0;
X      if (current->yrotate > 360)
X	current->yrotate -= 360;
X      break;
X    case 'j':                              /* rotate on x-axis */
X      current->xrotate += 15.0;
X      if (current->xrotate > 360)
X	current->xrotate -= 360;
X      break;
X    case 'k':                              /* rotate on x-axis */
X      current->xrotate -= 15.0;
X      if (current->xrotate < 0)
X	current->xrotate += 360;
X      break;
X    case 'l':                              /* rotate on y-axis */
X      current->yrotate -= 15.0;
X      if (current->yrotate < 0)
X	current->yrotate += 360;
X      break;
X    case '+':                              /* increase size */
X      current->size += .10;
X      break;
X    case '-':                              /* decrease size */
X      current->size -= .10;
X      if (current->size < .10)
X	current->size = .10;
X      break;
X    case 'a':                              /* move left */
X      current->translate[0] -= .20;
X      break;
X    case 's':                              /* move right */
X      current->translate[0] += .20;
X      break;
X    case 'w':                              /* move up */
X      current->translate[1] -= .20;
X      break;
X    case 'z':                              /* move down */
X      current->translate[1] += .20;
X      break;
X    case 'e':                              /* move back */
X      current->translate[2] -= .20;
X      break;
X    case 'x':                              /* move forward */
X      current->translate[2] += .20;
X      break;
X    case 27:                               /* quit */
X      exit (1);
X      break;
X    }
X
X  glutPostRedisplay ();
}
X
/*
X * reshape
X *
X * called when the window is moved or resized
X */
void reshape (int w, int h)
{
X  glViewport (0, 0, w, h);
X  glMatrixMode (GL_PROJECTION);
X  glLoadIdentity ();
X  gluPerspective (45.0, 1.0 * (GLfloat)w / (GLfloat)h, 1.0, 10.0);
X  glTranslatef (0.0, 0.0, -6.0);
X  glMatrixMode (GL_MODELVIEW);
}
X
/*
X * menu
X *
X * handle menu selections
X */
void menu (int choice)
{
X  if (choice >= 0 && choice <= 3)
X    current = objects[choice];
}
X
void print_keys ()
{
X  printf ("Commands:\n\n"
X	  "h,l\tRotate selected object around y-axis\n"
X	  "j,k\tRotate selected object around x-axis\n"
X	  "+,-\tChange size of selected object\n"
X	  "a,s\tMove selected object along x-axis\n"
X	  "w,z\tMove selected object along y-axis\n"
X	  "e,x\tMove selected object along z-axis\n");
}
X
/*
X * main
X */
int main (int argc, char **argv)
{
X  /* display a usage screen */
X  print_keys ();
X
X  /* initialize everything */
X  glutInit (&argc, argv);
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
X  glutCreateWindow ("Homework 1");
X  glutDisplayFunc (display);
X  glutKeyboardFunc (keyboard);
X  glutReshapeFunc (reshape);
X  init ();
X
X  /* create our menu */
X  glutCreateMenu (menu);
X  glutAddMenuEntry ("Manipulate entire view", 0);
X  glutAddMenuEntry ("Manipulate cube", 1);
X  glutAddMenuEntry ("Manipulate sphere", 2);
X  glutAddMenuEntry ("Maniuplate teapot", 3);
X  glutAttachMenu (GLUT_RIGHT_BUTTON);
X
X  /* enter the application loop */
X  glutMainLoop ();
X  return 0;
}
SHAR_EOF
  $shar_touch -am 0205191197 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
a4c10450a3b33a6f25923e3bfffd3a60  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8085 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8085,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh01382
exit 0

From ???@??? Fri Feb 07 07:32:57 1997
Received: from cii3112-23.its.rpi.edu (cheny4@cii3112-23.its.rpi.edu [128.113.109.173])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id PAA55602
	for <citrit>; Thu, 6 Feb 1997 15:11:03 -0500
From: Yuping Chen <cheny4>
Received: (cheny4@localhost) by cii3112-23.its.rpi.edu (8.6.9/8.6.4) id PAA23490 for citrit; Thu, 6 Feb 1997 15:10:59 -0500
Date: Thu, 6 Feb 1997 15:10:59 -0500
Message-Id: <199702062010.PAA23490@cii3112-23.its.rpi.edu>
To: citrit
Subject: HomeWork 1
X-UIDL: ee8e8ebb4c29ff22234ce69e37020e37

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 15:10 EST by <cheny4@cii3112-23>.
# Source directory was `/afs/rpi.edu/home/04/cheny4/private/gnv/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   4665 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh13756; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *  hw1.c 
X *  Drawing 3 objects and rotate and zoom them seperately
X *
X *  By: Yuping Chen
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
struct act {
X  int	object;
X  int	pick;
X  int	rotate_x;
X  int	rotate_y;
X  int	zoom_in;
X  int	zoom_out;
} actions;
X
X
void drawCube(void) {
X     GLfloat mat_ambient[] = { 0.8, 0.1, 0.1, 1.0 };
X     GLfloat mat_diffuse[] = { 0.8, 0.1, 0.2, 1.0 };
X     GLfloat mat_specular[] = { 0.8, 0.1, 0.1, 0.1 }; 
X     GLfloat low_shininess[] = { 5.0 };
X
X     glTranslatef(0.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
X     glutSolidCube(1.0);        
}  
X
void drawSphere(void)  {
X     GLfloat mat_ambient[] = { 0.1, 0.1, 0.8, 1.0 };
X     GLfloat mat_diffuse[] = { 0.1, 0.1, 0.8, 1.0 };
X     GLfloat mat_specular[] = { 0.0, 0.0, 0.0, 0.1 }; 
X     GLfloat no_shininess[] = { 0.0 };
X
X     glTranslatef(2.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X     glutSolidSphere(0.7, 30, 30);        
}  
X
void drawTeapot(void) {
X     GLfloat mat_ambient[] = { 0.7, 0.7, 0.1, 1.0 };
X     GLfloat mat_diffuse[] = { 0.6, 0.6, 0.1, 1.0 };
X     GLfloat mat_specular[] = { 0.4, 0.4, 0.2, 0.1 }; 
X     GLfloat no_shininess[] = { 5.0 };
X
X     glTranslatef(-2.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X     glutWireTeapot(0.6);
}   
X     
void display(void)
{
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X     /* glInitMatrix();*/
X      glPushMatrix();
X      drawCube();
X      glPopMatrix();
X
X      glPushMatrix();
X      drawSphere();
X      glPopMatrix();
X
X      glPushMatrix();
X      drawTeapot();
X      glPopMatrix();      
X      glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X /*    glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 1.0,0.0,0.0);
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 0.0,1.0,0.0);
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X    case 2:
X    case 3:
X	/*pickGeom(value);*/
X    break;  
X    case 4:
X        exit(0);
X	break;
X      }
}
X
void addmenu(void)
{
X      glutAddMenuEntry("Quit", 1);
X      glutAddMenuEntry("Cube", 2);
X      glutAddMenuEntry("Sphere", 3);
X      glutAddMenuEntry("Teapot", 4);
}
X
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowPosition(20, 560);
X      glutInitWindowSize(600, 300);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutKeyboardFunc(Key);
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display); 
X      glutCreateMenu(Select); 
X      /*glutAddMenuEntry("Quit", 1);*/
X      addmenu ();
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
X      return 0;
}
X
SHAR_EOF
  $shar_touch -am 0206150997 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
9892f50c645acb7dc95104a728ba09fe  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 4665 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '4665,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh13756
exit 0

From ???@??? Fri Feb 07 09:03:15 1997
Received: from marcus.its.rpi.edu (wangc5@marcus.its.rpi.edu [128.113.113.16])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id IAA47698
	for <citrit@rpi.edu>; Fri, 7 Feb 1997 08:41:22 -0500
From: Chuo-Lung Wang <wangc5>
Received: (wangc5@localhost) by marcus.its.rpi.edu (8.6.9/8.6.4) id IAA27623 for citrit@rpi.edu; Fri, 7 Feb 1997 08:41:22 -0500
Date: Fri, 7 Feb 1997 08:41:22 -0500
Message-Id: <199702071341.IAA27623@marcus.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: a4953b393bc9b0032c4fbf547f4d65c4

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-07 08:40 EST by <wangc5@marcus>.
# Source directory was `/afs/rpi.edu/home/78/wangc5/HW'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    898 -rw------- Makefile
#   9605 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh50614; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lMesaaux -lMesatk -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=cc
X
TARGET = simple
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LDFLAGS)
X
lorenz:    lorenz.o
X	$(CC) $(CFLAGS) -o $@ $? $(LIBS)
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0206232997 'Makefile' &&
  chmod 0600 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
a911ac703d77657be3fecce582d7478a  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 898 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '898,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
#include <GL/gl.h>
#include <GL/glut.h>
#include <stdlib.h>
#include <GL/glut.h>
X
/*##############################################*/
/*###             Globle Variables           ###*/
/*##############################################*/
X  GLfloat i=1.0;
X  int win;
X  int group=0;
X  int obj1=0,obj2=0,obj3=0;
X  int r1,r2,r3,r4;
X  int trans=0;
X  int camera;
X  int buffer=1;
X  GLfloat view1=0.0,view2=0.0,view3=0.0;
X  GLfloat view4=0.0,view5=0.0,view6=0.0;
X  static GLfloat spin1 = 0.0, spin2 = 0.0, spin3 = 0.0, spin4 = 0.0;
X  int submenu;
X
/*##############################################*/
void 
myinit(void)
{
X    GLfloat light_ambient[]  = {0.1, 0.1, 0.1, 1.0};
X    GLfloat light_diffuse[]  = {0.5, 0.5, 0.5, 1.0};
X    GLfloat light_specular[] = {0.6, 0.6, 0.6, 1.0};
X    GLfloat light_position[] = {1.0, 1.0, 1.0, 0.0};
X
X    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
X    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
X    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
X    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
X    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X    glEnable(GL_LIGHT0);
X    glDepthFunc(GL_LESS);
X    glEnable(GL_DEPTH_TEST);
X    glEnable(GL_LIGHTING);
}
void 
display(void)
{
X    GLfloat y_ambient[]      = { 0.4, 0.4, 0.0, 1.0 };
X    GLfloat y_diffuse[]      = { 0.5, 0.5, 0.0, 1.0 }; 
X    GLfloat y_specular[]     = { 0.7, 0.7, 0.0, 1.0 }; 
X    GLfloat y_emission[]     = { 0.3, 0.3, 0.0, 1.0 }; 
X
X    GLfloat trans_diffuse[]      = { 0.8, 0.8, 0.0, 0.25 }; 
X
X    GLfloat r_ambient[]      = { 0.3, 0.0, 0.0, 1.0 };
X    GLfloat r_diffuse[]      = { 0.3, 0.0, 0.0, 1.0 }; 
X    GLfloat r_specular[]     = { 0.3, 0.0, 0.0, 1.0 }; 
X    GLfloat r_emission[]     = { 0.1, 0.0, 0.0, 0.0 }; 
X
X    GLfloat b_ambient[]      = { 0.0, 0.0, 0.5, 1.0 };
X    GLfloat b_diffuse[]      = { 0.0, 0.0, 0.3, 1.0 }; 
X    GLfloat b_specular[]     = { 0.0, 0.0, 0.1, 1.0 }; 
X    GLfloat b_emission[]     = { 0.0, 0.0, 0.1, 0.0 }; 
X 
X    GLfloat low_shininess[]    = { 0.0 }; 
X    GLfloat high_shininess[]   = { 110.0 }; 
X        
X    glEnable(GL_LIGHT0);
X    glEnable(GL_LIGHTING);
X    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X    if(camera){
X    glPushMatrix();
X    glMatrixMode(GL_PROJECTION);
X    glRotated(view1, 0.0, 0.0, 1.0);
X    glRotated(view2, 0.0, 1.0, 0.0);
X    glRotated(view3, 1.0, 0.0, 0.0);
X    glTranslated(-view4, -view5, -view6);
X    glPopMatrix();
X    glMatrixMode(GL_MODELVIEW);
X    }
X    
X    glPushMatrix();
X    if(group)glRotatef(spin1, spin2, spin3, spin4);
X    glScalef(0.4, 0.4, 0.4);
X    glPushMatrix();
X    glTranslatef(-4.0, 0.0, 0.0);
X    if(obj1)glScalef(i, i, i);
X    if(obj1)glRotatef(spin1, spin2, spin3, spin4);
X    if(trans==1){
X      glEnable(GL_BLEND);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, trans_diffuse);
X      glutSolidTeapot(1.0);
X      glDisable(GL_BLEND);     
X    }
X    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, y_ambient);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, y_diffuse);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, y_specular);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, high_shininess);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, y_emission);
X    glColor3f(1.0, 1.0, 0.0);
X    glutSolidTeapot(1.0);
X    glPopMatrix();
X    glPushMatrix();
X    glTranslatef(0.0, 0, 0.0);
X    if(obj2)glScalef(i, i, i);
X    if(obj2)glRotatef(spin1, spin2, spin3, spin4);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, r_ambient); 
X    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, r_diffuse);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, r_specular);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, low_shininess);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, r_emission);
X    glColor3f(1.0, 0.0, 0.0);
X    glutSolidCube(1.0);
X    glPopMatrix();
X    
X    
X    glPushMatrix();
X    glTranslatef(4.0, 0.0, 0.0);
X    if(obj3)glScalef(i, i, i);
X    if(obj3)glRotatef(spin1, spin2, spin3, spin4);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, b_ambient); 
X    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, b_diffuse);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, b_specular);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, low_shininess);
X    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, b_emission);
X    glColor3f(0.0, 0.0, 1.0);
X    glutSolidSphere(1,15,15);
X    glPopMatrix();
X    
X    glPopMatrix();
X    glutSwapBuffers();
X    glFlush();
}
X
void 
myReshape(int w, int h)
{
X    glViewport(0, 0, w, h);
X    glMatrixMode(GL_PROJECTION);
X    glLoadIdentity();
X    if (w <= h)
X        glOrtho(-2.5, 2.5, -2.5 * (GLfloat) h / (GLfloat) w,
X            2.5 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
X    else
X        glOrtho(-2.5 * (GLfloat) w / (GLfloat) h,
X            2.5 * (GLfloat) w / (GLfloat) h, -2.5, 2.5, -10.0, 10.0);
X    glMatrixMode(GL_MODELVIEW);
} 
void 
focus_object(int value)
{
X    switch (value) {
X    case 1:
X    obj1=1;
X    obj2=0;
X    obj3=0;
X    group=0;
X    spin1=spin2=spin3=spin4=0.0;
X    printf("Focus on the Teapot\n");
X    break;
X
X    case 2:
X    obj1=0;
X    obj2=1;
X    obj3=0;
X    group=0;
X    spin1=spin2=spin3=spin4=0.0;
X    printf("Focus on the Cube\n");
X    break;
X
X    case 3:
X    obj1=0;
X    obj2=0;
X    obj3=1;
X    group=0;
X    spin1=spin2=spin3=spin4=0.0;
X    printf("Focus on the Sphere\n");
X    break;
X    }
glutPostRedisplay();
}
X
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X      spin1=spin1+15.0;
X      spin3=spin3+1.0;
X      break;
X    case 'j':
X      spin1=spin1+15.0;
X      spin2=spin2+1.0; 
X      break;
X    case 'k':
X      spin1=spin1-15.0;
X      spin2=spin2+1.0; 
X      break;
X    case 'l':
X      spin1=spin1-15.0;
X      spin3=spin3+1.0; 
X      break;
X    case '+':
X    i=i+0.1;
X    break;
X    case'-':
X    i=i-0.1;
X    if(i<=0.1){i=0.1;printf("Can't scale any more\n");}
X    break;
X    case 'w':
X    camera=1;
X    break;
X    case 'q':
X    camera=0;
X    break;
X    case '1':
X    view1=5.0;
X    break;
X    case '2':
X    view1=-5.0;
X    break;
X    case '3':
X    view2=5;
X    break;
X    case '4':
X    view2=-5;
X    break;
X    case '5':
X    view3=5;
X    break;
X    case '6':
X    view3=-5;
X    break;
X    case '7':
X    view4=0.5;
X    break;
X    case '8':
X    view4=-0.5;
X    break;
X    case 'a':
X    view5=0.5;
X    break;
X    case 'A':
X    view5=-0.5;
X    break;
X    case 'b':
X    view6=0.5;
X    break;
X    case 'B':
X    view6=-0.5;
X    break;
X    case 'T':
X    trans=1;
X    break;
X    case 't':
X    trans=0;
X    break;
X    case 27:           
X        exit(1);
X        break;
X    default:
X      break;
X    }
display();
}
X
void 
main_menu(int value)
{
X    if (value == 666)
X        exit(0);
X    if (value == 4){
X        group=1;
X        obj1=0;
X        obj2=0;
X        obj3=0;
X    }
X    if (value == 5){
X       buffer=0;
X       win=glutGetWindow();
X       glutDestroyWindow(win);
X       glutInitDisplayMode (GLUT_SINGLE | GLUT_RGBA);
X       glutCreateWindow("NEW");
X       myinit();
X       glutReshapeFunc(myReshape);
X       glutKeyboardFunc(Key);
X       glutDisplayFunc(display);
X       submenu = glutCreateMenu(focus_object);
X       glutAddMenuEntry("Focus on Teapot", 1);
X       glutAddMenuEntry("Focus on Cube", 2);
X       glutAddMenuEntry("Focus on Sphere", 3);
X       glutCreateMenu(main_menu);
X       glutAddMenuEntry("Working Together", 4);
X       glutAddMenuEntry("Single Buffer", 5);
X       glutAddMenuEntry("Double Buffer", 6);
X       glutAddSubMenu("Pick one", submenu);
X       glutAddMenuEntry("Quit", 666);
X       glutAttachMenu(GLUT_RIGHT_BUTTON);
X    }
X    
X    if (value == 6){
X       buffer=1;
X       win=glutGetWindow();
X       glutDestroyWindow(win);
X       glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X       glutCreateWindow("NEW");
X       myinit();
X       glutReshapeFunc(myReshape);
X       glutKeyboardFunc(Key);
X       glutDisplayFunc(display);
X       submenu = glutCreateMenu(focus_object);
X       glutAddMenuEntry("Focus on Teapot", 1);
X       glutAddMenuEntry("Focus on Cube", 2);
X       glutAddMenuEntry("Focus on Sphere", 3);
X       glutCreateMenu(main_menu);
X       glutAddMenuEntry("Working Together", 4);
X       glutAddMenuEntry("Single Buffer", 5);
X       glutAddMenuEntry("Double Buffer", 6);
X       glutAddSubMenu("Pick one", submenu);
X       glutAddMenuEntry("Quit", 666);
X       glutAttachMenu(GLUT_RIGHT_BUTTON);
X    }
}
void
info(void)
{
system("clear");
printf("HW#1\n");
printf("Try Right Button !!\n");
printf("Key Board Functions:\n");
printf("    h,j,k,l:spin objects\n");
printf("          w:Enable camera movement--change of viewpoint\n");
printf("          q:Disable camera movement--change of viewpoint\n");
printf("1-8,A,a,B,b:moving camera\n");
printf("          T:Enable teapot transparency\n");
printf("          t:Disable teapot transparency\n");
printf("        +,-:scale object\n");
printf("\nAfter move camera, please disable camera movement\n");
}
void 
main(int argc, char **argv)
{
X 
X    glutInit(&argc, argv);
X    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
X    glutInitWindowPosition(500, 500);
X    glutInitWindowSize(600, 600);
X    glutCreateWindow(argv[0]);
X    myinit();
X    glutReshapeFunc(myReshape);
X    glutKeyboardFunc(Key);
X    glutDisplayFunc(display);
X    submenu = glutCreateMenu(focus_object);
X    glutAddMenuEntry("Focus on Teapot", 1);
X    glutAddMenuEntry("Focus on Cube", 2);
X    glutAddMenuEntry("Focus on Sphere", 3);
X    glutCreateMenu(main_menu);
X    glutAddMenuEntry("Working Together", 4);
X    glutAddMenuEntry("Single Buffer", 5);
X    glutAddMenuEntry("Double Buffer", 6);
X    glutAddSubMenu("Pick one", submenu);
X    glutAddMenuEntry("Quit", 666);
X    glutAttachMenu(GLUT_RIGHT_BUTTON);
X    info();
X    glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206232897 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
5c69a4ac554149f50f7f8262c3b15cff  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 9605 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '9605,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh50614
exit 0

From ???@??? Mon Feb 10 07:33:49 1997
Received: from magritte.its.rpi.edu (youngs3@magritte.its.rpi.edu [128.113.113.19])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id XAA52958
	for <citrit@rpi.edu>; Sat, 8 Feb 1997 23:58:02 -0500
From: Stephen Young <youngs3>
Received: (youngs3@localhost) by magritte.its.rpi.edu (8.6.9/8.6.4) id XAA56454 for citrit@rpi.edu; Sat, 8 Feb 1997 23:57:59 -0500
Date: Sat, 8 Feb 1997 23:57:59 -0500
Message-Id: <199702090457.XAA56454@magritte.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 2adc9ab2ff235fa11e7c84943de13096

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-08 23:57 EST by <youngs3@jec321>.
# Source directory was `/afs/rpi.edu/home/33/youngs3/private/GRAPH_VIS/homework1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   1260 -rw-r--r-- Makefile
#   1880 -rw------- README
#    765 -rw------- basics.h
#    197 -rw------- draw_all.c
#    811 -rw------- draw_blob.c
#    761 -rw------- draw_box.c
#    855 -rw------- draw_tea.c
#    798 -rw------- initial.c
#   2391 -rw------- key_press.c
#   2023 -rw------- keyback.c
#    349 -rw------- main.c
#   1073 -rw------- menu.c
#    239 -rw------- move_camera.c
#    250 -rw------- reshape.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh10553; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lMesaaux -lMesatk -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=gcc
ARGS =-D DEBUG
X
homework1: main.o
X	$(CC) -o hw1 main.o draw_box.o draw_tea.o initial.o reshape.o \
X	menu.o draw_blob.o draw_all.o key_press.o move_camera.o \
X	$(LDFLAGS) $(ARGS)
X	
main.o: main.c menu.o initial.o reshape.o draw_all.o key_press.o move_camera.o
keypress.o: keypress.c
initial.o: initial.c
draw_box.o: draw_box.c 
draw_teap.o: draw_tea.c
draw_blob.o: draw_blob.c
reshape.o: reshape.c
draw_all.o: draw_all.c draw_box.o draw_tea.o draw_blob.o 
move_camera.o: move_camera.c
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0208225797 'Makefile' &&
  chmod 0644 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
be7e2d02971461576c31403849a3e7df  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 1260 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '1260,' 'current size' "$shar_count!"
  fi
fi
# ============= README ==============
if test -f 'README' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'README' '(file already exists)'
else
  $echo 'x -' extracting 'README' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'README' &&
Well here are a few directions on the use of this homework project.
X
1] One problem which was never solved was how to switch between double and
X single buffered windows without killing the original window. It appears that
X the only way to set the buffers is through the glutInitDisplayMode which is 
X a bitmask and no other command seems able to reset that bitmask.
X
2] I never did figure out how to do lighting correctly. I managed to get the
material lighting but never managed to get that 3D looking affect. The only
benefit that I got from NOT being able to do the lighting is that the 
transparency was easier to do (from not having to turn off lights)
X
Okay basically the following occurs in the program.
X
A] Toggle between affecting the movement of the
X   camera, teapot, cube, or sphere with the menus
X
i = move +0.2 in i (x in engineering terms) direction
I = move -0.2 in i direction
X
j = move +0.2 in j (y in engineering terms) direction
J = move -0.2 in j direction
X
k = move +0.2 in k (z in engineering terms) direction  
K = move -0.2 in k direction 
X
x = move +15.0 degrees rotation about x axis
XX = move -15.0 degrees rotation about x axis
X
y = move +15.0 degrees rotation about y axis
Y = move -15.0 degrees rotation about Y axis
X
z = move +15.0 degrees rotation about z axis
Z = move -15.0 degrees rotation about Z axis
X
- = scale down (only on objects)
+ = scale up (only on objects)
X
f = Full solid mode (teapot only)
F = transparent attempt (teapot only)
X
B] Double and single buffer toggling doesn't work. 
X
X
I haven't thrown headers onto the top of my files. Since I'm assuming that 
this README will have been read. I hereby acknowledge that this project is 
2 days late. PLEASE send me email if you need comments on the code! I also
haven't had time to comment any code yet!
X
This program was compiled on a SGI Indy
X
Stephen Young
2/8/97
X
youngs3@rpi.edu
SHAR_EOF
  $shar_touch -am 0208235697 'README' &&
  chmod 0600 'README' ||
  $echo 'restore of' 'README' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'README:' 'MD5 check failed'
3c901bb8a2c98ebeda2a4a302b2a7431  README
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'README'`"
    test 1880 -eq "$shar_count" ||
    $echo 'README:' 'original size' '1880,' 'current size' "$shar_count!"
  fi
fi
# ============= basics.h ==============
if test -f 'basics.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'basics.h' '(file already exists)'
else
  $echo 'x -' extracting 'basics.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'basics.h' &&
#include <stdlib.h>
#ifdef _WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glut.h>
#include <GL/glu.h>
X
void clear_scr(void);
void main_menu(int value);
void camera_options(int value);
void draw_tea(void);
void draw_box(void);
void draw_blob(void);
void init_all(void);
void reshape_fun(GLsizei w,GLsizei h);
void draw_all(void);
void key_press(unsigned char key, int x, int y);
void set_lighting(void);
void move_camera(void);
X
#define TEA_T 100
#define BOX_T 200
#define BLOB_T 300
#define CAM_T 400
X
struct fig_vals
{
X  float x_disp;
X  float y_disp;
X  float z_disp;
X  float x_rot;
X  float y_rot;
X  float z_rot;
X  float scale_val;
};
X
typedef struct fig_vals fig;
X  
fig tea;
fig box;
fig blob;
fig cam;
X
int toggler;
int filled;
float angle;
X
SHAR_EOF
  $shar_touch -am 0208230997 'basics.h' &&
  chmod 0600 'basics.h' ||
  $echo 'restore of' 'basics.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'basics.h:' 'MD5 check failed'
951214eb51af4980b3eb6c535cb6aff0  basics.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'basics.h'`"
    test 765 -eq "$shar_count" ||
    $echo 'basics.h:' 'original size' '765,' 'current size' "$shar_count!"
  fi
fi
# ============= draw_all.c ==============
if test -f 'draw_all.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'draw_all.c' '(file already exists)'
else
  $echo 'x -' extracting 'draw_all.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'draw_all.c' &&
#include "basics.h"
X
void draw_all(void)
{
X
X  glOrtho(-1.0,1.0,-1.0,1.0,-1.0,1.0);
X  clear_scr();
X
X  draw_box();
X  draw_tea();
X  draw_blob();
X  move_camera();
X  
X  glFlush;
X  glutSwapBuffers();
}
X
SHAR_EOF
  $shar_touch -am 0208232197 'draw_all.c' &&
  chmod 0600 'draw_all.c' ||
  $echo 'restore of' 'draw_all.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'draw_all.c:' 'MD5 check failed'
74dc081581677f3c5b43f6ca5a87b6be  draw_all.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'draw_all.c'`"
    test 197 -eq "$shar_count" ||
    $echo 'draw_all.c:' 'original size' '197,' 'current size' "$shar_count!"
  fi
fi
# ============= draw_blob.c ==============
if test -f 'draw_blob.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'draw_blob.c' '(file already exists)'
else
  $echo 'x -' extracting 'draw_blob.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'draw_blob.c' &&
#include "basics.h"
X
void draw_blob(void)
{
X  glPushMatrix();
X
X  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
X  glEnable(GL_COLOR_MATERIAL);
X  glColor3f(0.1,0.25,0.4);
X  glTranslatef(blob.x_disp,blob.y_disp,blob.z_disp);
X
X  if (blob.x_rot>360)
X    blob.x_rot=blob.x_rot-360;
X  if (blob.x_rot<-360)
X    blob.x_rot=blob.x_rot+360;
X  
X  if (blob.y_rot>360)
X    blob.y_rot=blob.y_rot-360;
X  if (blob.y_rot<-360)
X    blob.y_rot=blob.y_rot+360;
X  
X  if (blob.z_rot>360)
X    blob.z_rot=blob.z_rot-360;
X  if (blob.x_rot<-360)
X    blob.z_rot=blob.z_rot+360;
X
X  glRotatef(blob.x_rot,1.0,0.0,0.0);
X  glRotatef(blob.y_rot,0.0,1.0,0.0);
X  glRotatef(blob.z_rot,0.0,0.0,1.0);
X
X
X  if (blob.scale_val<0)
X    blob.scale_val=0;
X  
X  glutSolidSphere(blob.scale_val,100,100);
X  glDisable(GL_COLOR_MATERIAL);
X  glPopMatrix();
}
SHAR_EOF
  $shar_touch -am 0208215997 'draw_blob.c' &&
  chmod 0600 'draw_blob.c' ||
  $echo 'restore of' 'draw_blob.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'draw_blob.c:' 'MD5 check failed'
4bb49f5ae8cc28635e54be984b2aabbe  draw_blob.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'draw_blob.c'`"
    test 811 -eq "$shar_count" ||
    $echo 'draw_blob.c:' 'original size' '811,' 'current size' "$shar_count!"
  fi
fi
# ============= draw_box.c ==============
if test -f 'draw_box.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'draw_box.c' '(file already exists)'
else
  $echo 'x -' extracting 'draw_box.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'draw_box.c' &&
#include "basics.h"
X
void draw_box(void)
{
X  glPushMatrix();
X  glTranslatef(box.x_disp,box.y_disp,box.z_disp);
X
X  if (box.x_rot>360)
X    box.x_rot=box.x_rot-360;
X  if (box.x_rot<-360)
X    box.x_rot=box.x_rot+360;
X  
X  if (box.y_rot>360)
X    box.y_rot=box.y_rot-360;
X  if (box.y_rot<-360)
X    box.y_rot=box.y_rot+360;
X  
X  if (box.z_rot>360)
X    box.z_rot=box.z_rot-360;
X  if (box.x_rot<-360)
X    box.z_rot=box.z_rot+360;  
X
X
X
X  glRotatef(box.x_rot,1.0,0.0,0.0);
X  glRotatef(box.y_rot,0.0,1.0,0.0);
X  glRotatef(box.z_rot,0.0,0.0,1.0);
X
X  glColorMaterial(GL_FRONT,GL_SPECULAR);
X  glEnable(GL_COLOR_MATERIAL);
X  glColor3f(0.8,0.0,0.0);
X  if (box.scale_val<0)
X    box.scale_val=0;
X
X  glutSolidCube(box.scale_val);
X  glDisable(GL_COLOR_MATERIAL);
X  glPopMatrix();
}
SHAR_EOF
  $shar_touch -am 0208222997 'draw_box.c' &&
  chmod 0600 'draw_box.c' ||
  $echo 'restore of' 'draw_box.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'draw_box.c:' 'MD5 check failed'
fadc3042a86beb906e29ac44b74b8393  draw_box.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'draw_box.c'`"
    test 761 -eq "$shar_count" ||
    $echo 'draw_box.c:' 'original size' '761,' 'current size' "$shar_count!"
  fi
fi
# ============= draw_tea.c ==============
if test -f 'draw_tea.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'draw_tea.c' '(file already exists)'
else
  $echo 'x -' extracting 'draw_tea.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'draw_tea.c' &&
#include "basics.h"
X
void draw_tea (void)
{  
X  glPushMatrix();
X  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
X  glEnable(GL_COLOR_MATERIAL);
X  glColor3f(0.8,0.8,0.0);
X  glTranslatef(tea.x_disp,tea.y_disp,tea.z_disp);
X  
X  if (tea.x_rot>360)
X    tea.x_rot=tea.x_rot-360;
X  if (tea.x_rot<-360)
X    tea.x_rot=tea.x_rot+360;
X  
X  if (tea.y_rot>360)
X    tea.y_rot=tea.y_rot-360;
X  if (tea.y_rot<-360)
X    tea.y_rot=tea.y_rot+360;
X  
X  if (tea.z_rot>360)
X    tea.z_rot=tea.z_rot-360;
X  if (tea.x_rot<-360)
X    tea.z_rot=tea.z_rot+360;  
X  
X  glRotatef(tea.x_rot,1.0,0.0,0.0);
X  glRotatef(tea.y_rot,0.0,1.0,0.0);
X  glRotatef(tea.z_rot,0.0,0.0,1.0);
X
X  if (tea.scale_val<0)
X    tea.scale_val=0;
X
X  if (filled==0)
X    glutWireTeapot(tea.scale_val);
X  
X  else 
X    glutSolidTeapot(tea.scale_val);
X     
X  glDisable(GL_COLOR_MATERIAL);
X  glPopMatrix();
}
X
X
X
X
X
SHAR_EOF
  $shar_touch -am 0208223897 'draw_tea.c' &&
  chmod 0600 'draw_tea.c' ||
  $echo 'restore of' 'draw_tea.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'draw_tea.c:' 'MD5 check failed'
e861ae1139a94323f59830a5e0b03b54  draw_tea.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'draw_tea.c'`"
    test 855 -eq "$shar_count" ||
    $echo 'draw_tea.c:' 'original size' '855,' 'current size' "$shar_count!"
  fi
fi
# ============= initial.c ==============
if test -f 'initial.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'initial.c' '(file already exists)'
else
  $echo 'x -' extracting 'initial.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'initial.c' &&
#include "basics.h"
X
void init_tea(void)
{
X  tea.x_disp=-2.0;
X  tea.y_disp=0.0;
X  tea.z_disp=0.0;
X  tea.x_rot=0.0;
X  tea.y_rot=0.0;
X  tea.z_rot=0.0;
X  tea.scale_val=0.5;
}
X
void init_box(void)
{
X  box.x_disp=0.0;
X  box.y_disp=0.0;
X  box.z_disp=0.0;
X  box.x_rot=0.0;
X  box.y_rot=0.0;
X  box.z_rot=0.0;
X  box.scale_val=1.0;
}
X
void init_blob(void)
{
X  blob.x_disp=2.0;
X  blob.y_disp=0.0;
X  blob.z_disp=0.0;
X  blob.x_rot=0.0;
X  blob.y_rot=0.0;
X  blob.z_rot=0.0;
X  blob.scale_val=0.5;
}
X
void init_cam(void)
{
X  cam.x_disp=0.0;
X  cam.y_disp=0.0;
X  cam.z_disp=0.0;
X  cam.x_rot=0.0;
X  cam.y_rot=0.0;
X  cam.z_rot=0.0;
}
X
void init_all(void)
{ 
X  glOrtho(-3.0,3.0,-1.0,1.0,-3.0,3.0);
X  toggler=0;
X  filled=1;
X  init_cam();
X  init_box();
X  init_tea();
X  init_blob();
X  glShadeModel(GL_FLAT);
}
X
X
X
X
X
X
X
X
X
X
X
X
X
X
SHAR_EOF
  $shar_touch -am 0208231997 'initial.c' &&
  chmod 0600 'initial.c' ||
  $echo 'restore of' 'initial.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'initial.c:' 'MD5 check failed'
bbc92d406a87334e856922e45e4f1e82  initial.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'initial.c'`"
    test 798 -eq "$shar_count" ||
    $echo 'initial.c:' 'original size' '798,' 'current size' "$shar_count!"
  fi
fi
# ============= key_press.c ==============
if test -f 'key_press.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'key_press.c' '(file already exists)'
else
  $echo 'x -' extracting 'key_press.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'key_press.c' &&
#include "basics.h"
X
void key_press(unsigned char key, int x, int y)
{
X  float alter_x;
X  float alter_y;
X  float alter_z;
X  float scaler;
X  float move_x;
X  float move_y;
X  float move_z;
X  float angle;
X  int fill_flag;
X  
X  alter_x=0;
X  alter_y=0;
X  alter_z=0;
X  move_x=0;
X  move_y=0;
X  move_z=0;
X  scaler=0;
X  fill_flag=filled;
X
X  switch (key)
X    {
X    case 'y':
X      alter_y=15.0;
X      break;
X    case 'Y':
X      alter_y=-15.0;
X      break;
X    case 'x':
X      alter_x=15.0;
X      break;
X    case 'X':
X      alter_x=-15.0;
X      break;
X    case 'z':
X      alter_z=15.0;
X      break;
X    case 'Z':
X      alter_z=-15.0;
X      break;
X      
X    case '+':
X      scaler=scaler+0.1;
X      break;
X
X    case '-':
X      scaler=scaler-0.1;
X      break;
X     
X    case 'i':
X      move_x=move_x+0.2;
X      break;
X    case 'I':
X      move_x=move_x-0.2;
X      break;
X    case 'j':
X      move_y=move_y+0.2;
X      break;
X    case 'J':
X      move_y=move_y-0.2;
X      break;
X    case 'k':
X      move_z=move_z+0.2;
X      break;
X    case 'K':
X      move_z=move_z-0.2;
X      break;
X
X    case 'f':
X      fill_flag=1;
X      break;
X    
X    case 'F':
X      fill_flag=0;
X      break;
X
X    default:
X      break;
X    }
X  
X  switch (toggler)
X    {
X    case TEA_T:
X      glPushMatrix();
X      tea.x_disp=tea.x_disp+move_x;
X      tea.y_disp=tea.y_disp+move_y;
X      tea.z_disp=tea.z_disp+move_z;
X      tea.scale_val=tea.scale_val+scaler;
X      tea.x_rot=tea.x_rot+alter_x;
X      tea.y_rot=tea.y_rot+alter_y;
X      tea.z_rot=tea.z_rot+alter_z;
X      filled=fill_flag;
X
X      break;
X
X    case BOX_T:
X
X      box.x_rot=box.x_rot+alter_x;
X      box.y_rot=box.y_rot+alter_y;
X      box.z_rot=box.z_rot+alter_z;
X      box.x_disp=box.x_disp+move_x;
X      box.y_disp=box.y_disp+move_y;
X      box.z_disp=box.z_disp+move_z;
X      box.scale_val=box.scale_val+scaler;
X      break;
X
X    case BLOB_T:
X      blob.x_rot=blob.x_rot+alter_x;
X      blob.y_rot=blob.y_rot+alter_y;
X      blob.z_rot=blob.z_rot+alter_z;
X      blob.x_disp=blob.x_disp+move_x;
X      blob.y_disp=blob.y_disp+move_y;
X      blob.z_disp=blob.z_disp+move_z;
X      blob.scale_val=blob.scale_val+scaler;
X
X      break;
X
X    case CAM_T:
X      cam.x_rot=-alter_x;
X      cam.y_rot=-alter_y;
X      cam.z_rot=-alter_z;
X      cam.x_disp=-move_x;
X      cam.y_disp=-move_y;
X      cam.z_disp=-move_z;
X      
X      break;
X
X      
X    default:
X      break;
X    }
X  draw_all();
}
SHAR_EOF
  $shar_touch -am 0208233497 'key_press.c' &&
  chmod 0600 'key_press.c' ||
  $echo 'restore of' 'key_press.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'key_press.c:' 'MD5 check failed'
99cdc7e61d72ca4c4ec33c4ec7d500be  key_press.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'key_press.c'`"
    test 2391 -eq "$shar_count" ||
    $echo 'key_press.c:' 'original size' '2391,' 'current size' "$shar_count!"
  fi
fi
# ============= keyback.c ==============
if test -f 'keyback.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'keyback.c' '(file already exists)'
else
  $echo 'x -' extracting 'keyback.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'keyback.c' &&
#include "basics.h"
X
void key_press(unsigned char key, int x, int y)
{
X  float alter_x;
X  float alter_y;
X  float alter_z;
X  float scaler;
X  float move_x;
X  float move_y;
X  float move_z;
X  float angle;
X  
X  alter_x=0;
X  alter_y=0;
X  alter_z=0;
X  move_x=0;
X  move_y=0;
X  move_z=0;
X  scaler=0;
X  
X  switch (key)
X    {
X    case 'y':
X      alter_y++;
X      break;
X    case 'Y':
X      alter_y--;
X      break;
X    case 'x':
X      alter_x++;
X      break;
X    case 'X':
X      alter_x--;
X      break;
X    case 'z':
X      alter_z++;
X      break;
X    case 'Z':
X      alter_z--;
X      break;
X      
X    case '+':
X      scaler=scaler+0.1;
X      break;
X
X    case '-':
X      scaler=scaler-0.1;
X      break;
X     
X    case 'i':
X      move_x=move_x+0.1;
X      break;
X    case 'I':
X      move_x=move_x-0.1;
X      break;
X    case 'j':
X      move_y=move_y+0.1;
X      break;
X    case 'J':
X      move_y=move_y-0.1;
X      break;
X    case 'k':
X      move_z=move_z+0.1;
X      break;
X    case 'K':
X      move_z=move_z-0.1;
X      break;
X
X    default:
X      break;
X    }
X  
X  switch (toggler)
X    {
X    case TEA_T:
X      tea.x_rot=tea.x_rot+alter_x;
X      tea.y_rot=tea.y_rot+alter_y;
X      tea.z_rot=tea.z_rot+alter_z;
X      tea.x_disp=tea.x_disp+move_x;
X      tea.y_disp=tea.y_disp+move_y;
X      tea.z_disp=tea.z_disp+move_z;
X      tea.scale_val=tea.scale_val+scaler;
X      break;
X
X    case BOX_T:
X
X      box.x_rot=box.x_rot+alter_x;
X      box.y_rot=box.y_rot+alter_y;
X      box.z_rot=box.z_rot+alter_z;
X      box.x_disp=box.x_disp+move_x;
X      box.y_disp=box.y_disp+move_y;
X      box.z_disp=box.z_disp+move_z;
X      box.scale_val=box.scale_val+scaler;
X      break;
X
X    case BLOB_T:
X      blob.x_rot=blob.x_rot+alter_x;
X      blob.y_rot=blob.y_rot+alter_y;
X      blob.z_rot=blob.z_rot+alter_z;
X      blob.x_disp=blob.x_disp+move_x;
X      blob.y_disp=blob.y_disp+move_y;
X      blob.z_disp=blob.z_disp+move_z;
X      blob.scale_val=blob.scale_val+scaler;
X
X      break;
X      
X    default:
X      break;
X    }
/*  glutPostRedisplay();*/
X  draw_all();
}
SHAR_EOF
  $shar_touch -am 0208142497 'keyback.c' &&
  chmod 0600 'keyback.c' ||
  $echo 'restore of' 'keyback.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'keyback.c:' 'MD5 check failed'
872b64fa9a100aa35343076246c748c8  keyback.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'keyback.c'`"
    test 2023 -eq "$shar_count" ||
    $echo 'keyback.c:' 'original size' '2023,' 'current size' "$shar_count!"
  fi
fi
# ============= main.c ==============
if test -f 'main.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'main.c' '(file already exists)'
else
  $echo 'x -' extracting 'main.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
#include "basics.h"
X
int main(int argc, char** argv)
{
X  glutInitWindowSize(400,200);
X  glutInit(&argc,argv);
X  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
X  glutCreateWindow(argv[0]);
X
X  glutKeyboardFunc(key_press);
X  glutSwapBuffers();
X  init_all();
X  glutDisplayFunc(draw_all);
X  glutReshapeFunc(reshape_fun);
X  set_menus();
X  glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0208231397 'main.c' &&
  chmod 0600 'main.c' ||
  $echo 'restore of' 'main.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'main.c:' 'MD5 check failed'
b6261ad936e30634614a197371ad4d51  main.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'main.c'`"
    test 349 -eq "$shar_count" ||
    $echo 'main.c:' 'original size' '349,' 'current size' "$shar_count!"
  fi
fi
# ============= menu.c ==============
if test -f 'menu.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'menu.c' '(file already exists)'
else
  $echo 'x -' extracting 'menu.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'menu.c' &&
#include "basics.h"
/*
X * Start with basics set the screen to black. 
X *
X */
X
void clear_scr(void)
{
X  glClearColor(0.0, 0.0, 0.0, 0.0);
X  glClear(GL_COLOR_BUFFER_BIT);
}
X
X
void main_menu(int value)
{
X    if (value==911)
X      {
X	exit(0);
X      }
X    
X    else if (value==TEA_T)
X      {
X	toggler=TEA_T;
X      }
X    else if (value==BOX_T)
X      {
X	toggler=BOX_T;
X      }
X    else if (value==BLOB_T)
X      {
X	toggler=BLOB_T;
X      }
}
X
void camera_options(int value)
{
X  switch(value)
X    {
X    case 1:
X      toggler=CAM_T;
X      break;
X    default:
X      break;
X    }
X  
}
X
void set_menus(void)  
{ 
X
X  int cam_options;
X  
X  cam_options=glutCreateMenu(camera_options);
X  glutAddMenuEntry("Move Camera Point",1);
X  glutAddMenuEntry("Single buffered",2);
X  glutAddMenuEntry("Double buffered",3);
X  
X  glutCreateMenu(main_menu);
X  glutAddMenuEntry("Quit",911);
X  glutAddSubMenu("Camera Options",cam_options);
X  glutAddMenuEntry("Adjust Teapot",TEA_T);
X  glutAddMenuEntry("Adjust Cube",BOX_T);
X  glutAddMenuEntry("Adjust Sphere",BLOB_T);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
}
X
SHAR_EOF
  $shar_touch -am 0208231597 'menu.c' &&
  chmod 0600 'menu.c' ||
  $echo 'restore of' 'menu.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'menu.c:' 'MD5 check failed'
7ef61f8b24b0617b346493d217fa500b  menu.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'menu.c'`"
    test 1073 -eq "$shar_count" ||
    $echo 'menu.c:' 'original size' '1073,' 'current size' "$shar_count!"
  fi
fi
# ============= move_camera.c ==============
if test -f 'move_camera.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'move_camera.c' '(file already exists)'
else
  $echo 'x -' extracting 'move_camera.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'move_camera.c' &&
#include "basics.h"
X
void move_camera(void)
{
X  glMatrixMode(GL_MODELVIEW);
X  
X  glRotatef(cam.x_rot,1.0,0.0,0.0);
X  glRotatef(cam.y_rot,0.0,1.0,0.0);
X  glRotatef(cam.z_rot,0.0,0.0,1.0);
X  glTranslatef(cam.x_disp,cam.y_disp,cam.z_disp);
}
SHAR_EOF
  $shar_touch -am 0208233397 'move_camera.c' &&
  chmod 0600 'move_camera.c' ||
  $echo 'restore of' 'move_camera.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'move_camera.c:' 'MD5 check failed'
26a11bf72fbe2b929c7aacd091a777b3  move_camera.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'move_camera.c'`"
    test 239 -eq "$shar_count" ||
    $echo 'move_camera.c:' 'original size' '239,' 'current size' "$shar_count!"
  fi
fi
# ============= reshape.c ==============
if test -f 'reshape.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'reshape.c' '(file already exists)'
else
  $echo 'x -' extracting 'reshape.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'reshape.c' &&
#include "basics.h"
X
void reshape_fun(GLsizei w, GLsizei h)
{
X  glViewport (0, 0, w, h);            /*  define the viewport */
X  glMatrixMode(GL_PROJECTION);
X  glLoadIdentity();
X  glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
SHAR_EOF
  $shar_touch -am 0208094197 'reshape.c' &&
  chmod 0600 'reshape.c' ||
  $echo 'restore of' 'reshape.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'reshape.c:' 'MD5 check failed'
dfc8aa84a3752cda5dffae53d19b7edb  reshape.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'reshape.c'`"
    test 250 -eq "$shar_count" ||
    $echo 'reshape.c:' 'original size' '250,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh10553
exit 0

From ???@??? Mon Feb 10 07:34:01 1997
Received: from jec317.its.rpi.edu (cheny4@jec317.its.rpi.edu [128.113.10.67])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id UAA40760
	for <citrit@rpi.edu>; Sun, 9 Feb 1997 20:27:30 -0500
From: Yuping Chen <cheny4>
Received: (cheny4@localhost) by jec317.its.rpi.edu (951211.SGI.8.6.12.PATCH1042/8.6.4) id UAA09780 for citrit@rpi.edu; Sun, 9 Feb 1997 20:27:28 -0500
Date: Sun, 9 Feb 1997 20:27:28 -0500
Message-Id: <199702100127.UAA09780@jec317.its.rpi.edu>
To: citrit@rpi.edu
Subject: Homework 1
X-UIDL: c618e6e2e391c1b261b85bb0a7619bfe

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-09 20:27 EST by <cheny4@jec317>.
# Source directory was `/afs/rpi.edu/home/04/cheny4/private/gnv/hw1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   6725 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh09776; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *  hw1.c 
X *  Drawing 3 objects and rotate and zoom them seperately
X *
X *  By: Yuping Chen
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
#include <stdio.h>
X
typedef struct {
X  int	rotate_h;
X  int	rotate_j;
X  int	rotate_k;
X  int	rotate_l;
X  int	zoom_in;
X  int	zoom_out; 
} actions;
X
X  int	zoom_in;
X  int	zoom_out;
enum geom {Cube, Sphere, Teapot};
enum geom object;
X
actions	cube, sphere, teapot;
X
void drawCube(void) {
X     GLfloat mat_ambient[] = { 0.8, 0.2, 0.1, 1.0 };
X     GLfloat mat_diffuse[] = { 0.8, 0.1, 0.2, 1.0 };
X     GLfloat mat_specular[] = { 0.9, 0.0, 0.0, 1.0 }; 
X     GLfloat low_shininess[] = { 10.0 };
X
X     glTranslatef(0.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
X     glutSolidCube(0.6);
}  
X
void drawSphere(void)  {
X     GLfloat mat_ambient[] = { 0.0, 0.0, 0.8, 1.0 };
X     GLfloat mat_diffuse[] = { 0.1, 0.1, 0.8, 1.0 };
X     GLfloat mat_specular[] = { 0.0, 0.0, 0.0, 0.1 }; 
X     GLfloat no_shininess[] = { 0.0 };
X
X     glTranslatef(2.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X     glutSolidSphere(0.4, 20, 20);        
}  
X
void drawTeapot(void) {
X     GLfloat mat_ambient[] = { 0.7, 0.7, 0.1, 1.0 };
X     GLfloat mat_diffuse[] = { 0.6, 0.6, 0.1, 1.0 };
X     GLfloat mat_specular[] = { 0.4, 0.4, 0.2, 0.1 }; 
X     GLfloat no_shininess[] = { 5.0 };
X
X     glTranslatef(-2.0, 0.0, 0.0);
X     glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
X     glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
X     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
X     glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
X     glutWireTeapot(0.4);
}   
X     
void display(void)
{  
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X     /* glInitMatrix();*/
X
X      glPushMatrix();
X         glRotatef(15*cube.rotate_h, 0.0, 1.0, 0.0);
X         glRotatef(15*cube.rotate_j, 1.0, 0.0, 0.0);
X         glRotatef(-15*cube.rotate_k, 1.0, 0.0, 0.0);
X         glRotatef(-15*cube.rotate_l, 0.0, 1.0, 0.0);
X      drawCube();
X      glPopMatrix();
X
X      glPushMatrix();
X         glRotatef(15*sphere.rotate_h, 0.0, 1.0, 0.0);
X         glRotatef(15*sphere.rotate_j, 1.0, 0.0, 0.0);
X         glRotatef(-15*sphere.rotate_k, 1.0, 0.0, 0.0);
X         glRotatef(-15*sphere.rotate_l, 0.0, 1.0, 0.0);
X      drawSphere();
X      glPopMatrix();
X
X      glPushMatrix();
X         glRotatef(15*teapot.rotate_h, 0.0, 1.0, 0.0);
X         glRotatef(15*teapot.rotate_j, 1.0, 0.0, 0.0);
X         glRotatef(-15*teapot.rotate_k, 1.0, 0.0, 0.0);
X         glRotatef(-15*teapot.rotate_l, 0.0, 1.0, 0.0);
X      drawTeapot();
X      glPopMatrix();      
X      glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X  
X    cube.rotate_h=0;
X    cube.rotate_j=0;
X    cube.rotate_k=0;
X    cube.rotate_l=0;
X    cube.zoom_in=0;
X    cube.zoom_out=0;
X
X    sphere.rotate_h=0;
X    sphere.rotate_j=0;
X    sphere.rotate_k=0;
X    sphere.rotate_l=0;
X    sphere.zoom_in=0;
X    sphere.zoom_out=0; 
X
X    teapot.rotate_h=0;
X    teapot.rotate_j=0;
X    teapot.rotate_k=0;
X    teapot.rotate_l=0;
X    teapot.zoom_in=0;
X    teapot.zoom_out=0;
X  
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glEnable(GL_DEPTH_TEST);
X      glShadeModel (GL_FLAT);
X /*    glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X
X    switch (key) {
X    case 'h':
X      
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      if (object == Cube)  
X	cube.rotate_h++;
X      if (object == Sphere)
X	sphere.rotate_h++;
X      if (object == Teapot)
X	teapot.rotate_h++;
X      break;
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      if (object == Cube)  
X	cube.rotate_j++;
X      if (object == Sphere)
X	sphere.rotate_j++;
X      if (object == Teapot)
X	teapot.rotate_j++;
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X
X      if (object == Cube)  
X	cube.rotate_k++;
X      if (object == Sphere)
X	sphere.rotate_k++;
X      if (object == Teapot)
X	teapot.rotate_k++;
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      if (object == Cube)  
X	cube.rotate_l++;
X      if (object == Sphere)
X	sphere.rotate_l++;
X      if (object == Teapot)
X	teapot.rotate_l++;
X      break;
X    case 'i':
X	zoom_in++;
X      break;
X    case 'o':
X	zoom_out++;
X      break;      
X      
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X
X    switch (value) {
X    case 1:
X      object=Cube;
X      break;
X    case 2:
X      object=Sphere;
X      break;
X    case 3:
X      object=Teapot;
X      break;
X    case 4:
X        exit(0);
X	break;
X      }
}
X
void addmenu(void)
{
X      glutAddMenuEntry("Cube", 1);
X      glutAddMenuEntry("Sphere", 2);
X      glutAddMenuEntry("Teapot", 3);
X      glutAddMenuEntry("Quit", 4);
}
X
X
void intro(void) {
X     printf("\n\n\n\t\t******* README *******\n\n");
X     printf("To select an object, click the right mouse button;\n");
X     printf("To rotate, press 'j' and 'k' to rotate about the\n");
X     printf("y-axis, 'h' and 'l' to rotate about the x-axis\n\n\n");
X
X   }
X     
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      intro();
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowPosition(20, 560);
X      glutInitWindowSize(600, 400);
X      glutCreateWindow (argv[0]);
X      myInit ();
X
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display); 
X      glutCreateMenu(Select); 
X      glutKeyboardFunc(Key);
X      addmenu ();
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
X      return 0;
}
X
SHAR_EOF
  $shar_touch -am 0209202597 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
0cd0fff66334ec02de22bbe08b39bd02  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 6725 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '6725,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh09776
exit 0

From ???@??? Fri Feb 07 11:03:14 1997
Received: from linux1.acm.rpi.edu (linux1.acm.rpi.edu [128.213.5.20])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id KAA38254
	for <citrit@rpi.edu>; Fri, 7 Feb 1997 10:45:07 -0500
Received: (from mjr@localhost) by linux1.acm.rpi.edu (8.7.6/8.7.3) id KAA08246; Fri, 7 Feb 1997 10:44:35 -0500
Message-ID: <19970207104435.IO60896@acm.rpi.edu>
Date: Fri, 7 Feb 1997 10:44:35 -0500
From: mjr@linux1.acm.rpi.edu (Matthew J. Ryan)
To: citrit@rpi.edu (Thomas D. Citriniti)
Subject: Homework #1 Resubmission
References: <1.5.4.32.19970207154032.006faab4@mail.its.rpi.edu>
X-Mailer: Mutt 0.59
Mime-Version: 1.0
In-Reply-To: <1.5.4.32.19970207154032.006faab4@mail.its.rpi.edu>; from Thomas D. Citriniti on Feb 7, 1997 10:40:32 -0500
X-UIDL: a1cbd93bb89b3457a205d7e7c7a07dc1

#!/bin/sh
# This is a shell archive (produced by GNU sharut 4.2.1).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-07 10:42 EST by <mjr@vir>.
# Source directory was `/home/mjr/class/gv/proj1'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    803 -rw-r--r-- Makefile
#   9821 -rw-r--r-- proj1.c
#    296 -rw-rw-r-- proj1.h
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
    shar_n= shar_c='
'
  else
    shar_n=-n shar_c=
  fi
else
  shar_n= shar_c='\c'
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
$echo $shar_n 'x -' 'lock directory' "\`_sh01078': "$shar_c
if mkdir _sh01078; then
  $echo 'created'
else
  $echo 'failed to create'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
CC=gcc
LDFLAGS= -L/usr/X11R6/lib -lglut -lMesaGLU -lMesaGL -lXmu -lXi -lXext -lXt -lX11 -lm
CFLAGS= -g -I/usr/include/mesa -I/usr/include/glut
X
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LIBS) $(LDFLAGS)
X
clean:
X	/bin/rm -f *.o
X
proj1.o: proj1.h
SHAR_EOF
  $shar_touch -am 0207102497 'Makefile' &&
  chmod 0644 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
89f35823116f032b31c7c2a1d84c085a  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'Makefile'`"
    test 803 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '803,' 'current size' "$shar_count!"
  fi
fi
# ============= proj1.c ==============
if test -f 'proj1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'proj1.c' '(file already exists)'
else
  $echo 'x -' extracting 'proj1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'proj1.c' &&
/*
X *
X *  Simple2.c 
X *
X *  Simple example of programming using the OpenGL graphics library
X *  Taken from the "OpenGL Programming Guide"
X *
X *
X */
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
#include <stdio.h>
#include "proj1.h"
X
/* Global State Variables */
static objState worldInitial = {0.0, 0.0, -5.0, 0.0, 0.0, 0.0, 1.0,
X	{{0.0, 0.0, 0.0, 0.0},
X	 {0.0},
X	 {0.0, 0.0, 0.0, 0.0},
X	 {0.0, 0.0, 0.0, 0.0}}};
static objState world;
static objState cubeInitial = {0,0,0,0,0,0,1,
X	{{0.7, 0.2, 0.2, 1.0},
X	 {120.0},
X	 {0.9, 0.0, 0.0, 1.0},
X	 {1.0, 1.0, 1.0, 1.0}}};
static objState cube;
static objState sphereInitial = {2,0,0,0,0,0,1,
X	{{0.1, 0.1, 1.1, 1.0},
X	 {0.0},
X	 {1.0, 1.0, 1.0, 1.0},
X	 {0.0, 0.0, 1.0, 1.0}}};
static objState sphere;
static objState teapotInitial = {-2,0,0,0,0,0,1,
X	{{0.7, 0.7, 0.0, 1.0},
X	 {100.0},
X	 {0.6, 0.6, 0.1, 1.0},
X	 {1.0, 1.0, 0.5, 1.0}}};
static objState teapot;
X
static int sBufWin;
static int dBufWin;
X
void copyState(objState *src, objState *dest) {
X  bcopy(src, dest, sizeof(GLfloat)*7);
X  bcopy(src->mat.amb, dest->mat.amb, sizeof(float)*4);
X  bcopy(src->mat.shiny, dest->mat.shiny, sizeof(float)*1);
X  bcopy(src->mat.diff, dest->mat.diff, sizeof(float)*4);
X  bcopy(src->mat.spec, dest->mat.spec, sizeof(float)*4);
}
/*
X * Reset the program to it's initial state. 
X */
void resetWorld(void){
X  copyState(&worldInitial, &world);
X  copyState(&cubeInitial, &cube);
X  copyState(&sphereInitial, &sphere);
X  copyState(&teapotInitial, &teapot);
X  glutHideWindow();
X  glutSetWindow(dBufWin);
X  glutShowWindow();
}
X
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X  static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X  static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X  static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X  static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X  static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X  glPushMatrix();
X    /* Do world transformations */
X    glScalef(world.size, world.size, world.size);
X    glTranslatef(world.x, world.y, world.z);
X    glRotatef(world.rotX, 1.0, 0.0, 0.0);
X    glRotatef(world.rotY, 0.0, 1.0, 0.0);
X    glRotatef(world.rotZ, 0.0, 0.0, 1.0);
X
X    /* Set up lighting */
X    glEnable(GL_LIGHTING);
X    glEnable(GL_LIGHT0);
X    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X    glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X    glEnable(GL_DEPTH_TEST);
X
X    glPushMatrix();
X      glScalef(cube.size, cube.size, cube.size);
X      glTranslatef(cube.x/cube.size, cube.y/cube.size, cube.z/cube.size);
X      glRotatef(cube.rotX, 1.0, 0.0, 0.0);
X      glRotatef(cube.rotY, 0.0, 1.0, 0.0);
X      glRotatef(cube.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the cube */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, cube.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, cube.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, cube.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, cube.mat.shiny);
X        
X      glutSolidCube(1.0);   /*  draw the cube       */
X    glPopMatrix();
X
X    glPushMatrix();
X      glShadeModel(GL_FLAT);
X      glScalef(sphere.size, sphere.size, sphere.size);
X      glTranslatef(sphere.x/sphere.size, sphere.y/sphere.size, sphere.z/sphere.size);
X      glRotatef(sphere.rotX, 1.0, 0.0, 0.0);
X      glRotatef(sphere.rotY, 0.0, 1.0, 0.0);
X      glRotatef(sphere.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the sphere */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, sphere.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, sphere.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, sphere.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, sphere.mat.shiny);
X        
X      glutSolidSphere(0.5, 20, 20);   /*  draw the sphere       */
X      glShadeModel(GL_SMOOTH);
X    glPopMatrix();
X
X    glPushMatrix();
X      glScalef(teapot.size, teapot.size, teapot.size);
X      glTranslatef(teapot.x, teapot.y, teapot.z);
X      glRotatef(teapot.rotX, 1.0, 0.0, 0.0);
X      glRotatef(teapot.rotY, 0.0, 1.0, 0.0);
X      glRotatef(teapot.rotZ, 0.0, 0.0, 1.0);
X
X      /* set the material properties for the teapot */
X      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, teapot.mat.amb);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, teapot.mat.diff);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, teapot.mat.spec);
X      glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, teapot.mat.shiny);
X        
X      glutSolidTeapot(1.0);   /*  draw the teapot       */
X    glPopMatrix();
X
X 
X  glPopMatrix();
X  glutSwapBuffers(); 
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 20.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X  static objState *currObj = &world;
X
X  switch (key) {
X  case '0':
X    currObj = &world;
X    break;
X  case '1':
X    currObj = &sphere;
X    break;
X  case '2':
X    currObj = &cube;
X    break;
X  case '3':
X    currObj = &teapot;
X    break;
X  case 'h':
X    currObj->x -= DEF_TRANSLATE_INC;
X    break;
X  case 'l':
X    currObj->x += DEF_TRANSLATE_INC;
X    break;
X  case 'j':
X    currObj->y -= DEF_TRANSLATE_INC;
X    break;
X  case 'k':
X    currObj->y += DEF_TRANSLATE_INC;
X    break;
X  case 'i':  
X    currObj->z -= DEF_TRANSLATE_INC;
X    break;
X  case 'm':
X    currObj->z += DEF_TRANSLATE_INC;
X    break;
X  case 'x':
X    currObj->rotX -= DEF_ROTATE_INC;
X    break;
X  case 'X':
X    currObj->rotX += DEF_ROTATE_INC;
X    break;
X  case 'y':
X    currObj->rotY -= DEF_ROTATE_INC;
X    break;
X  case 'Y':
X    currObj->rotY += DEF_ROTATE_INC;
X    break;
X  case 'z':
X    currObj->rotZ -= DEF_ROTATE_INC;
X    break;
X  case 'Z':
X    currObj->rotZ += DEF_ROTATE_INC;
X    break;
X  case '+':
X    currObj->size += DEF_SCALE_INC;
X    break;
X  case '-':
X    currObj->size -= DEF_SCALE_INC;
X    break;
#ifdef DEBUG
X  case 'd':
X    fprintf(stderr, "World: %f %f %f %f %f %f\n", world.x, world.y, world.z,
X		world.rotX, world.rotY, world.rotZ);
X    fprintf(stderr, "Cube: %f %f %f %f %f %f\n", cube.x, cube.y, cube.z,
X		cube.rotX, cube.rotY, cube.rotZ);
X    fprintf(stderr, "Sphere: %f %f %f %f %f %f\n", sphere.x, sphere.y, sphere.z,
X		sphere.rotX, sphere.rotY, sphere.rotZ);
X    fprintf(stderr, "Teapot: %f %f %f %f %f %f\n", teapot.x, teapot.y, teapot.z,
X		teapot.rotX, teapot.rotY, teapot.rotZ);
X    break;
#endif
X  case 'q':	/* 'q' will exit */
X  case 27:	/* Esc will exit */
X    exit(1);
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
/* Callback for the main menu */
void
menuMain(int value)
{
X  switch (value) {
X  case 1: /* Change to single buffered mode. */
X    glutChangeToMenuEntry(1, "Set doublebuffer", 2);
X    glutHideWindow();
X    glutSetWindow(sBufWin);
X    glutShowWindow();
X    break;
X  case 2: /* Change to double buffered mode. */
X    glutChangeToMenuEntry(1, "Set singlebuffer", 1);
X    glutHideWindow();
X    glutSetWindow(dBufWin);
X    glutShowWindow();
X    break;
X  case 3:
X    resetWorld();
X    glutPostRedisplay;
X    break;
X  case 4:
X    exit(0);
X    break;
X  }
}
X
/* Callback for the Selection submenu. */
void menuSelection(int value)
{
X  switch(value) {
X  case 0:
X    Key('0', 0, 0);
X    break;
X  case 1:
X    Key('1', 0, 0);
X    break;
X  case 2:
X    Key('2', 0, 0);
X    break;
X  case 3:
X    Key('3', 0, 0);
X    break;
X  }
}
X
void printDoc(void) {
X  printf("The Selection submenu let's you choose which (or all) objects to move.\n");
X  printf("Use the set {single|double}buffer menu item to switch between single\nand double buffering.\n");
X  printf("Keys:\n");
X  printf("x = Pos. X axis rotation        X = Neg. X axis rotation\n");
X  printf("y = Pos. Y axis rotation        Y = Neg. Y axis rotation\n");
X  printf("z = Pos. Z axis rotation        Z = Neg. Z axis rotation\n");
X  printf("h = Neg. X axis translation     l = Pos. X axis translation\n");
X  printf("j = Neg. Y axis translation     k = Pos. Y axis translation\n");
X  printf("i = Neg. Z axis translation     m = Pos. Z axis translation\n");
X  printf("+ = Increase object(s) size     - = Decrease object(s) size\n");
}
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X  int menuSelectionId;
X
X  printDoc();
X  glutInit(&argc, argv);
X
X  /* Set up menu structure */
X  menuSelectionId = glutCreateMenu(menuSelection);
X  glutAddMenuEntry("All", 0);
X  glutAddMenuEntry("Sphere", 1);
X  glutAddMenuEntry("Cube", 2);
X  glutAddMenuEntry("Teapot", 3);
X  glutCreateMenu(menuMain);
X  glutAddSubMenu("Selection", menuSelectionId);
X  glutAddMenuEntry("Framebuffer: single", 1);
X  glutAddMenuEntry("Reset", 3);
X  glutAddMenuEntry("Quit", 4);
X
X  /* Set up single buffered window. */
X  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGBA);
X  sBufWin = glutCreateWindow(argv[0]);
X  glutKeyboardFunc(Key);
X  glutReshapeFunc(myReshape);
X  glutDisplayFunc(display);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X  glutHideWindow();
X
X  /* Set up double buffered window */
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X  dBufWin = glutCreateWindow(argv[0]);
X  glutKeyboardFunc(Key);
X  glutReshapeFunc(myReshape);
X  glutDisplayFunc(display);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X  /* Reset the world */
X  resetWorld();
X
X  /* We're off! */
X  glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0207102497 'proj1.c' &&
  chmod 0644 'proj1.c' ||
  $echo 'restore of' 'proj1.c' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'proj1.c:' 'MD5 check failed'
52b61eb16f199e102a8b57f5112c8643  proj1.c
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'proj1.c'`"
    test 9821 -eq "$shar_count" ||
    $echo 'proj1.c:' 'original size' '9821,' 'current size' "$shar_count!"
  fi
fi
# ============= proj1.h ==============
if test -f 'proj1.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'proj1.h' '(file already exists)'
else
  $echo 'x -' extracting 'proj1.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'proj1.h' &&
#define DEF_ROTATE_INC 15.0
#define DEF_TRANSLATE_INC 0.1
#define DEF_SCALE_INC 0.1
X
typedef struct {
X	GLfloat x;
X	GLfloat y;
X	GLfloat z;
X	GLfloat rotX;
X	GLfloat rotY;
X	GLfloat rotZ;
X	GLfloat size;
X	struct {
X		float amb[4];
X		float shiny[1];
X		float diff[4];
X		float spec[4];
X	} mat;
} objState;
SHAR_EOF
  $shar_touch -am 0206191197 'proj1.h' &&
  chmod 0664 'proj1.h' ||
  $echo 'restore of' 'proj1.h' 'failed'
  if ( md5sum --help </dev/null 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version </dev/null 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'proj1.h:' 'MD5 check failed'
59ec2c9b6a988542e005111e9e19980e  proj1.h
SHAR_EOF
  else
    shar_count="`LC_ALL=C wc -c < 'proj1.h'`"
    test 296 -eq "$shar_count" ||
    $echo 'proj1.h:' 'original size' '296,' 'current size' "$shar_count!"
  fi
fi
$echo $shar_n 'x -' 'lock directory' '_sh01078:' $shar_c
if rm -fr _sh01078; then
  $echo 'removed'
else
  $echo 'failed to remove'
fi
exit 0

From ???@??? Fri Feb 07 07:34:32 1997
Received: from straylight.diracware.com (straylight.diracware.com [38.225.157.110])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with SMTP id BAA33264;
	Fri, 7 Feb 1997 01:47:05 -0500
From: lavalj@rpi.edu (Jean-Etienne LaVallee)
To: citrit@rpi.edu
Cc: lavalj@rpi.edu
Subject: HomeWork 1
Date: Fri, 07 Feb 1997 06:45:14 GMT
Message-ID: <32face5a.358091788@mail1.its.rpi.edu>
X-Mailer: Forte Agent .99g/32.339
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 8bit
X-MIME-Autoconverted: from quoted-printable to 8bit by mail1.its.rpi.edu id BAA33264
X-UIDL: 01daa59e68e7287e3a35d0705fbd01ab

Tom,
	Couldn't FTP to campus for some reason (think it's my end,
but no sure).  So, I'm mailing this unshar'ed, sorry...

Etienne

File: hw1.c
------------------------------------

/*
 *  Advanced Graphics and Data Visualization 
 *	
 *	Home Work #1
 *
 *  Jean-Etienne LaVallee
 *
 *	Due: 2/6/97
 *
 *	Description:  OpenGL/GLUT scene showing three objects:
 *      - Sphere with solid blue rough surface
 *      - Cube with shiny red surface
 *      - Teapot with solid red surface
 *
 *  Note:  Uses Mark J. Kilgard's GLUT library as implemented under Win32
 *
 *  Compilation:  Used MS Visual C++ Developer Studio with the following
 *   LIB's linked in (Under the Build|Setting|Linking|Generl tab): 
 *           opengl32.lib, glu32.lib, glut.lib
 *
 *  Key Controls: 
 *              [Rotation/Translation]
 *
 *		  ----- ----- -----			 ---- ---- ----
 *		 | Q/U | W/I | E/O |  		| x+ | y+ | x- |
 *		  ----- ----- -----	  ==>  	 ---- ---- ----
 *		 | A/J | S/K | D/L |		| z+ | y- | z- |
 *		  ----- ----- ----- 		 ---- ---- ----
 *
 *               [Scale]
 *				',' = +
 *              '.' = -
 */

#ifdef _WIN32

#include <windows.h>

#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <GL/glut.h>


/*
 *  Structs and stuff
 */

// silly little state structure
typedef struct {
	GLdouble rx;    // x rotation
	GLdouble ry;    // y
	GLdouble rz;	// z
	GLdouble tx;	// x translation
	GLdouble ty;	// y
	GLdouble tz;	// z
	GLdouble sx;	// x scale
	GLdouble sy;	// y
	GLdouble sz;	// z
} myGLState;

/*
 *  Globals
 */

// Object State Structure  - it's almost OO
myGLState* objMove;
myGLState objCamera;
myGLState objCube;
myGLState objSphere;
myGLState objTeapot;

/*  Initialize material property and light source.
 */
void 
myinit(void)
{
    GLfloat light_ambient[] =
    {0.0, 0.0, 0.0, 1.0};
    GLfloat light_diffuse[] =
    {1.0, 1.0, 1.0, 1.0};
    GLfloat light_specular[] =
    {1.0, 1.0, 1.0, 1.0};
/* light_position is NOT default value */
    GLfloat light_position[] =
    {0.0, 3.0, 2.0, 0.0};

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);

/* Initiallize the state values */
	objMove = &objCamera;

	objCamera.rx  = 0.0;
	objCamera.ry  = 0.0;
	objCamera.rz  = 0.0;
	objCamera.tx  = 0.0;
	objCamera.ty  = 0.0;
	objCamera.tz  = 0.0;
	objCamera.sx  = 1.5;
	objCamera.sy  = 1.5;
	objCamera.sz  = 1.5;

	objCube.rx  = 0.0;
	objCube.ry  = 0.0;
	objCube.rz  = 0.0;
	objCube.tx  = 0.0;
	objCube.ty  = 0.0;
	objCube.tz  = 0.0;
	objCube.sx  = 0.7;
	objCube.sy  = 0.7;
	objCube.sz  = 0.7;

	objSphere.rx  = 0.0;
	objSphere.ry  = 0.0;
	objSphere.rz  = 0.0;
	objSphere.tx  = 2.0;
	objSphere.ty  = 0.0;
	objSphere.tz  = 0.0;
	objSphere.sx  = 0.7;
	objSphere.sy  = 0.7;
	objSphere.sz  = 0.7;

	objTeapot.rx  = 0.0;
	objTeapot.ry  = 0.0;
	objTeapot.rz  = 0.0;
	objTeapot.tx  = -2.0;
	objTeapot.ty  = 0.0;
	objTeapot.tz  = 0.0;
	objTeapot.sx  = 0.6;
	objTeapot.sy  = 0.6;
	objTeapot.sz  = 0.6;

}

void 
display(void)
{
	// Material defaults
    GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat no_shininess[] = { 0.0 };
    GLfloat cube_diffuse[] = { 0.8, 0.1, 0.1, 1.0 };
	GLfloat sphere_diffuse[] = { 0.1, 0.1, 0.8, 1.0 };
	GLfloat teapot_diffuse[] = { 0.8, 0.75, 0.2, 1.0 };
	GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat high_shininess[] = { 100.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// Draw all of the objects setting surface values as we go

    glPushMatrix();	                 // Camera
	glTranslatef(objCamera.tx, objCamera.ty, objCamera.tz);
    glScalef(objCamera.sx, objCamera.sy, objCamera.sz);
	glRotatef(objCamera.rx, 1.0, 0.0, 0.0);
	glRotatef(objCamera.ry, 0.0, 1.0, 0.0);
	glRotatef(objCamera.rz, 0.0, 0.0, 1.0);

    
	glPushMatrix();					 // Cube
	// Surface
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cube_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
	// Geometry
    glTranslatef(objCube.tx, objCube.ty, objCube.tz);
	glRotatef(objCube.rx, 1.0, 0.0, 0.0);
	glRotatef(objCube.ry, 0.0, 1.0, 0.0);
	glRotatef(objCube.rz, 0.0, 0.0, 1.0);
	glScalef(objCube.sx, objCube.sy, objCube.sz);
	glutSolidCube(1.0);
    glPopMatrix();


	glPushMatrix();					// Teapot    
	// Surface
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, teapot_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
	// Geometry
    glTranslatef(objTeapot.tx, objTeapot.ty, objTeapot.tz);
	glRotatef(objTeapot.rx, 1.0, 0.0, 0.0);
	glRotatef(objTeapot.ry, 0.0, 1.0, 0.0);
	glRotatef(objTeapot.rz, 0.0, 0.0, 1.0);
	glScalef(objTeapot.sx, objTeapot.sy, objTeapot.sz);
    glutSolidTeapot(1.0);
    glPopMatrix();


    glPushMatrix();					// Sphere
	// Surface
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, sphere_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
	// Geometry
    glTranslatef(objSphere.tx, objSphere.ty, objSphere.tz);
	glRotatef(objSphere.rx, 1.0, 0.0, 0.0);
	glRotatef(objSphere.ry, 0.0, 1.0, 0.0);
	glRotatef(objSphere.rz, 0.0, 0.0, 1.0);
	glScalef(objSphere.sx, objSphere.sy, objSphere.sz);
    glutSolidSphere(1.0, 16, 16);
    glPopMatrix();

    glPopMatrix();

    glFlush();
}

void 
myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-2.5, 2.5, -2.5 * (GLfloat) h / (GLfloat) w,
            2.5 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
    else
        glOrtho(-2.5 * (GLfloat) w / (GLfloat) h,
            2.5 * (GLfloat) w / (GLfloat) h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*
 * Keyboard handler
 */
void
key_handler(unsigned char key, int x, int y)
{
    switch (key) {
    case 'q':	// rot x+
		(*objMove).rx += 10.0;
		if( (*objMove).rx >= 360 )
			(*objMove).rx -= 360;
		break;
    case 'e':	// rot x-
		(*objMove).rx -= 10.0;
		if( (*objMove).rx < 0 )
			(*objMove).rx += 360;
		break;
    case 'a':	// rot z+
		(*objMove).rz += 10.0;
		if( (*objMove).rx >= 360 )
			(*objMove).rx -= 360;
		break;
    case 'd':	// rot z-
		(*objMove).rz -= 10.0;
        if( (*objMove).rx < 0 )
			(*objMove).rx += 360;
		break;
	case 'w':	// rot y+
		(*objMove).ry += 10.0;
		if( (*objMove).rx >= 360 )
			(*objMove).rx -= 360;
		break;
	case 's':	// rot y-
		(*objMove).ry -= 10.0;
		if( (*objMove).rx < 0 )
			(*objMove).rx += 360;
		break;
	case 'j':	// trans x+
		(*objMove).tx += 0.2;
		break;
    case 'l':	// trans x-
		(*objMove).tx -= 0.2;
		break;
    case 'u':	// trans z+
		(*objMove).tz += 0.2;
		break;
    case 'o':	// trans z-
		(*objMove).tz -= 0.2;
		break;
    case 'i':	// trans y+
		(*objMove).ty += 0.2;
		break;
    case 'k':	// trans y-
		(*objMove).ty -= 0.2;
		break;
    case ',':	// scale +
		(*objMove).sx += 0.2;
		(*objMove).sy += 0.2;
		(*objMove).sz += 0.2;
		break;
    case '.':	// scale -
		(*objMove).sx -= 0.2;
		(*objMove).sy -= 0.2;
		(*objMove).sz -= 0.2;
		break;
    case 27:           /* Esc will quit */
        exit(1);
        break;
    default:
      break;
    }
    glutPostRedisplay();
}


void
move_selection(int value)
{
	switch (value) {
	case 1:	  // Select the camera
		objMove = &objCamera;
		break;
	case 2:	  // Select the teapot
		objMove = &objTeapot;
		break;
	case 3:	  // Select the cube
		objMove = &objCube;
		break;
	case 4:	  // Select the sphere
		objMove = &objSphere;
		break;

	}
	glutPostRedisplay();
}

void 
polygon_mode(int value)
{
    switch (value) {
    case 1:		           // Show in poly mode
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
        glDisable(GL_BLEND);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        break;
    case 2:					// Show in wire mode
        glDisable(GL_DEPTH_TEST);
        glDisable(GL_LIGHTING);
        glColor3f(1.0, 1.0, 1.0);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glEnable(GL_LINE_SMOOTH);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        break;
    }
    glutPostRedisplay();
}

void 
pop_menu(int value)
{
    if (value == 666)
        exit(0);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
void 
main(int argc, char **argv)
{
    int submenu1, submenu2;

    glutInit(&argc, argv);
    glutInitWindowPosition(500, 500);
    glutInitWindowSize(600, 300);
    glutCreateWindow(argv[0]);

    myinit();
   
    glutKeyboardFunc(key_handler);
	
	glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    
	submenu1 = glutCreateMenu(polygon_mode);
    glutAddMenuEntry("Filled", 1);
    glutAddMenuEntry("Wire Frame", 2);

	submenu2 = glutCreateMenu(move_selection);
    glutAddMenuEntry("Camera", 1);
    glutAddMenuEntry("Teapot", 2);
    glutAddMenuEntry("Cube", 3);
    glutAddMenuEntry("Sphere", 4);

	glutCreateMenu(pop_menu);
    glutAddSubMenu("Polygon Mode", submenu1);
    glutAddSubMenu("Move Selection", submenu2);
	glutAddMenuEntry("Quit", 666);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
}

From ???@??? Wed Feb 12 07:08:11 1997
Received: from cii3116-12.its.rpi.edu (andret@cii3116-12.its.rpi.edu [128.113.109.137])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id QAA33130
	for <citrit@rpi.edu>; Tue, 11 Feb 1997 16:50:23 -0500
From: Thayer Andrews <andret>
Received: (andret@localhost) by cii3116-12.its.rpi.edu (8.6.9/8.6.4) id QAA21240 for citrit@rpi.edu; Tue, 11 Feb 1997 16:50:21 -0500
Date: Tue, 11 Feb 1997 16:50:21 -0500
Message-Id: <199702112150.QAA21240@cii3116-12.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 1f50cff08297458c6eaa8f8ed7a315ac

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:04 EST by <andret@rebecca.its.rpi.edu>.
# Source directory was `/afs/rpi.edu/home/70/andret/agfx'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  14578 -rw------- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh25285; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/*
X *
X * FILE: hw1.c
X * AUTHOR: Thayer Andrews
X * DATE: February 6, 1997
X *
X * Advanced Graphics homework 1
X * 
X */
X
#include <stdlib.h>
X
#ifdef _WIN32
#include <windows.h>
#endif
X
#include <GL/gl.h>
#include <GL/glut.h>
#include <math.h>
X
#define TRUE                1
#define FALSE               0
X
/*transformation increments used by the mouseMove function
X  to transform the currently selected object*/
#define TRANSLATE_INCR      0.1
#define ROTATE_INCR         5
#define SCALE_INCR          0.95
X
/*possible menu selections*/
#define ROTATE_SPHERE       1
#define SCALE_SPHERE        2
#define TRANSLATE_SPHERE    3
#define ROTATE_CUBE         4 
#define SCALE_CUBE          5
#define TRANSLATE_CUBE      6
#define ROTATE_TEAPOT       7
#define SCALE_TEAPOT        8
#define TRANSLATE_TEAPOT    9
#define CAMERA	            10
#define TRANSPARENT_TEAPOT  11
#define TOGGLE_SPHERE       12
#define TOGGLE_CUBE         13
#define TOGGLE_TEAPOT       14
#define QUIT                666
X
X
/*
X * object information structure containing all information
X * about an object's position, size, orientation and material.
X */
typedef struct _objectInfo
{
X  /*specify object position*/
X  GLfloat xPos;
X  GLfloat yPos;
X  GLfloat zPos;
X  
X  /*specify object orientation (in degrees)*/
X  GLfloat xAngle;
X  GLfloat yAngle;
X  GLfloat zAngle;
X  
X  /*specify object scale factors*/
X  GLfloat xScale;
X  GLfloat yScale;
X  GLfloat zScale;
X
X  /*float arrays to store material properties*/
X  GLfloat diffuse[4];
X  GLfloat ambient[4];
X  GLfloat specular[4];
X  GLfloat shininess[1];
X
} objectInfo;
X
X
/*Create global state structs for the cube, sphere, teapot and camera*/
objectInfo cubeInfo, sphereInfo, potInfo, cameraInfo;
X
/*more globals...*/
int selected = CAMERA;
int transparentTeapot = FALSE, sphereHidden = FALSE,
X    cubeHidden = FALSE, teapotHidden = FALSE;
GLsizei windowWidth, windowHeight;
X
X
/*
X * display function is responsible for translating geometry and drawing
X * it to the screen.
X */
void display(void)
{   
X  /*enable face culling to speed performance*/
X  glEnable(GL_CULL_FACE);
X  glCullFace(GL_BACK);
X  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X
X  /*Camera transformations*/
X  glMatrixMode(GL_PROJECTION);
X  glLoadIdentity();
X  gluPerspective(45.0,1.0*(GLfloat)windowWidth/(GLfloat)windowHeight,1.0,10.0);
X  glTranslatef(cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos);
X  glRotatef(cameraInfo.xAngle,1.0,0.0,0.0);
X  glRotatef(cameraInfo.yAngle,0.0,1.0,0.0);
X  
X  /*From now on we play with the modelview matrix...*/
X  glMatrixMode(GL_MODELVIEW);
X  glLoadIdentity();
X
X  if(!cubeHidden)
X  {
X    glPushMatrix();
X      /*position, scale and orient the cube*/
X      glTranslatef(cubeInfo.xPos, cubeInfo.yPos, cubeInfo.zPos);
X      glScalef(cubeInfo.xScale, cubeInfo.xScale, cubeInfo.xScale);
X      glRotatef(cubeInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(cubeInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(cubeInfo.zAngle,0.0,0.0,1.0);
X    
X     /*set material properties for and draw the cube*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, cubeInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, cubeInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, cubeInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, cubeInfo.shininess);
X      glutSolidCube(1.0);
X      glPopMatrix();
X  }
X
X  if(!sphereHidden)
X  {
X    glPushMatrix();
X      /*position, scale and orient the sphere*/ 
X      glTranslatef(sphereInfo.xPos, sphereInfo.yPos, sphereInfo.zPos);
X      glScalef(sphereInfo.xScale, sphereInfo.xScale, sphereInfo.xScale);
X      glRotatef(sphereInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(sphereInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(sphereInfo.zAngle,0.0,0.0,1.0);
X    
X      /*set material properties for and draw the sphere*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, sphereInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, sphereInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, sphereInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, sphereInfo.shininess);
X      glutSolidSphere(0.5,10,10);
X    glPopMatrix();
X  }
X
X
X  if(!teapotHidden)
X  {
X    /*If transparency is enabled, enable blending and switch the 
X      z-buffer to read only mode to allow the teapot to be transparent.*/
X    if(transparentTeapot)
X    {
X      glEnable(GL_BLEND);
X      glDepthMask(GL_FALSE);
X      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
X    }
X  
X    /*Switch off face culling for the teapot since the faces seem to be defined
X      backwards so front facing polygons are culled when glCullFace(GL_BACK) is
X      called.  Weird...*/
X    glDisable(GL_CULL_FACE);
X    
X    glPushMatrix();
X      /*position, scale and orient the teapot*/ 
X      glTranslatef(potInfo.xPos, potInfo.yPos, potInfo.zPos);
X      glScalef(potInfo.xScale, potInfo.xScale, potInfo.xScale);
X      glRotatef(potInfo.xAngle,1.0,0.0,0.0);
X      glRotatef(potInfo.yAngle,0.0,1.0,0.0);
X      glRotatef(potInfo.zAngle,0.0,0.0,1.0);
X    
X      /*set material properties for and draw the teapot*/
X      glMaterialfv(GL_FRONT, GL_AMBIENT, potInfo.ambient); 
X      glMaterialfv(GL_FRONT, GL_DIFFUSE, potInfo.diffuse);
X      glMaterialfv(GL_FRONT, GL_SPECULAR, potInfo.specular);
X      glMaterialfv(GL_FRONT, GL_SHININESS, potInfo.shininess);
X      glutSolidTeapot(0.5);
X    glPopMatrix();
X
X    /*now turn off blending and switch z-buffer back to 
X      read/write mode and re-enable culling*/
X    glDepthMask(GL_TRUE); 
X    glDisable(GL_BLEND);
X    glEnable(GL_CULL_FACE);
X  }
X
X  /*force completion of drawing and swap front and back buffers*/
X  glFlush();
X  glutSwapBuffers ();
}
X
X
X
/*
X * initialize lights and object attributes
X */
void myinit (void)
{  
X  /*define light parameters*/
X  float light0Pos[4] = {2.0, 4.0, 2.0, 1.0};
X  float light0Dir[4] = {-2.0, -4.0, -2.0, 1.0};
X  float light0Amb[4] = {0.7, 0.7, 0.7, 1.0};
X  float light0Diff[4] = {0.8, 0.8, 0.8, 1.0};
X  float light0Spec[4] = {0.8, 0.8, 0.8, 1.0};
X
X  /*clear to black when glClear() is called*/
X  glClearColor (0.0, 0.0, 0.0, 1.0);
X  
X  /*enable lighting and set GL_LIGHT0 params to defined values*/
X  glEnable(GL_LIGHTING);
X  glEnable(GL_LIGHT0);
X  glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
X  glLightfv(GL_LIGHT0, GL_AMBIENT, light0Amb);
X  glLightfv(GL_LIGHT0, GL_DIFFUSE, light0Diff);
X  glLightfv(GL_LIGHT0, GL_SPECULAR, light0Spec);
X
X  glEnable(GL_DEPTH_TEST);
X  glShadeModel(GL_SMOOTH);
X
X  /*set initial position and orientation for sphere*/
X  sphereInfo.xPos = 2.0; sphereInfo.yPos = 0.0; sphereInfo.zPos = 0.0;
X  sphereInfo.xAngle = 0.0; sphereInfo.yAngle = 0.0; sphereInfo.zAngle = 0.0;
X  sphereInfo.xScale = 1.0; sphereInfo.yScale = 1.0; sphereInfo.zScale = 1.0;
X
X  /*set material properties for the sphere*/
X  sphereInfo.diffuse[0] = 0.0; 
X  sphereInfo.diffuse[1] = 0.0; 
X  sphereInfo.diffuse[2] = 0.8; 
X  sphereInfo.diffuse[3] = 1.0;
X
X  sphereInfo.ambient[0] = 0.0;
X  sphereInfo.ambient[1] = 0.0;
X  sphereInfo.ambient[2] = 0.4;
X  sphereInfo.ambient[3] = 1.0;
X
X  sphereInfo.specular[0] = 0.0;
X  sphereInfo.specular[1] = 0.0;
X  sphereInfo.specular[2] = 0.3;
X  sphereInfo.specular[3] = 1.0;
X
X  sphereInfo.shininess[0] = 0.0;
X
X
X  /*set position and orientation of the cube*/
X  cubeInfo.xPos = 0.0; cubeInfo.yPos = 0.0; cubeInfo.zPos = 0.0;
X  cubeInfo.xAngle = 0.0; cubeInfo.yAngle = 0.0; cubeInfo.zAngle = 0.0;
X  cubeInfo.xScale = 1.0; cubeInfo.yScale = 1.0; cubeInfo.zScale = 1.0;
X
X  /*set material properties for the cube*/
X  cubeInfo.diffuse[0] = 0.8; 
X  cubeInfo.diffuse[1] = 0.0; 
X  cubeInfo.diffuse[2] = 0.0; 
X  cubeInfo.diffuse[3] = 1.0;
X
X  cubeInfo.ambient[0] = 0.4;
X  cubeInfo.ambient[1] = 0.0;
X  cubeInfo.ambient[2] = 0.0;
X  cubeInfo.ambient[3] = 1.0;
X
X  cubeInfo.specular[0] = 0.8;
X  cubeInfo.specular[1] = 0.8;
X  cubeInfo.specular[2] = 0.8;
X  cubeInfo.specular[3] = 1.0;
X
X  cubeInfo.shininess[0] = 100.0;
X
X  /*set position and orienation of the tea pot*/
X  potInfo.xPos = -2.0; potInfo.yPos = 0.0; potInfo.zPos = 0.0;
X  potInfo.xAngle = 0.0; potInfo.yAngle = 0.0; potInfo.zAngle = 0.0;
X  potInfo.xScale = 1.0; potInfo.yScale = 1.0; potInfo.zScale = 1.0;
X
X  /*set material properties for the cube*/
X  potInfo.diffuse[0] = 0.8; 
X  potInfo.diffuse[1] = 0.8; 
X  potInfo.diffuse[2] = 0.0; 
X  potInfo.diffuse[3] = 0.6;
X
X  potInfo.ambient[0] = 0.4;
X  potInfo.ambient[1] = 0.4;
X  potInfo.ambient[2] = 0.0;
X  potInfo.ambient[3] = 0.6;
X
X  potInfo.specular[0] = 0.3;
X  potInfo.specular[1] = 0.3;
X  potInfo.specular[2] = 0.0;
X  potInfo.specular[3] = 0.6;
X
X  potInfo.shininess[0] = 100.0;
X
X  /*set position and orientation of the camera*/
X  cameraInfo.xPos = 0.0; cameraInfo.yPos = 0.0; cameraInfo.zPos = -8.0;
X  cameraInfo.xAngle = 0.0; cameraInfo.yAngle = 0.0; cameraInfo.zAngle = 0.0;
X  cameraInfo.xScale = 1.0; cameraInfo.yScale = 1.0; cameraInfo.zScale = 1.0;
}
X
X
/*
X * handle window resize and expose events
X */
void myReshape(GLsizei w, GLsizei h)
{
X  /*save the window size in these globals for use
X    in the display function*/
X  windowWidth = w; 
X  windowHeight = h;
X  
X  glViewport(0, 0, w, h);
X  glMatrixMode(GL_PROJECTION);
X  glLoadIdentity();
X  gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X  glTranslatef(cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos);
X  glRotatef(cameraInfo.xAngle,1.0,0.0,0.0);
X  glRotatef(cameraInfo.yAngle,0.0,1.0,0.0);
X  glMatrixMode(GL_MODELVIEW);
X  glLoadIdentity ();
}
X
X
/*
X * Handle pop-up menu events.  Perform transparency and hidden object
X * toggling directly otherwise just assign the input parameter to selected
X * and let the mouse movement callback handle rotation, scaling and 
X * translation.
X */
void
Select(int value)
{
X
X  /*exit when user selects quit*/
X  if(value == QUIT)
X    exit(0);
X  /*if user toggles transparency, invert current transparency state
X    and force redraw*/
X  else if(value == TRANSPARENT_TEAPOT)
X  {
X    if(transparentTeapot)
X      transparentTeapot = FALSE;
X    else 
X      transparentTeapot = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_SPHERE)
X  {
X    if(sphereHidden)
X      sphereHidden = FALSE;
X    else 
X      sphereHidden = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_CUBE)
X  {
X    if(cubeHidden)
X      cubeHidden= FALSE;
X    else 
X      cubeHidden = TRUE;
X    glutPostRedisplay();
X  }
X  else if(value == TOGGLE_TEAPOT)
X  {
X    if(teapotHidden)
X      teapotHidden = FALSE;
X    else 
X      teapotHidden = TRUE;
X    glutPostRedisplay();
X  }
X  /*...otherwise, set selected global to menu option value*/
X  else
X    selected = value;
}
X
X
/*
X * keys function scales, rotates and translates the
X * currently selected object.
X */ 
void keys(unsigned char key, int x, int y)
{
X
X  GLint deltaX = 0, deltaY = 0;
X  
X  
X  switch(key)
X  {
X  case 'h':
X    deltaX = -1;
X    break;
X  case 'j':
X    deltaX = 1;
X    break;
X  case 'k':
X    deltaY = -1;
X    break;
X  case 'l':
X    deltaY = 1;
X    break;
X  }
X
X  /*as mouse movement callbacks are generated, switch based on the 
X    selected action and execute it*/
X  switch(selected) {
X  case ROTATE_SPHERE:
X    sphereInfo.yAngle += (deltaX*ROTATE_INCR);
X    sphereInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_SPHERE:
X    if(deltaX < 0)
X      sphereInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      sphereInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_SPHERE:
X    sphereInfo.xPos += (deltaX*TRANSLATE_INCR);
X    sphereInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X
X  case ROTATE_CUBE:
X    cubeInfo.yAngle += (deltaX*ROTATE_INCR);
X    cubeInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_CUBE:
X    if(deltaX < 0)
X      cubeInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      cubeInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_CUBE:
X    cubeInfo.xPos += (deltaX*TRANSLATE_INCR);
X    cubeInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X
X  case ROTATE_TEAPOT:
X    potInfo.yAngle += (deltaX*ROTATE_INCR);
X    potInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  case SCALE_TEAPOT:
X    if(deltaX < 0)
X      potInfo.xScale *= SCALE_INCR;
X    else if(deltaX > 0)
X      potInfo.xScale /= SCALE_INCR;
X    break;
X  case TRANSLATE_TEAPOT:
X    potInfo.xPos += (deltaX*TRANSLATE_INCR);
X    potInfo.yPos -= (deltaY*TRANSLATE_INCR);
X    break;
X    
X  case CAMERA:
X    cameraInfo.yAngle += (deltaX*ROTATE_INCR);
X    cameraInfo.xAngle += (deltaY*ROTATE_INCR);
X    break;
X  }
X  
X  /*force redraw of buffers*/
X  glutPostRedisplay();
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv)
{
X  /*menu id's used below*/
X  int sphereMenu, cubeMenu, potMenu; 
X
X  glutInit(&argc, argv);
X  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X  glutInitWindowSize (500, 500);
X  glutCreateWindow (argv[0]);
X    
X
X  /*print help messages*/
X  printf("\n\nTo select an action use the right mouse button.\n");
X  printf("Keys:\n");
X  printf("h and j: Transform about/along x-axis\n");
X  printf("k and l: Transform about/along y-axis\n");
X
X  /*initialize stuff*/
X  myinit ();
X    
X  glutDisplayFunc(display);
X  glutReshapeFunc (myReshape);
X  glutIdleFunc (NULL);
X
X  /*
X   * Setup a pop-up menu and bind it to the right
X   * mouse button.  Start by defining the sphere 
X   * submenu
X   */
X  sphereMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Sphere", TOGGLE_SPHERE);
X  glutAddMenuEntry("Rotate Sphere",ROTATE_SPHERE);
X  glutAddMenuEntry("Scale Sphere", SCALE_SPHERE);
X  glutAddMenuEntry("Translate Sphere", TRANSLATE_SPHERE);
X  /*...now define the cube submenu...*/
X  cubeMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Cube", TOGGLE_CUBE);
X  glutAddMenuEntry("Rotate Cube",ROTATE_CUBE);
X  glutAddMenuEntry("Scale Cube", SCALE_CUBE);
X  glutAddMenuEntry("Translate Cube", TRANSLATE_CUBE);
X  /*...now define the teapot submenu...*/
X  potMenu = glutCreateMenu(Select);
X  glutAddMenuEntry("Toggle Teapot", TOGGLE_TEAPOT);
X  glutAddMenuEntry("Rotate Teapot",ROTATE_TEAPOT);
X  glutAddMenuEntry("Scale Teapot", SCALE_TEAPOT);
X  glutAddMenuEntry("Translate Teapot", TRANSLATE_TEAPOT);
X  /*...now create the main pop-up menu and add the three
X    submenus to it*/
X  glutCreateMenu(Select);
X  glutAddSubMenu("Sphere",sphereMenu);
X  glutAddSubMenu("Cube", cubeMenu);
X  glutAddSubMenu("Teapot", potMenu);
X  /*...finally add two more entries to the main menu
X    and bind it to the right mouse button.*/
X  glutAddMenuEntry("Move Camera", CAMERA);
X  glutAddMenuEntry("Toggle Teapot Transparency", TRANSPARENT_TEAPOT);
X  glutAddMenuEntry("Quit", QUIT);
X  glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X  /*bind keyboard events to the keys() function*/
X  glutKeyboardFunc(keys);
X  
X  /*start the main loop*/
X  glutMainLoop();
}
SHAR_EOF
  $shar_touch -am 0206190397 'hw1.c' &&
  chmod 0600 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
a3719fcf6744aef2acaa49124f27b2d8  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 14578 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '14578,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh25285
exit 0

From ???@??? Wed Feb 12 07:08:17 1997
Received: from marcus.its.rpi.edu (clarkl@marcus.its.rpi.edu [128.113.113.16])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id SAA40954
	for <citrit@rpi.edu>; Tue, 11 Feb 1997 18:36:32 -0500
From: Landon David Clark <clarkl>
Received: (clarkl@localhost) by marcus.its.rpi.edu (8.6.9/8.6.4) id SAA104594 for citrit@rpi.edu; Tue, 11 Feb 1997 18:36:31 -0500
Date: Tue, 11 Feb 1997 18:36:31 -0500
Message-Id: <199702112336.SAA104594@marcus.its.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1
X-UIDL: 912da6e1d5da0f9f44b0b4bac843586b

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-06 19:49 EST by <clarkl@marcus>.
# Source directory was `/afs/rpi.edu/home/92/clarkl/advgra/temp'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    898 -rw-r--r-- Makefile.sgi
#   8946 -rw-r--r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh52801; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile.sgi ==============
if test -f 'Makefile.sgi' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile.sgi' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile.sgi' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile.sgi' &&
#
# Sample Makefile for compilling the sample code for the
# Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)
#
# Copy this to the directory where the program resides and use
#  
#       make progname
#
# The progname would be the prefix of the source file you generated.
# Like if your source file was hw1.c, the above line would read:
#
#       make hw1
#
# The make utility would automatically look for something with a suffix
# it understood and would find hw1.c. There are built in rules which
# tell it how to compile c source.
#
X
LDFLAGS= -L/campus/visualization/mesa-ogl/1.2.7/@sys/lib \
X	 -lGL -lGLU -lMesaaux -lMesatk -lglut -lXmu -lXt -lX11 -lm
CFLAGS= -g -I/campus/visualization/mesa-ogl/1.2.7/@sys/include/glut
CC=cc
X
TARGET = simple
X
$(TARGET): $(TARGET).o
X	$(CC) -o $@ $? $(LDFLAGS)
X
lorenz:    lorenz.o
X	$(CC) $(CFLAGS) -o $@ $? $(LIBS)
X
clean:
X	/bin/rm -f *.o
SHAR_EOF
  $shar_touch -am 0206194597 'Makefile.sgi' &&
  chmod 0644 'Makefile.sgi' ||
  $echo 'restore of' 'Makefile.sgi' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile.sgi:' 'MD5 check failed'
a911ac703d77657be3fecce582d7478a  Makefile.sgi
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile.sgi'`"
    test 898 -eq "$shar_count" ||
    $echo 'Makefile.sgi:' 'original size' '898,' 'current size' "$shar_count!"
  fi
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* Landon Clark */
/* Adv. Computer Graphics */
/* HW1 */
X
X
X
/* Includes required */
#include <GL/gl.h>
#include <GL/glut.h>
X
float cub_x_trans = 0, cub_y_trans = 0, cub_z_trans = 0; /* Placement of the square */  
float cub_x_spin=0, cub_y_spin=0;
float cub_sca = 1.0;
float tea_x_trans = -2, tea_y_trans = 0, tea_z_trans = 0; /* Placement of the square */  
float tea_x_spin=0, tea_y_spin=0;
float tea_sca = 0.6;
float sph_x_trans = 2, sph_y_trans = 0, sph_z_trans = 0; /* Placement of the square */  
float sph_x_spin=0, sph_y_spin=0;
float sph_sca = .6;
/*
X *  Clear the screen.  Set the current color to white.
X *  Draw the cube.
X */
void display(void)
{
X  GLfloat color_sph[] = { 0.0, 0.0, 1.0, 1.0 };
X  GLfloat color_tea[] = { .4, .4, 0.0, .25 };
X  GLfloat color_cub[] = { 1.0, 0.0, 0.0, 1.0 };
X
X  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
X
X  glPushMatrix();
X  glTranslatef(cub_x_trans, cub_y_trans, cub_z_trans);
X  glRotatef(cub_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(cub_y_spin, 0.0, 1.0, 0.0);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 100.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_cub);
X  glutSolidCube(cub_sca);   /*  draw the cube       */
X  glPopMatrix();
X
X  glPushMatrix();
X  glTranslatef(tea_x_trans, tea_y_trans, tea_z_trans); 
X  glRotatef(tea_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(tea_y_spin, 0.0, 1.0, 0.0);
X  glColor4f(0.0, 0.0, 0.0, .25);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_tea);
X  glutSolidTeapot(tea_sca);   /*  draw the teapot       */
X  glPopMatrix();
X
X  glPushMatrix();
X  glTranslatef(sph_x_trans, sph_y_trans, sph_z_trans);
X  glRotatef(sph_x_spin, 1.0, 0.0, 0.0);
X  glRotatef(sph_y_spin, 0.0, 1.0, 0.0);
X  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0);
X  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, color_sph);
X  glutSolidSphere(sph_sca, 100, 100);   /*  draw the teapot       */
X  glPopMatrix();
X
X  glutSwapBuffers(); 
}
X
/* Initialize shading model */
void myInit(void)
{
X      static float lightPos[4] = {2.0, 4.0, 2.0, 1.0};
X      static float lightDir[4] = {-2.0, -4.0, -2.0, 1.0};
X      static float lightAmb[4] = {0.7, 0.7, 0.7, 1.0};
X      static float lightDiff[4] = {0.8, 0.8, 0.8, 1.0};
X      static float lightSpec[4] = {0.4, 0.4, 0.4, 1.0};
X
X      glColor4f(1.0, 0.0, 0.0, .75);
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
X      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
X      glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
X      glEnable(GL_DITHER); 
X      glEnable(GL_DEPTH_TEST);
X      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
/*      glShadeModel (GL_FLAT);
*     glClearColor (0.0, 0.0, 0.0, 0.0);
X */
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X      glTranslatef (0.0, 0.0, -5.0);     /*  viewing transformation      */
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'h':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 0.0,1.0,0.0);
X      break;
X    case 'j':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(15.0, 1.0,0.0,0.0);
X      break;
X    case 'k':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 1.0,0.0,0.0);
X      break;
X    case 'l':
X      glMatrixMode (GL_MODELVIEW);        /* manipulate modelview matrix  */
X      glRotatef(-15.0, 0.0,1.0,0.0);
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
/*
X *  Handle Menus
X */
void
Select(int value)
{
X    switch (value) {
X    case 1:
X        exit(0);
X        break;
X    case 2:
X	glutKeyboardFunc(Key);
X	break;
X    default:
X	break;
X      }
}
X
void key_cub_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_y_spin+=15;
X    break;
X  case 'j':
X    cub_x_spin+=15;
X    break;
X  case 'k':
X    cub_x_spin+=-15;
X    break;
X  case 'l':
X    cub_y_spin+=-15;
X    break;
X  }
X  if (cub_x_spin > 360)
X    cub_x_spin -= 360;
X  if (cub_y_spin > 360)
X    cub_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_tea_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_y_spin+=15;
X    break;
X  case 'j':
X    tea_x_spin+=15;
X    break;
X  case 'k':
X    tea_x_spin+=-15;
X    break;
X  case 'l':
X    tea_y_spin+=-15;
X    break;
X  }
X  if (tea_x_spin > 360)
X    tea_x_spin -= 360;
X  if (tea_y_spin > 360)
X    tea_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_sph_rot(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_y_spin+=15;
X    break;
X  case 'j':
X    sph_x_spin+=15;
X    break;
X  case 'k':
X    sph_x_spin+=-15;
X    break;
X  case 'l':
X    sph_y_spin+=-15;
X    break;
X  }
X  if (sph_x_spin > 360)
X    sph_x_spin -= 360;
X  if (sph_y_spin > 360)
X    sph_y_spin -= 360;
X  glutPostRedisplay();
}
X
void key_cub_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_sca += 1.0;
X    break;
X  case 'j':
X    cub_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_tea_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_sca += 1.0;
X    break;
X  case 'j':
X    tea_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_sph_sca(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_sca += 1.0;
X    break;
X  case 'j':
X    sph_sca -= 1.0;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_cub_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    cub_x_trans -= .5;
X    break;
X  case 'y':
X    cub_x_trans += .5;
X    break;
X  case 'u':
X    cub_y_trans += .5;
X    break;
X  case 'j':
X    cub_y_trans -= .5;
X    break;
X  case 'i':
X    cub_z_trans += .5;
X    break;
X  case 'k':
X    cub_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_tea_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    tea_x_trans -= .5;
X    break;
X  case 'y':
X    tea_x_trans += .5;
X    break;
X  case 'u':
X    tea_y_trans += .5;
X    break;
X  case 'j':
X    tea_y_trans -= .5;
X    break;
X  case 'i':
X    tea_z_trans += .5;
X    break;
X  case 'k':
X    tea_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void key_sph_mov(unsigned char key, int x, int y)
{
X  switch (key) {
X  case 'h':
X    sph_x_trans -= .5;
X    break;
X  case 'y':
X    sph_x_trans += .5;
X    break;
X  case 'u':
X    sph_y_trans += .5;
X    break;
X  case 'j':
X    sph_y_trans -= .5;
X    break;
X  case 'i':
X    sph_z_trans += .5;
X    break;
X  case 'k':
X    sph_z_trans -= .5;
X    break;
X  default:
X    break;
X  }
X  glutPostRedisplay();
}
X
void cub_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_cub_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_cub_sca);
X  break;
X
X case 3:
X  glutKeyboardFunc(key_cub_mov);
X  break;
X   }
X
}
X
void tea_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_tea_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_tea_sca);
X  break;
X
X case 3:
X  glutKeyboardFunc(key_tea_mov);
X  break;
X   } 
}
X
void sph_menu(int item)
{
X  switch (item) {
X  case 1:
X  glutKeyboardFunc(key_sph_rot); 
X  break;
X
X case 2:
X  glutKeyboardFunc(key_sph_sca);
X  break;
X case 3:
X  glutKeyboardFunc(key_sph_mov);
X  break;  
X   }
X
}
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) 
{
X      int tea, cub, sph;  /*Sub Menus */
X
X      glutInit(&argc, argv);
X      glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X      glutInitWindowSize(750, 300);
X      glutCreateWindow (argv[0]);
X      myInit ();
X      glutReshapeFunc (myReshape);
X      glutDisplayFunc(display);
X
X      cub = glutCreateMenu(cub_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      tea = glutCreateMenu(tea_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      sph = glutCreateMenu(sph_menu);
X      glutAddMenuEntry("Rotate", 1);
X      glutAddMenuEntry("Scale", 2);
X      glutAddMenuEntry("Move", 3);
X
X      glutCreateMenu(Select);
X      glutAddMenuEntry("Quit", 1);
X      glutAddMenuEntry("ViewPoint", 2);
X      glutAddSubMenu("Cube", cub);
X      glutAddSubMenu("Teapot", tea);
X      glutAddSubMenu("Sphere", sph);
X
X      glutAttachMenu(GLUT_RIGHT_BUTTON);
X      glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0206194497 'hw1.c' &&
  chmod 0644 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
fbb0dff2c098acbe389341e70b0d9a44  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 8946 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '8946,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh52801
exit 0

From ???@??? Fri Feb 14 07:43:24 1997
Received: from cortez.sss.rpi.edu (tulumg@cortez.sss.rpi.edu [128.113.113.33])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id RAA64458
	for <citrit@rpi.edu>; Thu, 13 Feb 1997 17:10:49 -0500
From: "Gregory C. Tulumbas" <tulumg>
Received: (tulumg@localhost) by cortez.sss.rpi.edu (8.6.9/8.6.4) id RAA104462 for citrit@rpi.edu; Thu, 13 Feb 1997 17:10:48 -0500
Date: Thu, 13 Feb 1997 17:10:48 -0500
Message-Id: <199702132210.RAA104462@cortez.sss.rpi.edu>
To: citrit@rpi.edu
Subject: HomeWork 1 (again)
X-UIDL: 5a31151a14ed417b7019ab8745243faf

#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-02-13 17:09 EST by <tulumg@cortez>.
# Source directory was `/afs/rpi.edu/home/05/tulumg/private/gl'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   5628 -rw-rw-r-- hw1.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh114546; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= hw1.c ==============
if test -f 'hw1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'hw1.c' '(file already exists)'
else
  $echo 'x -' extracting 'hw1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'hw1.c' &&
/* Gregory C. Tulumbas  - Homework #1 */
X
X
#ifdef _WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glut.h>
X
X
typedef struct {
X	GLfloat		dx;
X	GLfloat		dy;
X	GLfloat		dz;
X	
X	GLfloat		xangle;
X	GLfloat		yangle;
X	GLfloat		zangle;
X
X	GLfloat		c_diff[4];
X	GLfloat		c_spec[4];
X
X	GLfloat		shiny;
} ObjState;
X
ObjState cube;
ObjState sphere;
ObjState teapot;
ObjState camera;
X
ObjState *curr;
X
X
void display(void)
{
X      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
X	  
X	  /* Change camera angle */
X	  glMatrixMode(GL_PROJECTION);
X	  glPushMatrix();
X	    glRotatef(camera.xangle, 1.0, 0.0, 0.0);
X	    glRotatef(camera.yangle, 0.0, 1.0, 0.0);
X
X	    glMatrixMode (GL_MODELVIEW);
X	  
X	    /* Draw sphere */
X	    glPushMatrix();
X	     glTranslatef(sphere.dx, sphere.dy, sphere.dz);
X  	     glRotatef(sphere.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(sphere.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,sphere.c_diff);
X	     glMaterialfv(GL_FRONT,GL_SPECULAR, sphere.c_spec);
X	     glutSolidSphere(1.0, 10, 10);
X	    glPopMatrix();
X
X	    /* Draw teapot */
X	    glPushMatrix();
X	     glTranslatef(teapot.dx, teapot.dy, teapot.dz);	   
X	     glRotatef(teapot.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(teapot.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,teapot.c_diff); 
X	     glutSolidTeapot(0.75);
X	    glPopMatrix();
X
X        /* Draw cube */
X	    glPushMatrix();
X	     glTranslatef(cube.dx, cube.dy, cube.dz);	   
X	     glRotatef(cube.xangle, 1.0, 0.0, 0.0);
X	     glRotatef(cube.yangle, 0.0, 1.0, 0.0);
X	     glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,cube.c_diff);
X	     glMaterialfv(GL_FRONT,GL_SPECULAR, cube.c_spec);
X	     glMaterialf(GL_FRONT,GL_SHININESS,cube.shiny);
X	     glutSolidCube(1.0);
X	    glPopMatrix();
X
X	  glMatrixMode(GL_PROJECTION);
X	  glPopMatrix();
X
X      glutSwapBuffers(); 
}
X
void myInit(void)
{
X      static float lightPos[4] = {2.0, 2.0, 3.0, 1.0};
X
X	  /* Initialize lighting & shading model */
X      glEnable(GL_LIGHTING);
X      glEnable(GL_LIGHT0);
X      glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
X      glEnable(GL_DEPTH_TEST);
X	  glShadeModel (GL_SMOOTH);
X
X	  /* Initialize objects */
X	  cube.dx = 0.0;
X	  cube.dy = 0.0;
X	  cube.dz = 0.0;
X	  cube.xangle = 0.0;
X	  cube.yangle = 0.0;
X	  cube.zangle = 0.0;
X	  cube.c_diff[0] = 1.0;
X	  cube.c_diff[1] = 0.0;
X	  cube.c_diff[2] = 0.0;
X	  cube.c_diff[3] = 1.0;
X	  cube.c_spec[0] = 0.8;
X	  cube.c_spec[1] = 0.8; 
X	  cube.c_spec[2] = 0.8;
X	  cube.c_spec[3] = 1.0;
X	  cube.shiny = 10.0;
X
X	  sphere.dx = 2.0;
X	  sphere.dy = 0.0;
X	  sphere.dz = 0.0;
X	  sphere.xangle = 0.0;
X	  sphere.yangle = 0.0;
X	  sphere.zangle = 0.0;
X	  sphere.c_diff[0] = 0.0;
X	  sphere.c_diff[1] = 0.0;
X	  sphere.c_diff[2] = 1.0;
X	  sphere.c_diff[3] = 1.0;
X	  sphere.c_spec[0] = 0.0;
X	  sphere.c_spec[1] = 0.0;
X	  sphere.c_spec[2] = 0.0;
X	  sphere.c_spec[3] = 1.0;
X
X
X	  teapot.dx = -2.0;
X	  teapot.dy = 0.0;
X	  teapot.dz = 0.0;
X	  teapot.xangle = 0.0;
X	  teapot.yangle = 0.0;
X	  teapot.zangle = 0.0;
X	  teapot.c_diff[0] = 1.0;
X	  teapot.c_diff[1] = 1.0;
X	  teapot.c_diff[2] = 0.0;
X	  teapot.c_diff[3] = 1.0;
X	  teapot.c_spec[0] = 0.0;
X	  teapot.c_spec[1] = 0.0;
X	  teapot.c_spec[2] = 0.0;
X	  teapot.c_spec[3] = 1.0;
X
X	  camera.xangle = 0.0;
X	  camera.yangle = 0.0;
X	  camera.zangle = 0.0;
X
X	  curr = &cube;
}
X
X
/*
X * Keyboard handler
X */
void
Key(unsigned char key, int x, int y)
{
X    switch (key) {
X    case 'a':
X      curr->xangle = curr->xangle - 10 % 360;
X      break;
X    case 'z':
X      curr->xangle = curr->xangle + 10 % 360; 
X      break;
X    case 'k':
X      curr->yangle = curr->yangle - 10 % 360;
X      break;
X    case 'l':
X      curr->yangle = curr->yangle + 10 % 360;
X      break;
X    case 27:           /* Esc will quit */
X        exit(1);
X        break;
X    default:
X      break;
X    }
X    glutPostRedisplay();
}
X
X
/*
X *  Handle Menus
X */
void Select(int value){
X    switch (value) {
X	case 1:
X	    curr = &cube;
X		break;
X	case 2:
X		curr = &sphere;
X		break;
X	case 3:
X		curr = &teapot;
X		break;
X	case 4:
X		curr = &camera;
X		break;
X	case 5:
X		myInit();
X	    glutPostRedisplay();
X		break;
X    case 20:
X        exit(0);
X        break;
X    }
}
X
/*
X *  Called when the window is first opened and whenever 
X *  the window is reconfigured (moved or resized).
X */
void myReshape(int w, int h)
{
X      glViewport (0, 0, w, h);            /*  define the viewport */
X      glMatrixMode(GL_PROJECTION);
X      glLoadIdentity();
X      gluPerspective(45.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 10.0);
X	  glTranslatef (0.0, 0.0, -9.0);     /*  viewing transformation      */
X	  glPushMatrix();
X      glMatrixMode (GL_MODELVIEW);        /* back to modelview matrix  */
}
X
X
/*
X *  Main Loop
X *  Open window with initial window size, title bar, 
X *  RGBA display mode, and handle input events.
X */
int main(int argc, char** argv) {
X
X printf("Project #1: Teapot, Cube & Sphere\n");
X printf("---------------------------------\n");
X printf("Use the right mouse button to select object to modify.\n");
X printf("A & Z : rotate around the X axis\n");
X printf("K & L : rotate around the Y axis\n");
X 
X /* Init */
X glutInit(&argc, argv);
X glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA);
X glutCreateWindow ("Teapot, Sphere & Cube");
X myInit ();
X glutKeyboardFunc(Key);
X glutReshapeFunc (myReshape);
X glutDisplayFunc(display);
X 
X /* Set up right button menu */
X glutCreateMenu(Select);
X glutAddMenuEntry("Cube", 1);
X glutAddMenuEntry("Sphere", 2);
X glutAddMenuEntry("Teapot", 3);
X glutAddMenuEntry("Camera", 4);
X glutAddMenuEntry("Reset Scene", 5);
X glutAddMenuEntry("Quit", 20);
X glutAttachMenu(GLUT_RIGHT_BUTTON);
X
X glutMainLoop();
}
X
SHAR_EOF
  $shar_touch -am 0213170397 'hw1.c' &&
  chmod 0664 'hw1.c' ||
  $echo 'restore of' 'hw1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'hw1.c:' 'MD5 check failed'
f4bb4263ac8129e538e5dcb125b4a57f  hw1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'hw1.c'`"
    test 5628 -eq "$shar_count" ||
    $echo 'hw1.c:' 'original size' '5628,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh114546
exit 0

From ???@??? Tue Feb 11 13:47:34 1997
Received: from jec6314-01.its.rpi.edu (chenyi@jec6314-01.its.rpi.edu [128.113.110.85])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id NAA63346
	for <citrit>; Tue, 11 Feb 1997 13:45:29 -0500
Received: (chenyi@localhost) by jec6314-01.its.rpi.edu (8.6.9/8.6.4) id NAA24836 for citrit; Tue, 11 Feb 1997 13:45:24 -0500
From: "Yi Chen" <chenyi@rpi.edu>
Message-Id: <9702111345.ZM22786@jec6314-01.its.rpi.edu>
Date: Tue, 11 Feb 1997 13:45:21 -0500
X-Mailer: Z-Mail (3.2.1 10apr95)
To: citrit
Subject: grade for proj1
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-UIDL: 34c5a4af7daa8ef41f00f4f0c01bfa11

cheny4	26/30
braunj 	20/30
kozurj	35/30
kholma	30/30
wilmesj	35/30
anandk	29/30
moriartk@cs	35/30
kalisz@fc01.psf.lmco.com	15/30
conway	40/30
stefanm	29/30
boothj	33/30
platom	38/30
mjr@linux1.acm.rpi.edu	33/30
griglb	30/30
schnem	35/30
wangm	37/30
tehrani	30/30
kramer2@cs.rpi.edu 	40/30
normat@chronos.stu.rpi.edu 	35/30
wangc5	35/30
youngs3	20/30
parkec3	15/30
dsouze	36/30
tulumg	10/30
pedrih	23/30
jainh	28/30
younh	23/30


From ???@??? Thu Feb 27 07:54:24 1997
Received: from jec6314-01.its.rpi.edu (chenyi@jec6314-01.its.rpi.edu [128.113.110.85])
	by mail1.its.rpi.edu (8.8.5/8.8.5) with ESMTP id WAA24012
	for <citrit>; Wed, 26 Feb 1997 22:51:39 -0500
Received: (chenyi@localhost) by jec6314-01.its.rpi.edu (8.6.9/8.6.4) id WAA40594 for citrit; Wed, 26 Feb 1997 22:51:28 -0500
From: "Yi Chen" <chenyi@rpi.edu>
Message-Id: <9702262251.ZM38032@jec6314-01.its.rpi.edu>
Date: Wed, 26 Feb 1997 22:51:20 -0500
X-Mailer: Z-Mail (3.2.1 10apr95)
To: citrit
Subject: hw1 regrade
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-UIDL: bc415ea62eb8b1f3f36e052e431eb2fb

Tom,
here are some regrading for hw1

tulumg 		30/30
youngs3 	26/30
pedrih		28/30
younh		35/30

Richard

