<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0100)https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="./Class20-CGLibAdv_files/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app8.us.archive.org";archive_analytics.values.server_ms=151;</script>
<link type="text/css" rel="stylesheet" href="./Class20-CGLibAdv_files/banner-styles.css">


   
   <meta name="GENERATOR" content="Mozilla/4.61C-CCK-MCD Caldera Systems OpenLinux [en] (X11; I; Linux 2.2.10 i586) [Netscape]">
   <title>ECSE-4750, RPI, Class 20</title>
<!-- Time-stamp: </home/wrf/cg-f99/Classes/24/index.html, Wed,  3 Nov 1999, 19:15:00 EST, wrf@benvolio.ecse.rpi.edu> -->
<style type="text/css">
<!--
H1 { color: red; }

H2 { color: blue; }

   OL.outline {list-style-type: upper-roman;
    font: bold italic 18pt sans-serif;}

   OL.outline OL {list-style-type: upper-alpha;
       font: bold 14pt sans-serif;}

   OL.outline OL OL {list-style-type: decimal;
	  font: 12pt serif;}

   OL.outline OL OL OL {list-style-type: lower-alpha;
	     font: 10pt serif;}

   OL.outline OL OL OL OL {list-style-type: lower-roman;
		font: 10pt sans-serif;}
   -->
</style>
</head>
<body bgcolor="#FFFFFF"><div id="wm-ipp" lang="en" style="display: block;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./Class20-CGLibAdv_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20031113163252"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20030626024354/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="26 Jun 2003">JUN</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 16:32:52 Nov 13, 2003">NOV</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20040917132910/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="17 Sep 2004"><strong>SEP</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20030626024354/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="2:43:54 Jun 26, 2003"><img src="./Class20-CGLibAdv_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 16:32:52 Nov 13, 2003">13</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20040917132910/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="13:29:10 Sep 17, 2004"><img src="./Class20-CGLibAdv_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20020627161413/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="27 Jun 2002"><strong>2002</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 16:32:52 Nov 13, 2003">2003</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20041230135121/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="30 Dec 2004"><strong>2004</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20031113163252*/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html" title="See a list of every capture for this URL">7 captures</a>
           <div class="r" title="Timespan for captures of this URL">27 Jun 02 - 30 Dec 04</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="500" height="27" border="0" src="./Class20-CGLibAdv_files/graph.jsp">
       <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./Class20-CGLibAdv_files/disclaim-element.js"></script>
<script type="text/javascript" src="./Class20-CGLibAdv_files/graph-calc.js"></script>
<script type="text/javascript" src="./Class20-CGLibAdv_files/jquery.min.js"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/index.html";

var firstYear = 1996;
var imgWidth = 500,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "13";
var displayMonth = "Nov";
var displayYear = "2003";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<center>
<h1>
Rensselaer Polytechnic Institute<br>
ECSE-4750 Computer Graphics, Spring 2000<br>
Class 20</h1></center>

<hr width="100%">
<br>&nbsp;
<h1>
Homework #8, Due Tuesday April 4 (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/hw8.tar.gz">hw8.tar.gz</a>)</h1>
This assignment requires you understand the CGWindow library of C++ classes
and use it to read in a file of geoemtry primitives. The first part of
the assignment requires you to add a few new nodes to the class hierarchy,
a&nbsp; PolygonShape, TriangleShape, and PolylineShape. The next part is
to read in the example.dat file in the above gzip file, the file format
is:
<p>NodeType&nbsp;&nbsp; Count&nbsp;&nbsp; Red&nbsp;&nbsp; Green&nbsp;&nbsp;
Blue
<br># # # # # # # # # # # # # # # #
</p><p>Where NodeType can be one of:
</p><p>0: Coords 1: Points 2: Lines 3: Polygons 4: Triangles 5: PolyLines
</p><p>The coords section consists of x,y,z triplets. Points Sections consist
of single values of indexes into the current point set. Lines consist of
pairs of values of indexes into the current point set. Polygons are a closed, filled region which consist of a
series of single values which are vertices into the current point set with
each
Polygon series is terminated by a -1. Triangles are filled shapes and their entry sections consist of
triplets of triangle vertices totaling the count. PolyLines consist of
a series of single
values which are vertices into the current point set with each Polyline
series is terminated by a -1. Polylines are not closed automatically.
</p><p>An example file would be:
</p><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size="+1">0 5 1.0 0.0 0.0&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0 2.0 3.0&nbsp;&nbsp; 4.0 5.0 6.0&nbsp;&nbsp; 7.0 8.0 9.0&nbsp;&nbsp; 6.0 5.0 4.0&nbsp;&nbsp;&nbsp; 3.0 2.0 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 0.0&nbsp; 1.0&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 0&nbsp; 2&nbsp; 1&nbsp; 3&nbsp; 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 0.0&nbsp; 0.0&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 2&nbsp;&nbsp; 2 3&nbsp;&nbsp; 4 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 1.0&nbsp; 1.0&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 3 2 4 0 -1&nbsp;&nbsp; 3 2 4 1 0 -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 1.0&nbsp; 0.0&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 4 3&nbsp;&nbsp;&nbsp; 1 0 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 0.0&nbsp; 1.0&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1 2 3 3 -1&nbsp;&nbsp; 4 1 3 1 0 2 1 3 1 2 3 1&nbsp; -1</font></pre>

<p><br>Where the first line describes a series of points to be loaded including
count and RGB value (this can be ignored for points). The second line specifies
<br>the actual x,y,z values for each point. The third line specifies the
next object to be a set of 6 points and they are green. The fourth lines
specifies the
<br>points topology, these numbers refer to coords in the geometry object.
</p><p>You are to hand in a screen shot of the results of reading in and displaying
the dat file with your name in the title bar. Also hand in a copy of the
new classes and your code to read in and setup the rendering pipeline.
</p><h1>
The Computer Graphics Window library:</h1>

<ul>
<li>
We demonstrated an initial implementation using a geometry container, a
topology container, a shape collection mechanism, and a transform class.</li>

<li>
To recap:</li>

<ul>
<li>
We are using a collection based system so things are organized this way:</li>

<ol>
<li>
The CGWindow (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgxwindow.h">cgxwindow.h</a>, <a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgxwindow.cpp">cgxwindow.cpp</a>)
holds a collection of CGActors.</li>

<li>
The CGActor (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgactor.h">cgactor.h</a>, cgactor.cpp) holds
a collection of shapes.</li>

<li>
Shapes, our topology containers, hold pointers to the geoemtry (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgcoords.h">cgcoords.h)</a>.
Here is an example of a PointShape (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgpointshape.h">cgpointshape.h</a>,
<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgpointshape.cpp">cgpointshape.cpp</a>)</li>
</ol>

<li>
The CGActors are responible for position and orientation of their CGShapes
using a member variable CGTransform (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgtransform.h">cgtransform.h</a>,
<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/19/cgtransform.cpp">cgtransform.cpp</a>)</li>

<li>
This transform is used when the shapes attempt to draw themselves, for
instance the PointShape will use the supplied transform to orient its point
prior to calling the CGWindows draw methods.</li>
</ul>
</ul>

<h3>
Optimizations:</h3>

<ul>
<li>
The Shape Class:</li>

<ul>
<li>
The main problem here is the need to transform all points supplied to the
PointShape by its internal pointer.</li>

<li>
This extremely inneficient when the PointList pointed to by the shape contains
many more points than the shape actually uses.</li>

<li>
It will spend much more time transforming than it needs to.</li>

<li>
Options:</li>

<ul>The transform can supply a method to transform a single point.
<pre><font size="+2">/** Method called when update requested */
void CGPointShape::Draw(CGWindow *cgw, CGTransform &amp;cgt)
{
&nbsp;&nbsp;&nbsp; unsigned int ii;
&nbsp;&nbsp;&nbsp; CGPoint pt;
&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;m_vNodeList.size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pt = (*m_Points)[m_vNodeList[ii]];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgt.TransformPoint(pt);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugOut("Point: " &lt;&lt; pt.x &lt;&lt; "," &lt;&lt; pt.y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgw-&gt;DrawPoint(pt.x,pt.y);
&nbsp;&nbsp;&nbsp; }
}</font></pre>
This takes care of the extra math but has the overhead of multiple function
calls.
<p>The Shape can create a pointlist of just the points it is using and
pass this to the transform and finally draw them.
<br>This wastes memory and time by creating copies of the points.
<br>We can minimize this by creating a cached version of the points needed
by the shape and using these for every draw. But what happens when the
underlying points are changed?
<br>We can use the internal time of each object to track when things are
changed and when refreshes to cached data is required.
</p><pre><font size="+1">/</font><font size="+2">** Method called when update requested */
void CGPointShape::Draw(CGWindow *cgw, const CGTransform &amp;cgt)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; ii;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CGPoint pt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the cache is empty or the pointlist is newer, regen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_CachePoints.Size() == 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Points-&gt;GetModifiedTime() &gt; m_CachePoints.GetModifiedTime()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_CachePoints = *m_Points;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgt.TransformPoints(m_CachePoints);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;m_vNodeList.size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugOut("Point: " &lt;&lt; pt.x &lt;&lt; "," &lt;&lt; pt.y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgw-&gt;DrawPoint(m_CachePoints.Get(ii).x,m_CachePoints.Get(ii).y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}</font></pre>
This also has a problem in that the points will not be transformed if the
passed in transform has been updated.
<br>So we add this to the conditional:
<pre><font size="+2">/** Update the Shapes internal points if necessary based on the transform. */
void CGShape::UpdateInternalPoints(const CGTransform &amp;cgt)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; ii;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the cache is empty or the pointlist is newer, regen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_CachePoints.Size() == 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Points-&gt;GetModifiedTime() &gt; m_CachePoints.GetModifiedTime() ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_LastTransformUsed != cgt.GetModifiedTime()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugOut("Regenerating CachePoints.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_CachePoints.Erase();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;m_vNodeList.size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_CachePoints.AddPoint(m_Points-&gt;Get(m_vNodeList[ii]));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgt.TransformPoints(m_CachePoints);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_LastTransformUsed = cgt.GetModifiedTime();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (int iErr) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iErr++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}</font></pre>
And we also moved it to the Shape class.
<ul>&nbsp;</ul>
</ul>
</ul>

<li>
The CGWindow class:</li>

<ul>
<li>
Many graphics APIs allow you to specify an array of points in a single
call which specify multiple geometric primitives.</li>

<li>
We minimize the number of function calls and allow the underlying implementation
decide the best method to draw the primitives.</li>

<li>
We can add functions to handle multiple points like:</li>

<ul>
<pre><font size="+2">/** Base function used as an interface to drawing algorithms */
void CGWindow::DrawPoint(const CGPoint &amp;pt)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDrawPoint(XtDisplay(m_DrawingArea),XtWindow(m_DrawingArea),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GC, pt.x, m_Size[1]-pt.y);
}

/** Base function used as an interface to drawing algorithms */
void CGWindow::DrawPoints(const CGPointList &amp;pts)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ii;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;pts.Size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDrawPoint(XtDisplay(m_DrawingArea),XtWindow(m_DrawingArea),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GC, pts.Get(ii).x, m_Size[1]-pts.Get(ii).y);
&nbsp; }
}

/** Draw a line from pt1 to pt2 */
void CGWindow::DrawLine(const CGPoint &amp;pt1, const CGPoint &amp;pt2)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDrawLine(XtDisplay(m_DrawingArea),XtWindow(m_DrawingArea),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GC, pt1.x, m_Size[1]-pt1.y, pt2.x, m_Size[1]-pt2.y);
}

/* Draw a line from pts[0] to pts[1] then pts[2] to pts[3] */
void CGWindow::DrawLines(const CGPointList &amp;pts)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ii;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((pts.Size()%2) != 0) { // odd number of points
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "Odd number of points sent to DrawLines" &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;pts.Size();ii+=2) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDrawLine(XtDisplay(m_DrawingArea),XtWindow(m_DrawingArea),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GC, pts.Get(ii).x, m_Size[1]-pts.Get(ii).y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pts.Get(ii+1).x, m_Size[1]-pts.Get(ii+1).y);
&nbsp; }
}</font></pre>
</ul>

<li>
Whats missing from this methodology? The points we are using are World
Coordinates and the screen is integer pixel based.</li>

<li>
Look in the book at sections 6.1 - 6.3 and think about a way to handle
specifying a view transform to handle panning and zooming.</li>

<li>
The code supplied has a special method to take World points and translate
them to Display points.</li>

<pre><font size="+2">/** Convert world Coords to display */
void CGWindow::WorldToDisplay(const CGPointList &amp;pts)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XPoint xPnt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ii;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DisplayPoints.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;pts.Size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPnt.x = short(pts.Get(ii).x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPnt.y = short(m_Size[1]-pts.Get(ii).y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DisplayPoints.push_back(xPnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}

/** Convert world Coords to display */
void CGWindow::WorldToDisplay(const CGPoint &amp;pt)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XPoint xPnt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DisplayPoints.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPnt.x = short(pt.x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPnt.y = short(m_Size[1]-pt.y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DisplayPoints.push_back(xPnt);
}&nbsp;&nbsp;</font></pre>

<li>
What do we need to do to our points to make the view transform work?</li>
</ul>
</ul>

<h3>
Color:</h3>

<ul>
<li>
We need to add color to our system.</li>

<li>
As we discussed we need a method to implement colors that effect the whole
object, shapes within and object, or per-vertex coloring.</li>

<li>
Since the graphics library we are using (XLib/MSWindows) does not handle
per-vertex coloring we will stick with the first two.</li>

<li>
Adding color to an object is simple, add a CGColor (<a href="https://web.archive.org/web/20031113163252/http://www.rpi.edu/dept/ecse/cg-s00/Classes/20/cgproperty.h">cgproperty.h</a>)member
variable to our CGActor class.</li>

<li>
We will standardize our color by specifying the Red, Green, and Blue components
to the color.</li>

<li>
These values will be normalized to 1 to allow cross platform translation.
Think of it as specifying the percentage of that color for any given RGB
triplet.</li>

<li>
We then modify the CGWindow SetColor to accept a reference to a CGColor
class and the CGACtor::Draw methods look like:</li>

<pre><font size="+2">/** Time to draw */
void CGActor::Draw(CGWindow *cgw) const {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ii;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgw-&gt;SetColor(m_ObjectColor);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ii=0;ii&lt;m_vShapes.size();ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vShapes[ii]-&gt;Draw(cgw, m_Trans);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}</font></pre>

<li>
The trick of course is applying it at the appropriate time.</li>
</ul>

<hr>
<center>
<p>Copyright © 1999-2000, Thomas D. Citriniti, citrit@rpi.edu
<br>ECSE Dept., Rensselaer Polytechnic Inst., Troy NY, 12180 USA</p></center>








<!--
     FILE ARCHIVED ON 16:32:52 Nov 13, 2003 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:02:52 Aug 21, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</body></html>