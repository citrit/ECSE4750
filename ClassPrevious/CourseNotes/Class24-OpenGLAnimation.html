<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0100)https://web.archive.org/web/20030626025805/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="./Class24-OpenGLAnimation_files/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app12.us.archive.org";archive_analytics.values.server_ms=154;</script>
<link type="text/css" rel="stylesheet" href="./Class24-OpenGLAnimation_files/banner-styles.css">


   
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.61C-CCK-MCD Caldera Systems OpenLinux [en] (X11; I; Linux 2.2.10 i586) [Netscape]">
   <title>ECSE 475 Class 24</title>
</head>
<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080"><div id="wm-ipp" lang="en" style="display: block;" class="hi">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./Class24-OpenGLAnimation_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20030626025805"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20030129213002/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="29 Jan 2003">JAN</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 2:58:05 Jun 26, 2003">Oct</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20040917132922/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="17 Sep 2004"><strong>SEP</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20030129213002/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="21:30:02 Jan 29, 2003"><img src="./Class24-OpenGLAnimation_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 2:58:05 Jun 26, 2003">26</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20040917132922/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="13:29:22 Sep 17, 2004"><img src="./Class24-OpenGLAnimation_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20020320165739/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="20 Mar 2002"><strong>2002</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 2:58:05 Jun 26, 2003">2000</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20040917132922/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="17 Sep 2004"><strong>2004</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20030626025805*/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" title="See a list of every capture for this URL">9 captures</a>
           <div class="r" title="Timespan for captures of this URL">8 May 01 - 30 Dec 04</div>
       </td>
       <td class="k">
       <a href="https://web.archive.org/web/20001001000000/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="500" height="27" border="0" src="./Class24-OpenGLAnimation_files/graph.jsp">
       <div class="yt" style="display: inline; width: 25px; height: 27px; left: 100px;"></div><div class="mt" style="display: inline; width: 2px; height: 27px; left: 119px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20030626025805/http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./Class24-OpenGLAnimation_files/disclaim-element.js"></script>
<script type="text/javascript" src="./Class24-OpenGLAnimation_files/graph-calc.js"></script>
<script type="text/javascript" src="./Class24-OpenGLAnimation_files/jquery.min.js"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.rpi.edu/dept/ecse/cg-s00/Classes/24/index.html";

var firstYear = 1996;
var imgWidth = 500,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "26";
var displayMonth = "Jun";
var displayYear = "2003";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<center>
<h1>
Rensselaer Polytechnic Institute<br>
ECSE-4750 Computer Graphics, Spring 2000<br>
Class 24</h1></center>

<hr>
<h2>
<a name="Animation"></a>Animation with OpenGL</h2>

<ul>
<li>
One of the most exciting things you can do on a graphics computer is draw
pictures that move. Whether you're an engineer trying to see all sides
of a mechanical part you're designing, a pilot learning to fly an airplane
using a simulation, or merely a computer-game aficionado, it's clear that
animation is an important part of computer graphics.</li>

<li>
In a movie theater, motion is achieved by taking a sequence of pictures
(24 per second), and then projecting them at 24 per second on the screen.
(The old Charlie Chaplin movies were shot at 16 frames per second and are
noticeably jerky.)</li>

<li>
Computer-graphics screens typically refresh (redraw the picture) approximately
60 to 76 times per second, and some even run at about 120 refreshes per
second. Clearly, 60 per second is smoother than 30, and 120 is marginally
better than 60. Refresh rates faster than 120, however, are beyond the
point of diminishing returns, since the human eye is only so good.</li>

<li>
The key idea that makes motion picture projection work is that when it
is displayed, each frame is complete.</li>

<li>
What is the problem with this following code segment which attempts to
animate a scene:</li>
</ul>

<dir>
<pre><tt>open_window();
for (i = 0; i &lt; 1000000; i++) {
&nbsp;&nbsp; clear_the_window();&nbsp;
&nbsp;&nbsp; draw_frame(i);&nbsp;
&nbsp;&nbsp; wait_until_a_24th_of_a_second_is_over();&nbsp;
}</tt></pre>
</dir>

<table border="">
<tbody><tr>
<td valign="CENTER">
<center>?</center>
</td>

<td valign="CENTER">What is the problem with this algorithm?</td>
</tr>
</tbody></table>

<ul>
<li>
A modified version of the preceding program that does display smoothly
animated graphics might look like this:</li>
</ul>

<dir>
<pre><tt>open_window_in_double_buffer_mode();
for (i = 0; i &lt; 1000000; i++) {&nbsp;
&nbsp;&nbsp; clear_the_window();&nbsp;
&nbsp;&nbsp; draw_frame(i);
&nbsp;&nbsp; swap_the_buffers();&nbsp;
</tt>}</pre>
</dir>

<table border="">
<tbody><tr>
<td valign="CENTER">
<center>?</center>
</td>

<td valign="CENTER">How does this remove the problem of the last algorithm?</td>
</tr>
</tbody></table>

<ul>
<li>
OpenGL doesn't have a swap_the_buffers() command because the feature might
not be available on all hardware and, in any case, it's highly dependent
on the window system. However, GLX provides such a command, for use on
machines that use the X Window System.</li>
</ul>
<b><i>Example 1-3: A Double-Buffered Program: double.c</i></b>
<dir>
<pre><tt>#include &lt;GL/gl.h</tt>&nbsp;
<tt>#include &lt;GL/glu.h</tt>&nbsp;
<tt>#include &lt;GL/glx.h</tt>&nbsp;
<tt>#include "aux.h"
static GLfloat spin = 0.0;
void display(void)</tt>&nbsp;
<tt>{
glClear(GL_COLOR_BUFFER_BIT);
glPushMatrix();</tt>&nbsp;
<tt>glRotatef(spin, 0.0, 0.0, 1.0);</tt>&nbsp;
<tt>glRectf(-25.0, -25.0, 25.0, 25.0);
glPopMatrix();&nbsp;
glFlush();</tt>&nbsp;
<tt>glXSwapBuffers(auxXDisplay(), auxXWindow());
}
void spinDisplay(void)&nbsp;
{
spin = spin + 2.0;</tt>&nbsp;
<tt>if (spin&nbsp; 360.0)</tt>&nbsp;
<tt>&nbsp;&nbsp; spin = spin - 360.0;</tt>&nbsp;
<tt>display();
}
void startIdleFunc(AUX_EVENTREC *event)</tt>&nbsp;
<tt>{
auxIdleFunc(spinDisplay);
}
void stopIdleFunc(AUX_EVENTREC *event)</tt>&nbsp;
<tt>{
auxIdleFunc(0);
}
void myinit(void)
{
glClearColor(0.0, 0.0, 0.0, 1.0);</tt>&nbsp;
<tt>glColor3f(1.0, 1.0, 1.0);</tt>&nbsp;
<tt>glShadeModel(GL_FLAT);
}
void myReshape(GLsizei w, GLsizei h)&nbsp;
{
glViewport(0, 0, w, h);</tt>&nbsp;
<tt>glMatrixMode(GL_PROJECTION);</tt>&nbsp;
<tt>glLoadIdentity();</tt>&nbsp;
<tt>if (w &lt;= h)&nbsp;
&nbsp;&nbsp; glOrtho (-50.0, 50.0, -50.0*(GLfloat)h/(GLfloat)w,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50.0*(GLfloat)h/(GLfloat)w, -1.0, 1.0);</tt>&nbsp;
<tt>else&nbsp;
&nbsp;&nbsp; glOrtho (-50.0*(GLfloat)w/(GLfloat)h,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50.0*(GLfloat)w/(GLfloat)h, -50.0, 50.0, -1.0, 1.0);</tt>&nbsp;
<tt>glMatrixMode(GL_MODELVIEW);</tt>&nbsp;
<tt>glLoadIdentity ();
}
int main(int argc, char** argv)
{
auxInitDisplayMode(AUX_DOUBLE | AUX_RGBA);
auxInitPosition(0, 0, 500, 500);</tt>&nbsp;
<tt>auxInitWindow(argv[0]);</tt>&nbsp;
<tt>myinit();</tt>&nbsp;
<tt>auxReshapeFunc(myReshape);</tt>&nbsp;
<tt>auxIdleFunc(spinDisplay);</tt>&nbsp;
<tt>auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, startIdleFunc);</tt>&nbsp;
<tt>auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, stopIdleFunc);</tt>&nbsp;
<tt>auxMainLoop(display);</tt></pre>
<tt>}</tt></dir>
<b><i>Figure 1-2: A Double-Buffered Program Results</i></b>
<p><img src="./Class24-OpenGLAnimation_files/fig1-2.gif" height="190" width="518">
</p><p>
</p><hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="Drawing_Geometric_Objects"></a>Drawing Geometric Objects</h2>

<ul>
<li>
At the highest level of abstraction, there are three basic drawing operations:
clearing the window, drawing a geometric object, and drawing a raster object.</li>

<li>
All the curved lines and surfaces you've seen are approximated by large
numbers of little flat polygons or straight lines</li>

<li>
OpenGL's default style of drawing graphics is immediate-mode. This specifies
that OpenGL will draw the object when you issue the command. The other
mode is display list drawing which store the drawing commands for later
usage. Display lists are more efficient and we will look at those later.</li>
</ul>

<h3>
<a name="Clearing_the_Window"></a>Clearing the Window</h3>

<ul>
<li>
Drawing on a computer screen is different from drawing on paper in that
the paper starts out white, and all you have to do is draw the picture.
On a computer, the memory holding the picture is usually filled with the
last picture you drew, so you typically need to clear it to some background
color before you start to draw the new scene.</li>

<li>
This is how to clear the window to black:</li>
</ul>

<blockquote><tt>glClearColor(0.0, 0.0, 0.0, 0.0);</tt>
<br><tt>glClear(GL_COLOR_BUFFER_BIT);</tt></blockquote>

<ul>
<li>
The first line sets the clearing color to black, and the next command clears
the entire window to the current clearing color. The single parameter to
<i>glClear()</i>
indicates which buffers are to be cleared. In this case, the program clears
only the color buffer, where the image displayed on the screen is kept.</li>

<li>
Typically, you set the clearing color once, early in your application,
and then you clear the buffers as often as necessary. OpenGL keeps track
of the current clearing color as a state variable rather than requiring
you to specify it each time a buffer is cleared.</li>
</ul>

<h3>
<a name="Specifying_a_Color"></a>Specifying a Color</h3>

<ul>
<li>
With OpenGL, the description of the shape of an object being drawn is independent
of the description of its color. Whenever a particular geometric object
is drawn, it's drawn using the currently specified coloring scheme.</li>

<li>
Until the color or coloring scheme is changed, all objects are drawn in
that color or using that coloring scheme. This method helps OpenGL achieve
higher drawing performance than would result if it didn't keep track of
the current color.</li>

<li>
For example, the pseudocode</li>
</ul>

<blockquote><tt>set_current_color(red);</tt>
<br><tt>draw_object(A);</tt>
<br><tt>draw_object(B);</tt>
<br><tt>set_current_color(green);</tt>
<br><tt>set_current_color(blue);</tt>
<br><tt>draw_object(C);</tt></blockquote>

<ul>
<li>
draws objects A and B in red, and object C in blue. The command on the
fourth line that sets the current color to green is wasted.</li>

<li>
To set a color, use the command <i>glColor3f().</i> It takes three parameters,
all of which are floating-point numbers between 0.0 and 1.0. The parameters
are, in order, the red, green, and blue components of the color.</li>
</ul>
<b><i>Table 1-2: Color mappings to RGB values</i></b>
<br>&nbsp;
<br>&nbsp;
<table border="">
<tbody><tr>
<td valign="CENTER">Command</td>

<td valign="CENTER">Color</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(0.0, 0.0, 0.0);</td>

<td valign="CENTER">black</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(1.0, 0.0, 0.0);</td>

<td valign="CENTER">red</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(0.0, 1.0, 0.0);</td>

<td valign="CENTER">green</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(1.0, 1.0, 0.0);</td>

<td valign="CENTER">yellow</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(0.0, 0.0, 1.0);</td>

<td valign="CENTER">blue</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(1.0, 0.0, 1.0);</td>

<td valign="CENTER">magenta</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(0.0, 1.0, 1.0);</td>

<td valign="CENTER">cyan</td>
</tr>

<tr>
<td valign="CENTER">glColor3f(1.0, 1.0, 1.0);</td>

<td valign="CENTER">white</td>
</tr>
</tbody></table>

<h3>
<a name="Forcing_Completion_of_Drawing"></a>Forcing Completion of Drawing</h3>

<ul>
<li>
Most modern graphics systems can be thought of as an assembly line, sometimes
called a graphics pipeline. The main central processing unit (CPU) issues
a drawing command, perhaps other hardware does geometric transformations,
clipping occurs, then shading or texturing is performed, and finally, the
values are written into the bitplanes for display</li>

<li>
The client server model of OpenGL uses packets of drawing commands as the
method of communication. These packets hold a number of drawing commands
and the client will wait for the packet to be filled before sending it
to the server. This can result in a few drawing commands getting "stuck"
in the transmission packet on the client.</li>

<li>
For this reason, OpenGL provides the command <i>glFlush(),</i> which forces
the client to send the network packet even though it might not be full.
Where there is no network and all commands are truly executed immediately
on the server, <i>glFlush()</i> might have no effect. However, if you're
writing a program that you want to work properly both with and without
a network, include a call to <i>glFlush()</i> at the end of each frame
or scene.</li>
</ul>

<hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="Drawing_Graphic_Primitives"></a>Drawing Graphic Primitives</h2>

<dl>
<dt>
<b>Points</b></dt>

<dd>
A point is represented by a set of floating-point numbers called a vertex.
All internal calculations are done as if vertices are three-dimensional.
Vertices specified by the user as two-dimensional (that is, with only x
and y coordinates) are assigned a z co-ordinate equal to zero by OpenGL</dd>

<dt>
<b>Lines</b></dt>

<dd>
In OpenGL, line means line segment, not the mathematician's version that
extends to infinity in both directions. There are easy ways to specify
a connected series of line segments, or even a closed, connected series
of segments. In all cases, though, the lines comprising the connected series
are specified in terms of the vertices at their endpoints.</dd>

<dt>
<b>Polygons</b></dt>

<dd>
Polygons are the areas enclosed by single closed loops of line segments,
where the line segments are specified by the vertices at their endpoints.
Polygons are typically drawn with the pixels in the interior filled in,
but you can also draw them as outlines or a set of points</dd>

<dt>
<b>Rectangles</b></dt>

<dd>
Since rectangles are so common in graphics applications, OpenGL provides
a filled-rectangle drawing primitive, <i>glRect*().</i> You can draw a
rectangle as a but your particular implementation of OpenGL might have
optimized <i>glRect*()</i> for rectangles.</dd>
</dl>

<ul>
<li>
How to draw an OpenGL Primitive, the following code specifies the vertices
for a polygon show in figure 3:</li>
</ul>

<dir>
<pre><tt>glBegin(GL_POLYGON);</tt>&nbsp;
<tt>&nbsp; glVertex2f(0.0, 0.0);</tt>&nbsp;
<tt>&nbsp; glVertex2f(0.0, 3.0);</tt>&nbsp;
<tt>&nbsp; glVertex2f(3.0, 3.0);</tt>&nbsp;
<tt>&nbsp; glVertex2f(4.0, 1.5);</tt>&nbsp;
<tt>&nbsp; glVertex2f(3.0, 0.0);</tt>&nbsp;
<tt>glEnd();</tt></pre>
</dir>
<b><i>Figure 1-3: Drawing a Polygon or Set of Points</i></b>
<p><img src="./Class24-OpenGLAnimation_files/fig1-3.gif" alt="Figure 3" height="106" width="246">
</p><ul>
<li>
If you had used GL_POINTS instead of GL_POLYGON, the primitive would have
been simply the five points shown in Figure 2 . Table 1-2 in the following
function summary for <i>glBegin()</i> lists the ten possible arguments
and the corresponding type of primitive.</li>
</ul>

<dl>
<dt>
<i>void glBegin(GLenum mode);</i></dt>

<dd>
Marks the beginning of a vertex list that describes a geometric primitive.
The type of primitive is indicated by mode, which can be any of the values
shown in</dd>
</dl>
<b><i>Table 1-3: Geometric Primitive Names and Meanings</i></b>
<br>&nbsp;
<br>&nbsp;
<table border="">
<tbody><tr>
<td valign="CENTER">Value</td>

<td valign="CENTER">Meaning</td>
</tr>

<tr>
<td valign="CENTER">GL_POINTS&nbsp;</td>

<td valign="CENTER">individual points</td>
</tr>

<tr>
<td valign="CENTER">GL_LINES&nbsp;</td>

<td valign="CENTER">pairs of vertices interpreted as individual line segments</td>
</tr>

<tr>
<td valign="CENTER">GL_POLYGON&nbsp;</td>

<td valign="CENTER">boundary of a simple, convex polygon</td>
</tr>

<tr>
<td valign="CENTER">GL_TRIANGLES&nbsp;</td>

<td valign="CENTER">triples of vertices interpreted as triangles</td>
</tr>

<tr>
<td valign="CENTER">GL_QUADS&nbsp;</td>

<td valign="CENTER">quadruples of vertices interpreted as four-sided polygons</td>
</tr>

<tr>
<td valign="CENTER">GL_LINE_STRIP&nbsp;</td>

<td valign="CENTER">series of connected line segments</td>
</tr>

<tr>
<td valign="CENTER">GL_LINE_LOOP&nbsp;</td>

<td valign="CENTER">same as above, with a segment added between last and
first vertices</td>
</tr>

<tr>
<td valign="CENTER">GL_TRIANGLE_STRIP&nbsp;</td>

<td valign="CENTER">linked strip of triangles</td>
</tr>

<tr>
<td valign="CENTER">GL_TRIANGLE_FAN&nbsp;</td>

<td valign="CENTER">linked fan of triangles</td>
</tr>

<tr>
<td valign="CENTER">GL_QUAD_STRIP&nbsp;</td>

<td valign="CENTER">linked strip of quadrilaterals</td>
</tr>
</tbody></table>

<h3>
<a name="Restriction_on_using_glBegin___and_glEnd"></a>Restriction on using
glBegin() and glEnd()</h3>

<ul>
<li>
The most important aspect of vertices are their coordinates, which are
specified by the <i>glVertex()</i> command. You can also supply additional
vertex specific information for each vertex - a color, a normal vector,
texture coordinates, or any combination of the following commands:</li>
</ul>
<b><i>Table 1-4: Valid commands between glBegin() and glEnd()</i></b>
<br>&nbsp;
<br>&nbsp;
<table border="">
<tbody><tr>
<td valign="CENTER">Command</td>

<td valign="CENTER">Purpose of command</td>
</tr>

<tr>
<td valign="CENTER"><i>glVertex*()</i></td>

<td valign="CENTER">set vertex commands</td>
</tr>

<tr>
<td valign="CENTER"><i>glColor*()</i></td>

<td valign="CENTER">set current color</td>
</tr>

<tr>
<td valign="CENTER"><i>glIndex*()</i></td>

<td valign="CENTER">set current color index</td>
</tr>

<tr>
<td valign="CENTER"><i>glNormal*()</i></td>

<td valign="CENTER">set normal vertex coordinates</td>
</tr>

<tr>
<td valign="CENTER"><i>glEvalCoord*()</i></td>

<td valign="CENTER">generate coordinates</td>
</tr>

<tr>
<td valign="CENTER"><i>glCallList(), glCallLists()</i></td>

<td valign="CENTER">execute display list(s)</td>
</tr>

<tr>
<td valign="CENTER"><i>glTexCoord*()</i></td>

<td valign="CENTER">set texture coordinates</td>
</tr>

<tr>
<td valign="CENTER"><i>glEdgeflag*()</i></td>

<td valign="CENTER">control drawing of edges</td>
</tr>

<tr>
<td valign="CENTER"><i>glMaterial*()</i></td>

<td valign="CENTER">set material properties</td>
</tr>
</tbody></table>

<ul>
<li>
No other OpenGL commands are valid between a <i>glBegin()</i> and <i>glEnd()</i>
pair, making any other OpenGL call will generate and error. Note though
that only OpenGL commands are restricted. For example the following code
draws an outlined circle:</li>
</ul>

<dir>
<pre><tt>#define PI 3.1415926535897</tt>&nbsp;
<tt>Glint circle_points = 100;</tt>&nbsp;
<tt>glBegin(GL_LINE_LOOP);</tt>&nbsp;
<tt>for (I = 0;I &lt; circle_points; I++) {</tt>&nbsp;
<tt>&nbsp;&nbsp; angle = 2 * PI * I /circle_points;
&nbsp;&nbsp; glVertex2f(cos(angle), sin(angle));</tt>&nbsp;
<tt>}</tt>&nbsp;
<tt>glEnd();</tt></pre>
</dir>

<ul>
<li>
This is of course not the most efficient method of drawing a circle, more
efficient methods include storing the vertexes in an array, create a display
list, or use a GLU routine.</li>

<li>
You can use any combination of the twenty-four versions of the <i>glVertex*()</i>
command between the <i>glBegin()</i> and <i>glEnd(),</i> although in real
applications all the calls in any particular instance tends to be of the
same type.</li>
</ul>

<h3>
<a name="Displaying_Points__Lines__and_Polygons"></a>Displaying Points,
Lines, and Polygons</h3>

<ul>
<li>
By default, a point is drawn as a single pixel on the screen, a line is
drawn solid and one pixel wide, and polygons are drawn solidly filled in.
The following commands control the display modes for the default drawing
modes.</li>
</ul>

<dl>
<dt>
void <b>glPointSize</b>(GLfloat <i>size</i>)</dt>

<dd>
Sets the width in pixels for rendered points, <i>size</i> must be greater
than 0.0 and by default is 1.0</dd>

<dt>
void <b>glLineWidth</b>(GLfloat <i>width</i>)</dt>

<dd>
Sets the width in pixels for rendered lines; <i>width</i> must be greater
than 0.0 and by default is 1.0.</dd>

<dt>
void <b>glLineStipple</b>(GLint <i>factor</i>, Glushort <i>pattern</i>)</dt>

<dd>
Sets the current stippling pattern for lines. The <i>pattern</i> argument
is a 16 bit series of 0s and 1s, and is repeated as necessary to stipple
a given line. The pattern can be stretched out by using <i>factor</i>,
which multiplies each subseries of consecutive 1s and 0s. Line stippling
must be enabled by passing GL_LINE_STIPPLE to <i>glEnable();</i> it's disabled
by passing the same argument to <i>glDisable().</i></dd>

<dt>
void <b>glPolygonMode</b>(GLenum <i>face</i>, Glenum <i>mode</i>);</dt>

<dd>
Controls the drawing mode for a polgons front and back faces. The parameter
<i>face</i>
can be GL_FRONT_AND_BACK, GL_FRONT, or GL_BACK; <i>mode</i> can be GL_POINT,
GL_LINE or GL_FILL to indicate whether the polygon should be drawn as points,
outlined, or filled. By default, both the front and back faces are drawn
filled.</dd>
</dl>

<ul>
<li>
In general, polygons can be complicated, so OpenGL makes some strong restrictions
on what constitutes a primitive polygon.</li>
</ul>

<ol>
<ol>
<li>
The edges of a OpenGL polygon can't intersect (a mathematician would call
this a <i>simple polygon</i>)</li>

<li>
OpenGL polygons must be convex, they cannot have indentations.</li>
</ol>
</ol>

<ul>
<li>
Note that polygons with holes cannot be described. They are nonconvex,
and they can't be drawn with a boundary made up of a single closed loop.</li>
</ul>
<b><i>Figure 1-4: Valid and Invalid Polygons</i></b>
<p><img src="./Class24-OpenGLAnimation_files/fig1-4.gif" alt="Figure 1-4" height="81" width="319">
</p><p>
</p><hr>
<h2>
<a name="Polygon_Details"></a>Polygon Details</h2>

<ul>
<li>
Polygons are typically drawn by filling in all the pixels enclosed within
the boundary.</li>

<li>
Polygons have two sides, a front and a back and might be rendered differently
depending on which side is facing the viewer. This allows you to have cutaway
views of solid objects in which there is an obvious distinction between
the parts that are inside and those on the outside.</li>

<li>
The polygon drawing mode is controlled by:</li>
</ul>

<dl>
<dt>
void <b>glPolygonMode</b>(GLenmu <i>face</i>, Glenum <i>mode</i>);</dt>

<dd>
Controls the drawing mode for polygons front and back faces. The parameter
<i>face</i>
can be GL_FRONT_AND_BACK, GL_FRONT, or GL_BACK; <i>mode</i> can be GL_POINT,
GL_LINE, or GL_FILL.</dd>
</dl>

<ul>
<li>
You can have the front faces filled and the back faces outlined with these
two calls:</li>
</ul>

<blockquote><tt>glPolygonMode(GL_FRONT, GL_FILL);</tt>
<br><tt>glPolygonMode(GL_BACK, GL_LINE);</tt></blockquote>

<h3>
Reversing and Culling Polygon Faces</h3>

<ul>
<li>
Polygons whose vertices appear in a counterclockwise order on the screen
are called <i>front-facing</i>. You can construct the surface of any reasonable
solid from polygons of consistent orientation.</li>

<li>
You can swap what OpenGL considers the back face by using the function:</li>
</ul>

<dl>
<dt>
void <b>glFrontFace</b>(GLenum <i>mode</i>);</dt>

<dd>
Controls how front-facing polygons are determined. By default, <i>mode</i>
is GL_CCW, which corresponds to a counterclockwise orientation of the ordered
vertices of a projected polygon in window coordinates. If <i>mode</i> is
GL_CW, faces with a clockwise orientation are considered front-facing.</dd>
</dl>

<ul>
<li>
In a completely enclosed surface constructed from polygons with a consistent
orientation, none of the back-facing polygons are ever visible, they are
always obscured by the front-facing polygons. In this situation, you can
maximize drawing speed by having OpenGL discard polygons as soon as it
determines that they are back-facing.</li>

<li>
To instruct OpenGL to discard front- or back-facing polygons, use:</li>
</ul>

<dl>
<dt>
void <b>glCullFace</b>(GLenum <i>mode</i>);</dt>

<dd>
Indicates which polygons should be discarded (culled) before they are converted
to screen coordinates. The <i>mode</i> is either GL_FRONT, GL_BACK, or
GL_FRONT_AND_BACK to indicate front-, back-facing, or all polygons. To
take effect, culling must be enabled using <b>glEnable()</b> with the GL_CULL_FACE;
it can be disabled with <b>glDisable()</b> and the same argument.</dd>
</dl>

<ul>
<li>
By default, filled polygons are drawn with a solid pattern. They can also
be filled with a 32x32 bit window-aligned stipple pattern, which can be
specified with:</li>
</ul>

<dl>
<dt>
void <b>glPolygonStipple</b>(cont Glubyte *<i>mask</i>);</dt>

<dd>
Defines the current stipple pattern for filled polygons. the argument <i>mask</i>
is a pointer to a 32x32 bitmap that's interpreted as a mask of 0s and 1s.
Polygon stippling is enabled and disabled by using <b>glEnable()</b> and
<b>glDisable()</b>
with GL_POLYGON_STIPPLE as the argument.</dd>
</dl>

<h3>
<a name="Normal_Vectors"></a>Normal Vectors</h3>

<ul>
<li>
A normal vector (or normal for short) is a vector that points in a direction
that is perpendicular to a surface.</li>

<li>
For a flat surface one perpendicular direction suffices for every point
on the surface, but for a general curved surface, the normal direction
might be different at each point. With OpenGL you can specify a normal
for each vertex.</li>

<li>
Vertices may share the same normal, but you can't assign normals anywhere
other than at the vertices.</li>

<li>
To set the current normal for subsequent calls to <b>glVertex()</b> use:</li>
</ul>
void <b>glNormal3</b>{bsidf}(<i>TYPE nx, TYPE ny, TYPE nz</i>);
<dl>
<dt>
void <b>glNormal3</b>{bsidf}<b>v</b>(const <i>TYPE *v</i>);</dt>

<dd>
Sets the current normal vector as specified by the arguments. The nonvector
version (without the <b>v</b>) takes three arguments, which specify an
(<i>nx, ny, nz</i>) vector that is taken to be the normal. alternatively,
you can use the vector version of this function (with the <b>v</b>) and
supply a single array of three elements to specify the desired normal.
The <b>b, s</b>, and <b>i</b> versions scale their parameter values linearly
to the range [-1.0, 1.0].</dd>
</dl>

<ul>
<li>
There is no magic to finding the normals for an object, most likely you
have to perform some calculations that might include taking derivatives.
Normals are used in shading of polygon surfaces.</li>
</ul>

<hr>
<center>
<p>Copyright Â© 1999-2000, Thomas D. Citriniti, citrit@rpi.edu
<br>ECSE Dept., Rensselaer Polytechnic Inst., Troy NY, 12180 USA</p></center>








<!--
     FILE ARCHIVED ON 2:58:05 Jun 26, 2003 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:09:27 Aug 21, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</body></html>