<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0100)https://web.archive.org/web/20031113163410/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="./Class23-OpenGL_files/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app1.us.archive.org";archive_analytics.values.server_ms=139;</script>
<link type="text/css" rel="stylesheet" href="./Class23-OpenGL_files/banner-styles.css">


   
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.61C-CCK-MCD Caldera Systems OpenLinux [en] (X11; I; Linux 2.2.10 i586) [Netscape]">
   <title>ECSE 475 Class 23</title>
</head>
<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080"><div id="wm-ipp" lang="en" style="display: block;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./Class23-OpenGL_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20031113163410"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20030912091304/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="12 Sep 2003">SEP</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 16:34:10 Nov 13, 2003">NOV</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20040917132918/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="17 Sep 2004"><strong>SEP</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20030912091304/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="9:13:04 Sep 12, 2003"><img src="./Class23-OpenGL_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 16:34:10 Nov 13, 2003">13</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20040917132918/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="13:29:18 Sep 17, 2004"><img src="./Class23-OpenGL_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20020628014440/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="28 Jun 2002"><strong>2002</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 16:34:10 Nov 13, 2003">2003</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20041230145207/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="30 Dec 2004"><strong>2004</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20031113163410*/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html" title="See a list of every capture for this URL">10 captures</a>
           <div class="r" title="Timespan for captures of this URL">8 May 01 - 30 Dec 04</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="500" height="27" border="0" src="./Class23-OpenGL_files/graph.jsp">
       <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20031113163410/http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./Class23-OpenGL_files/disclaim-element.js"></script>
<script type="text/javascript" src="./Class23-OpenGL_files/graph-calc.js"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(imgWidth,imgHeight,yearImgWidth,monthImgWidth){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.rpi.edu/dept/ecse/cg-s00/Classes/23/index.html";

var firstYear = 1996;
var displayDay = "13";
var displayMonth = "Nov";
var displayYear = "2003";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})(500, 27, 25, 2);//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<center>
<h1>
Rensselaer Polytechnic Institute<br>
ECSE-4750 Computer Graphics, Spring 2000<br>
Class 23</h1></center>

<hr>
<br>&nbsp;
<br>&nbsp;
<h1>
How does MapInfo Professional Integrate 3D</h1>

<ul>
<li>
Currently MapInfo Pro was strickly a 2D&nbsp;program.</li>

<li>
The Mapper window show layer in various 2D&nbsp;projections.</li>

<li>
In a previous release false shading of elevation grids was introduced which
exagerated topological features to show relief and changing features.</li>

<li>
In the latest release a 3D Map window was introduced which allows users
to view their Grids at a rotated angle.</li>

<li>
Grids may consist of elevations, temperature, population density, etc.</li>

<li>
Vector layers can be laid over the top to accurately represent roads and
boundaries with respect to the topological changes.</li>

<li>
The main issue is how to create an interface that will be comfortable to
users who are experienced with only 2D controls.</li>

<li>
The current implementation is a mix of 2D and 3D interators.</li>

<li>
One major issue turned out to be the inconsitant support of OpenGL for
different hardware display adapters.</li>
</ul>

<h2>
<a name="What_is_OpenGL_"></a>What is OpenGL?</h2>

<ul>
<li>
OpenGL is a software interface to 3D and 2D graphics routines. OpenGL can
be used as an interface to graphics hardware or in some instances, be a
software only solution.</li>

<li>
This interface consists of about 120 distinct commands, which you use to
specify the objects and operations needed to produce interactive three-dimensional
applications.</li>

<li>
OpenGL is designed to work efficiently even if the computer that displays
the graphics you create isn't the computer that runs your graphics program.</li>

<ul>
<li>
This might be the case if you work in a networked computer environment
where many computers are connected to one another by wires capable of carrying
digital data. In this situation, the computer on which your program runs
and issues OpenGL drawing commands is called the client, and the computer
that receives those commands and performs the drawing is called the server.
The format for transmitting OpenGL commands (called the protocol) from
the client to the server is always the same, so OpenGL programs can work
across a network even if the client and server are different kinds of computers.
If an OpenGL program isn't running across a network, then there's only
one computer, and it is both the client and the server.</li>
</ul>

<li>
OpenGL is designed as a streamlined, hardware-independent interface to
be implemented on many different hardware platforms.</li>

<ul>
<li>
To achieve these qualities:</li>

<li>
No commands for performing windowing tasks or obtaining user input are
included in OpenGL.</li>

<li>
You must work through whatever windowing system controls the particular
hardware you're using.</li>
</ul>

<li>
With OpenGL, you must build up your desired model from a small set of geometric
primitive points, lines, and polygons. (A sophisticated library that provides
these features could certainly be built on top of OpenGL, we will investigate
this in detail).</li>
</ul>

<h3>
How does OpenGL work?</h3>

<ul>
<li>
Here is the order in which OpenGL performs the major graphics operations
necessary to render an image on the screen.</li>
</ul>

<ol>
<ol>
<li>
Construct shapes from geometric primitives, thereby creating mathematical
descriptions of objects. (OpenGL considers points, lines, polygons, images,
and bitmaps to be primitives.)</li>

<li>
Arrange the objects in three-dimensional space and select the desired vantage
point for viewing the composed scene.</li>

<li>
Calculate the color of all the objects. The color might be explicitly assigned
by the application, determined from specified lighting conditions, or obtained
by pasting a texture onto the objects.</li>

<li>
Convert the mathematical description of objects and their associated color
information to pixels on the screen. This process is called rasterization.</li>
</ol>
</ol>

<ul>
<li>
During these stages, OpenGL might perform other operations, such as eliminating
parts of objects that are hidden by other objects (the hidden parts won't
be drawn, which might increase performance). In addition, after the scene
is rasterized but just before it's drawn on the screen, you can manipulate
the pixel data if you want.</li>
</ul>

<h3>
Some basic terms:</h3>

<dl>
<dt>
Rendering</dt>

<dd>
Conversion of primitives specified in object co-ordinates to an image in
the framebuffer. Rendering is the primary operation of OpenGL, it's what
OpenGL does.</dd>

<dt>
Bitplane</dt>

<dd>
A rectangular array of bits mapped one-to-one with pixels.</dd>

<dt>
Framebuffer</dt>

<dd>
All the buffers of a given window or context. Sometimes includes all the
pixel memory of the graphics hardware accelerator. The framebuffer is also
a stack of bitplanes.</dd>
</dl>

<h2>
<a name="A_simple_example_"></a>A simple example:</h2>

<ul>
<li>
Because you can do so many things with the OpenGL graphics system, an OpenGL
program can be complicated. However, the basic structure of a useful program
can be simple: Its tasks are to initialise certain states that control
how OpenGL renders and to specify objects to be rendered.</li>

<li>
Example 1-1 renders a white rectangle on a black background, as shown in
Figure 1-1 .</li>
</ul>
<b><i>Example 1-1: A simple OpenGL Program.</i></b>
<dir>
<pre><tt>#include &lt;whateverYouNeed.h
main() {
OpenAWindowPlease();&nbsp;
glClearColor(0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
glColor3f(1.0, 1.0, 1.0);
glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);&nbsp;
glBegin(GL_POLYGON);
&nbsp; glVertex2f(-0.5, -0.5);
&nbsp; glVertex2f(-0.5, 0.5);
&nbsp; glVertex2f(0.5, 0.5);
&nbsp; glVertex2f(0.5, -0.5);
glEnd();
glFlush();

KeepTheWindowOnTheScreenForAWhile();
}</tt></pre>
</dir>

<ul>
<li>
The <i>OpenAWindowPlease()</i> routine is meant as a placeholder for a
window system-specific routine.</li>

<li>
The next two lines are OpenGL commands that clear the window to black:
<i>glClearColor()</i> establishes what color the window will be cleared
to, and <i>glClear()</i> actually clears the window. Once the color to
clear to is set, the window is cleared to that color whenever <i>glClear()</i>
is called.</li>

<li>
The next OpenGL command used in the program, <i>glOrtho(),</i> specifies
the co-ordinate system OpenGL assumes as it draws the final image and how
the image gets mapped to the screen.</li>

<li>
The next calls, which are bracketed by <i>glBegin()</i> and <i>glEnd(),</i>
define the object to be drawn in this example, a polygon with four vertices.</li>

<li>
The polygon's "corners" are defined by the <i>glVertex2f()</i> commands.
As you might be able to guess from the arguments, which are (x, y) co-ordinate
pairs, the polygon is a rectangle.</li>

<li>
Finally, <i>glFlush()</i> ensures that the drawing commands are actually
executed, rather than stored in a buffer awaiting additional OpenGL commands.</li>

<li>
The <i>KeepTheWindowOnTheScreenForAWhile()</i> placeholder routine forces
the picture to remain on the screen instead of immediately disappearing.</li>
</ul>
<b><i>Figure 1-1: Resultant image</i></b>
<p><img src="./Class23-OpenGL_files/fig1-1.gif" alt="Figure 1" height="269" width="251">
</p><p>
</p><hr>
<h2>
<a name="OpenGL_Command_Syntax_"></a>OpenGL Command Syntax:</h2>

<ul>
<li>
OpenGL commands use the prefix gl and initial capital letters for each
word making up the command name (recall <i>glClearColor(),</i> for example).</li>

<li>
OpenGL defined constants begin with GL_, use all capital letters, and use
underscores to separate words (like <tt>GL_COLOR_BUFFER_BIT</tt>).</li>

<li>
The seemingly extraneous letters appended to some command names (the <i>3f</i>
in <i>glColor3f(),</i> for example) are necessary to allow the command
to be used with various type of data values.</li>

<li>
The <i>3</i> part of the suffix indicates that three arguments are given;
another version of the Color command takes four arguments. The <i>f</i>
part of the suffix indicates that the arguments are floating-point numbers.</li>

<li>
Some OpenGL commands accept as many as eight different data types for their
arguments.</li>
</ul>

<h2>
<a name="Command_suffixes_maping_to_ANSI_C_types_"></a>Command suffixes
maping to ANSI C types:</h2>
<b><i>Table 1-1: Command Suffixes and Argument Data Types</i></b>
<br>&nbsp;
<br>&nbsp;
<table border="">
<tbody><tr>
<td valign="CENTER">Suffix</td>

<td valign="CENTER">Data Type</td>

<td valign="CENTER">C-Language Type</td>

<td valign="CENTER">OpenGL Type Definition</td>
</tr>

<tr>
<td valign="CENTER">
<center>b</center>
</td>

<td valign="CENTER">8-bit integer</td>

<td valign="CENTER">signed char</td>

<td valign="CENTER">GLbyte</td>
</tr>

<tr>
<td valign="CENTER">
<center>s</center>
</td>

<td valign="CENTER">16-bit integer</td>

<td valign="CENTER">short</td>

<td valign="CENTER">GLshort</td>
</tr>

<tr>
<td valign="CENTER">
<center>i</center>
</td>

<td valign="CENTER">32-bit integer</td>

<td valign="CENTER">long</td>

<td valign="CENTER">Glint, GLsizei</td>
</tr>

<tr>
<td valign="CENTER">
<center>f</center>
</td>

<td valign="CENTER">32-bit floating-point</td>

<td valign="CENTER">float</td>

<td valign="CENTER">Glfloat, GLclampf</td>
</tr>

<tr>
<td valign="CENTER">
<center>d</center>
</td>

<td valign="CENTER">64-bit floating-point</td>

<td valign="CENTER">double</td>

<td valign="CENTER">Gldouble, GLclampd</td>
</tr>

<tr>
<td valign="CENTER">
<center>ub</center>
</td>

<td valign="CENTER">8-bit unsigned integer</td>

<td valign="CENTER">unsigned char</td>

<td valign="CENTER">Glubyte, GLboolean</td>
</tr>

<tr>
<td valign="CENTER">
<center>us</center>
</td>

<td valign="CENTER">16-bit unsigned integer</td>

<td valign="CENTER">unsigned short</td>

<td valign="CENTER">GLushort</td>
</tr>

<tr>
<td valign="CENTER">
<center>ui</center>
</td>

<td valign="CENTER">32-bit unsigned integer</td>

<td valign="CENTER">unsigned long</td>

<td valign="CENTER">GLuint,GLenum, GLbitfield</td>
</tr>
</tbody></table>

<ul>
<li>
Thus, the two commands:</li>
</ul>

<blockquote><tt>glVertex2i(1, 3);</tt>
<br><tt>glVertex2f(1.0, 3.0);</tt></blockquote>

<ul>
<li>
are equivalent, except that the first specifies the vertex's coordinates
as 32-bit integers and the second specifies them as single-precision floating-point
numbers.</li>

<li>
Some OpenGL commands can take a final letter v, which indicates that the
command takes a pointer to a vector (or array) of values rather than a
series of individual arguments:</li>
</ul>

<blockquote><tt>glColor3f(1.0, 0.0, 0.0);</tt>
<br><tt>float color_array[] = {1.0, 0.0,0.0};</tt>
<br><tt>glColor3fv(color_array);</tt></blockquote>

<ul>
<li>
The particular implementation of OpenGL that you're using might not follow
this scheme exactly; an implementation in C++, Java, or Ada, for example,
wouldn't need to.</li>
</ul>

<table border="">
<tbody><tr>
<td valign="CENTER">
<center>?</center>
</td>

<td valign="CENTER">How would C++, Java, or Ada remove these extra routine
definitions?</td>
</tr>
</tbody></table>

<p>
</p><hr>
<h2>
<a name="OpenGL_as_a_State_Machine"></a>OpenGL as a State Machine</h2>

<ul>
<li>
OpenGL is a state machine. You put it into various states (or modes) that
then remain in effect until you change them.</li>

<li>
The current color is a state variable. You can set the current color to
white, red, or any other color, and thereafter every object is drawn with
that color until you set the current color to something else.</li>

<li>
The current color is only one of many state variables that OpenGL preserves.
Others control such things as the current viewing and projection transformations,
line and polygon stipple patterns, polygon drawing modes, pixel-packing
conventions, positions and characteristics of lights, and material properties
of the objects being drawn.</li>

<li>
Many state variables refer to modes that are enabled or disabled with the
command <i>glEnable()</i> or <i>glDisable().</i></li>

<li>
Each state variable or mode has a default value, and at any point you can
query the system for each variable's current value using one of the four
following commands:</li>
</ul>

<blockquote><i>glGetBooleanv(), glGetDoublev(), glGetFloatv(),</i> or <i>glGetIntegerv()</i></blockquote>

<ul>
<li>
Which of these commands you select depends on what data type you want the
answer to be given in. Some state variables have a more specific query
command (such as <i>glGetLight*(), glGetError(),</i> or <i>glGetPolygonStipple()</i>
).</li>

<li>
In addition, you can save and later restore the values of a collection
of state variables on an attribute stack with the <i>glPushAttrib()</i>
and <i>glPopAttrib()</i> commands. Whenever possible, you should use these
commands rather than any of the query commands, since they're likely to
be more efficient.</li>

<li>
Refer to this site for more information:</li>

<br><a href="https://web.archive.org/web/20031113163410/http://www.hp.com/unixwork/products/grfx/OpenGL/Web/Reference/glEnable.html">http://www.hp.com/unixwork/products/grfx/OpenGL/Web/Reference/glEnable.html</a></ul>

<table border="">
<tbody><tr>
<td valign="CENTER">
<center>?</center>
</td>

<td valign="CENTER">Why would this be more efficient?</td>
</tr>
</tbody></table>

<p>
</p><hr>
<h2>
<a name="The_OpenGL_Programming_Guide_Auxiliary_L"></a>The OpenGL Programming
Guide Auxiliary Library</h2>

<ul>
<li>
OpenGL contains rendering commands but is designed to be independent of
any window system or operating system. Consequently, it contains no commands
for opening windows or reading events from the keyboard or mouse.</li>

<li>
The auxiliary library is intentionally simple, and it would be difficult
to build a large application on top of it. It's intended solely to support
the examples in the "OpenGL Programming Guide", but you may find it a useful
starting point to begin building real applications.</li>
</ul>

<h3>
<a name="Window_Management"></a>Window Management</h3>

<ul>
<li>
Three routines perform tasks necessary to initialise and open a window</li>

<ul>
<li>
<i>auxInitWindow()</i> opens a window on the screen. It enables the Escape
key to be used to exit the program, and it sets the background color for
the window to black.</li>

<li>
<i>auxInitPosition()</i> tells <i>auxInitWindow()</i> where to position
a window on the screen.</li>

<li>
<i>auxInitDisplayMode()</i> tells <i>auxInitWindow()</i> whether to create
an RGBA or color-index window. You can also specify a single- or double-buffered
window. (If you're working in color-index mode, you'll want to load certain
colors into the color map; use <i>auxSetOneColor()</i> to do this.) Finally,
you can use this routine to indicate that you want the window to have an
associated depth, stencil, and/or accumulation buffer.</li>
</ul>
</ul>

<h3>
<a name="Handling_Input_Events"></a>Handling Input Events</h3>

<ul>
<li>
You can use these routines to register callback commands that are invoked
when specified events occur.</li>

<ul>
<li>
<i>auxReshapeFunc()</i> indicates what action should be taken when the
window is resized, moved, or exposed.</li>

<li>
<i>auxKeyFunc()</i> and <i>auxMouseFunc()</i> allow you to link a keyboard
key or a mouse button with a routine that's invoked when the key or mouse
button is pressed or released.</li>
</ul>
</ul>

<h3>
<a name="Drawing_3_D_Objects"></a>Drawing 3-D Objects</h3>

<ul>
<li>
The auxiliary library includes several routines for drawing these three-dimensional
objects:</li>

<ul>
<li>
sphere, octahedron, cube, dodecahedron, torus, icosahedron, cylinder, teapot,
cone</li>
</ul>

<li>
You can draw these objects as wireframes or as solid shaded objects with
surface normals defined. For example, the routines for a sphere and a torus
are as follows:</li>
</ul>

<blockquote><i>void auxWireSphere(GLdouble radius);</i>
<br><i>void auxSolidSphere(GLdouble radius);</i>
<br><i>void auxWireTorus(GLdouble innerRadius, GLdouble outerRadius);</i>
<br><i>void auxSolidTorus(GLdouble innerRadius, GLdouble outerRadius);</i></blockquote>

<ul>
<li>
All these models are drawn centered at the origin. When drawn with unit
scale factors, these models fit into a box with all coordinates from -1
to 1. Use the arguments for these routines to scale the objects.</li>
</ul>

<h3>
<a name="Managing_a_Background_Process"></a>Managing a Background Process</h3>

<ul>
<li>
You can specify a function that's to be executed if no other events are
pending for example, when the event loop would otherwise be idle with <i>auxIdleFunc().</i>
This routine takes a pointer to the function as its only argument. Pass
in zero to disable the execution of the function.</li>
</ul>

<h3>
<a name="Running_the_Program"></a>Running the Program</h3>

<ul>
<li>
Within your <i>main()</i> routine, call <i>auxMainLoop()</i> and pass it
the name of the routine that redraws the objects in your scene. Example
1-2 shows how you might use the auxiliary library to create the simple
program shown in Example 1-1 .</li>
</ul>
<b><i>Example 1-2: A Simple OpenGL Program Using the Auxiliary Library:
simple.c</i></b>
<dir>
<pre><tt>/* Includes required */
#include &lt;GL/gl.h&nbsp;
#include "aux.h"
</tt>/*
* Clear the screen. Set the current color to white.&nbsp;
* Draw the wire frame cube.&nbsp;
*<tt>/
void display(void)</tt>&nbsp;
<tt>{
glClearColor (0.0, 0.0, 0.0, 0.0);</tt>&nbsp;
<tt>glClear(GL_COLOR_BUFFER_BIT);
glColor3f(1.0, 1.0, 1.0);</tt>&nbsp;
<tt>glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);</tt>&nbsp;
<tt>glBegin(GL_POLYGON);</tt>&nbsp;
<tt>&nbsp; glVertex2f(-0.5, -0.5);
&nbsp; glVertex2f(-0.5, 0.5);</tt>&nbsp;
<tt>&nbsp; glVertex2f(0.5, 0.5);</tt>&nbsp;
<tt>&nbsp; glVertex2f(0.5, -0.5);</tt>&nbsp;
<tt>glEnd();</tt>&nbsp;
<tt>glFlush();
}
/* Initialize shading model */
void myInit(void)</tt>&nbsp;
{
glShadeModel (GL_FLAT);
<tt>}
</tt>/*&nbsp;
* Called when the window is first opened and whenever&nbsp;
* the window is reconfigured (moved or resized).&nbsp;
*<tt>/
void myReshape(GLsizei w, GLsizei h)</tt>&nbsp;
<tt>{
glMatrixMode(GL_PROJECTION);
glLoadIdentity();</tt>&nbsp;
glFrustum (-1.0, 1.0, -1.0, 1.0, 1.5, 20.0); /* transformation */&nbsp;
glMatrixMode (GL_MODELVIEW); /* back to modelview matrix */&nbsp;
glViewport (0, 0, w, h); /* define the viewport */
}
/*&nbsp;
* Main Loop&nbsp;
* Open window with initial window size, title bar,&nbsp;
* RGBA display mode, and handle input events.&nbsp;
*<tt>/
int main(int argc, char** argv)&nbsp;
{
auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);</tt>&nbsp;
<tt>auxInitPosition (0, 0, 500, 500);</tt>&nbsp;
<tt>auxInitWindow (argv[0]);</tt>&nbsp;
myInit ();&nbsp;
auxReshapeFunc (myReshape);&nbsp;
auxMainLoop(display)<tt>;
}</tt></pre>
</dir>

<hr>
<h2>
<a name="Compilling_on_RCS"></a>Compilling on RCS</h2>

<ul>
<li>
There is an example Makefile in the VisClass/apps directory which can be
used as a template for future assignments.</li>
</ul>
<b><i>Example 1-3: Example Makefile for simple.c</i></b>
<pre><tt>#</tt>&nbsp;
<tt># Sample Makefile for compilling the sample code for the</tt>&nbsp;
<tt># Advanced Computer Graphics and Data Visualization 35.6961 (Fall 1995)</tt>&nbsp;
<tt>#</tt>&nbsp;
<tt># Copy this to the directory where the program resides and use</tt>&nbsp;
<tt>#&nbsp;
# make progname</tt>&nbsp;
<tt>#</tt>&nbsp;
<tt># The progname would be the prefix of the source file you generated.</tt>&nbsp;
<tt># Like if your source file was hw1.c, the above line would read:</tt>&nbsp;
<tt>#</tt>&nbsp;
<tt># make hw1</tt>&nbsp;
<tt>#</tt>&nbsp;
<tt># The make utility would automatically look for something with a suffix</tt>&nbsp;
<tt># it understood and would find hw1.c. There are built in rules which</tt>&nbsp;
<tt># tell it how to compile c source.
LIBS= -lGL -lGLU -laux -lXm -lXt -lX11 -lm</tt>&nbsp;
<tt>CFLAGS=-DAIXV3 -I/usr/include/GL</tt>&nbsp;
<tt>CC=cc
simple: simple.o</tt>&nbsp;
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CC) $(CFLAGS) -o $@ $? $(LIBS)
lorenz: lorenz.o</tt>&nbsp;
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CC) $(CFLAGS) -o $@ $? $(LIBS)
clean:</tt>&nbsp;
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /bin/rm -f *.o</tt></pre>
<b><i>Example 1-4: Results of the build process.</i></b>
<dir>
<pre><tt>% make simple
cc -DAIXV3 -I/usr/include/GL -c simple.c</tt>&nbsp;
<tt>cc -DAIXV3 -I/usr/include/GL -o simple simple.o -lGL -lGLU -laux -lXm -lXt -lX11 -lm</tt>&nbsp;
<tt>%</tt></pre>
</dir>

<ul>
<li>
Obviously there should be no warning or error messages as a result of the
build.</li>
</ul>

<p><br>
</p><hr>
<center>
<p>Copyright © 1999-2000, Thomas D. Citriniti, citrit@rpi.edu
<br>ECSE Dept., Rensselaer Polytechnic Inst., Troy NY, 12180 USA</p></center>








<!--
     FILE ARCHIVED ON 16:34:10 Nov 13, 2003 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:08:37 Aug 21, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</body></html>