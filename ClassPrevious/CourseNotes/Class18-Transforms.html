<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0100)https://web.archive.org/web/20030129214717/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="./Class18-Transforms_files/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app13.us.archive.org";archive_analytics.values.server_ms=99;</script>
<link type="text/css" rel="stylesheet" href="./Class18-Transforms_files/banner-styles.css">


   
   <meta name="GENERATOR" content="Mozilla/4.61C-CCK-MCD Caldera Systems OpenLinux [en] (X11; I; Linux 2.2.10 i586) [Netscape]">
   <title>ECSE-4750, RPI, Class 18</title>
<!-- Time-stamp: </home/wrf/cg-f99/Classes/24/index.html, Wed,  3 Nov 1999, 19:15:00 EST, wrf@benvolio.ecse.rpi.edu> -->
<style type="text/css">
<!--
H1 { color: red; }

H2 { color: blue; }

   OL.outline {list-style-type: upper-roman;
    font: bold italic 18pt sans-serif;}

   OL.outline OL {list-style-type: upper-alpha;
       font: bold 14pt sans-serif;}

   OL.outline OL OL {list-style-type: decimal;
	  font: 12pt serif;}

   OL.outline OL OL OL {list-style-type: lower-alpha;
	     font: 10pt serif;}

   OL.outline OL OL OL OL {list-style-type: lower-roman;
		font: 10pt sans-serif;}
   -->
</style>
</head>
<body bgcolor="#FFFFFF"><div id="wm-ipp" lang="en" style="display: block;" class="hi">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./Class18-Transforms_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20030129214717"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20021119172735/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="19 Nov 2002">NOV</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 21:47:17 Jan 29, 2003">Jun</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20040917132902/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="17 Sep 2004"><strong>SEP</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20021119172735/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="17:27:35 Nov 19, 2002"><img src="./Class18-Transforms_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 21:47:17 Jan 29, 2003">29</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20040917132902/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="13:29:02 Sep 17, 2004"><img src="./Class18-Transforms_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20010508132134/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="8 May 2001"><strong>2001</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 21:47:17 Jan 29, 2003">2000</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20040917132902/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="17 Sep 2004"><strong>2004</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20030129214717*/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" title="See a list of every capture for this URL">7 captures</a>
           <div class="r" title="Timespan for captures of this URL">8 May 01 - 30 Dec 04</div>
       </td>
       <td class="k">
       <a href="https://web.archive.org/web/20000601000000/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="500" height="27" border="0" src="./Class18-Transforms_files/graph.jsp">
       <div class="yt" style="display: inline; width: 25px; height: 27px; left: 100px;"></div><div class="mt" style="display: inline; width: 2px; height: 27px; left: 111px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20030129214717/http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./Class18-Transforms_files/disclaim-element.js"></script>
<script type="text/javascript" src="./Class18-Transforms_files/graph-calc.js"></script>
<script type="text/javascript" src="./Class18-Transforms_files/jquery.min.js"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.rpi.edu/dept/ecse/cg-s00/Classes/18/index.html";

var firstYear = 1996;
var imgWidth = 500,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "29";
var displayMonth = "Jan";
var displayYear = "2003";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<center>
<h1>
Rensselaer Polytechnic Institute<br>
ECSE-4750 Computer Graphics, Spring 2000<br>
Class 18</h1></center>

<center>
<hr width="100%"></center>

<h1>
Homework #7 Due Thursday March 23, 2000</h1>

<ol>
<li>
Use this CGWindow code to implement Excercise 5.1 in the Hearn &amp; Baker
text. You will need to add functions for the matrix transforms and storage
classes. You will need to look up the XtAppAddTimeOut in X and SetTimer
and WM_TIMER in Windows. Be careful, they both behave differently. Generate
a screen shot of multiple stages and hand in your code.</li>

<li>
Complete 5.2 in the text and hand in your work.</li>
</ol>

<h1>
From last time:</h1>

<ul>
<li>
We were discussing options of how to organize our graphics objects to best
fit our design criteria which are:</li>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Compact</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Since we know graphics data tends to be very large, we need to design our
structures to minimize computer memory requirements.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Efficient</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Scene data needs to be accessed many times and we would like to retrieve
and store data in our structures in constant time.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b> Mappable</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data representations need to efficiently map into graphics primitives.
We must be able to easily convert external data into internal
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graphics data structures.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Minimal Coverage</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
We must create a data representation that minimizes the number of data
types while covering a large portion of external data types.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
We wish to balance efficiency with the number of data types.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Simple</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Simple algorithms and data sets are easier to implement and also easier
to extend.
<li>
We will be using a collection based system in which we will use the STL
container classes for vectors.</li>

<li>
The CGWindow will collect Actors, Actors will collect shapes, and shapes
will hold pointers to geometries.</li>

<li>
This all works if we are looking at a static scene, but of course nothing
is static. We need geometry transformations to animate our scene.</li>
</ul>

<h1>
Two-Dimensional Geometric Transformations</h1>

<h3>
Basic Transformations:</h3>

<ul>
<li>
We will first look at the Cartesian coordinate transformations and then
apply matrix formulas which can be expressed in a more convenient form
that allows efficient combination of object transformations.</li>

<br>&nbsp;
<li>
<b>Translation</b>:</li>

<ul>
<li>
Translation is applied to an object by repositioning it along a straight
line path from one coordinate to another.</li>

<br>We translate a two-dimensional point by adding translation distances
tx and ty to the original coordinate position (x,y) to move the point to
a new position (x',y')
<pre><font size="+2">(1)&nbsp;&nbsp;&nbsp; x' = x + tx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y' = y + ty</font></pre>
&nbsp;
<li>
The translation distance pair (tx,ty) is called a <b>translation vector
</b>or
<b>shift
vector</b>.</li>

<li>
We can express the translation equations 1 as a single matrix equation
by using column vectors to represent coordinate positions and the translation
vector:</li>

<pre><font size="+2">(2)&nbsp;&nbsp;&nbsp; P = | x |&nbsp;&nbsp;&nbsp; P'= | x' |&nbsp;&nbsp;&nbsp; T = | tx |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y' |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ty |</font></pre>

<li>
This allows us to write the two-dimensional translation as:</li>

<br>&nbsp;
<pre><font size="+2">(3)&nbsp;&nbsp;&nbsp; P' = P + T</font></pre>

<li>
Translation is a <i>rigid-body transformation</i> that moves an object
without deformation.</li>

<li>
Every point on the object is translated by the same amount.</li>

<li>
A Line segment is translated by applying the translation vector to each
of the endpoints and redrawing the object at these new points.</li>

<li>
A Polygon is translated by applying the translation vector to the coordinate
of each vertex and then regenerating the polygon at these new points.</li>

<li>
Similar methods can be used to translate circular objects. The control
points for these objects are translated and then each object is redrawn
using these new control points.</li>

<br>&nbsp;</ul>

<li>
<b>Rotation</b>:</li>

<ul>
<li>
Rotations are applied to an object by repositioning it along a circular
path in the xy plane.</li>

<li>
To generate a rotation we specify a <b>rotation angle</b> <b><i>0</i></b>
and the position (xr,yr) of the <b>rotation point</b> (or <b>pivot point)</b>
about which the object is to be rotated.</li>

<li>
Positive values define counter clockwise rotations and negative values
specify clockwise rotations.</li>

<li>
We will first define rotation formula for rotations about the origin</li>

<li>
In this formula <b><i>r</i></b> is the distance from the origin to the
point, <b><i>@</i></b> is the original rotation angle of the vector to
the original point, and <b><i>0 </i></b>is the desired rotational angle.</li>

<pre><font size="+2">(4)&nbsp;&nbsp;&nbsp; x' = </font><b><i>r</i></b><font size="+2"> cos(</font><b><i>@</i></b><font size="+2">+</font><b><i>0</i></b><font size="+2">) = </font><b><i>r</i></b><font size="+2"> cos(@)cos(</font><b><i>0</i></b><font size="+2">) - </font><b><i>r</i></b><font size="+2"> sin(@)sin(</font><b><i>0</i></b><font size="+2">)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y' = </font><b><i>r</i></b><font size="+2"> sin(</font><b><i>@</i></b><font size="+2">+</font><b><i>0</i></b><font size="+2">) = </font><b><i>r</i></b><font size="+2"> cos(@)sin(</font><b><i>0</i></b><font size="+2">) - </font><b><i>r</i></b><font size="+2"> sin(@)cos(</font><b><i>0</i></b><font size="+2">)</font></pre>

<li>
The original coordinates of the points in polar coordinate are:</li>

<pre><font size="+2">(5)&nbsp;&nbsp;&nbsp; x = </font><b><i>r</i></b><font size="+2"> cos(</font><b><i>@</i></b><font size="+2">)&nbsp;&nbsp;&nbsp; y = </font><b><i>r</i></b><font size="+2"> sin(</font><b><i>@</i></b><font size="+2">)</font></pre>

<li>
Substituting expressions 5 into 4 we get an equation for rotating a point
through an angle <b><i>0</i></b> about the origin:</li>

<pre><font size="+2">(6)&nbsp;&nbsp;&nbsp; x' = x cos(</font><b><i>0</i></b><font size="+2">) - y sin(</font><b><i>0</i></b><font size="+2">)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y' = x sin(</font><b><i>0</i></b><font size="+2">) + y cos(</font><b><i>0</i></b><font size="+2">)</font></pre>

<li>
We can write these equations in a matrix form:</li>

<pre><font size="+2">(7)&nbsp;&nbsp;&nbsp; P' = R<sup>.</sup>P</font></pre>

<li>
Where the rotation matrix is</li>

<pre><font size="+2">(8)&nbsp;&nbsp;&nbsp; R = |cos(</font><b><i>0</i></b><font size="+2">)&nbsp; -sin(</font><b><i>0</i></b><font size="+2">)|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |sin(</font><b><i>0</i></b><font size="+2">)&nbsp;&nbsp; cos(</font><b><i>0</i></b><font size="+2">)|</font></pre>

<li>
Rotation about an arbitrary pivot position is</li>

<pre><font size="+2">(9)&nbsp;&nbsp;&nbsp; x' = xr + (x - xr)cos(</font><b><i>0</i></b><font size="+2">) - (y - yr)sin(</font><b><i>0</i></b><font size="+2">)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y' = yr + (x - xr)sin(</font><b><i>0</i></b><font size="+2">) + (y - yr)cos(</font><b><i>0</i></b><font size="+2">)</font></pre>

<li>
This equation introduces the pivot point as a additive terms to the original
points.</li>

<li>
We could add these terms to the transformation matrix by including the
pivot point transformation. We will see in a moment a better way to handle
this translation.</li>

<li>
As with Translations, Rotations are rigid-body transformations that move
objects without deformation.</li>

<br>&nbsp;</ul>

<li>
<b>Scaling</b>:</li>

<ul>
<li>
This transformation alters the size of an object by multiplying the coordinate
values of each vertex by <b>scaling factors</b> sx and sy.</li>

<pre><font size="+2">(10)&nbsp;&nbsp;&nbsp; x' = x * sx&nbsp;&nbsp;&nbsp; y' = y * sy</font></pre>

<li>
Scaling factor sx scales in the x direction while sy scales in the y direction.</li>

<li>
These equations can be written using matrix form:</li>

<pre><font size="+2">(11)&nbsp;&nbsp;&nbsp; | x' | = | sx&nbsp; 0&nbsp; | . | x |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y' |&nbsp;&nbsp; | 0&nbsp;&nbsp; sy |&nbsp;&nbsp; | y |</font></pre>

<li>
or</li>

<pre><font size="+2">(12)&nbsp;&nbsp;&nbsp; P' = S<sup>.</sup>P</font></pre>

<li>
Where S is the two by two scaling matrix in 11.</li>

<li>
Any positive scaling factors can be applied. Values less than one reduce
the size of the object while values greater than one enlarge the object.</li>

<li>
Using a value of 1 leaves the object unchanged.</li>

<li>
When sx and sy are assigned the same value,&nbsp; a <b>uniform scaling</b>
is produced keeping the objects proportions equal.</li>

<li>
Specifying different values for sx and sy results in <b>differential scaling</b>.
This can be used in applications that specify a few basic building blocks
that can be modified and transformed using scaling and transformations.
This is an important factor in our design criteria concerning</li>

<li>
The scaling performed by equation 11 both scales and translates objects.
Again because the scaling is performed about the coordinate origin.</li>

<li>
We can control where the scaling origin is by specifying a position, called
the <b>fixed point,</b> that will remain unchanged after the scaling procedure.</li>

<li>
Similar to to the rotation equation, we will add the fixed point to equation
10:</li>

<pre><font size="+2">(13)&nbsp;&nbsp;&nbsp; x' = xf + (x - xf)sx&nbsp;&nbsp;&nbsp; y' = yf + (y - yf)sx</font></pre>

<li>
We can rewrite these to separate the multiplicative and additive terms:</li>

<pre><font size="+2">(14)&nbsp;&nbsp;&nbsp; x' = x<sup>.</sup>sx + xf(1 - sx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y' = y<sup>.</sup>sy + yf(1 - sy)</font></pre>

<li>
where the additive terms xf(1-sx) and yf(1-sy) are constant for all points
in the object.</li>

<li>
Including coordinates for the fixed point int he scaling equation is similar
o including coordinates for a pivot point in the rotations equations.</li>

<li>
We can setup a column vector whose elements are the constant terms in 14,
then we add this column vector to the product <b>S<sup>.</sup>P</b> in
12.</li>

<li>
We of course would like to reduce this to matrix multiplication to reduce
our work and combine all operations into matrix multiplication.</li>

<li>
Polygons and lines are scaled by applying transformations 14 to each vertex
and then regenerating or drawing the objects.</li>

<li>
Other objects are scaled by applying the appropriate equations to the term
defining the object. An ellipse is resized by scaling the semi major and
semi minor axes and redrawing the object. Uniform scaling of a circle is
done by adjusting the radius.</li>
</ul>
</ul>

<h3>
Matrix Representations and Homogeneous Coordinates:</h3>

<ul>
<li>
Animation and simulation systems require many changes to an objects appearance
for every step of the animation.</li>

<li>
If there are many objects in your animation then you will have a great
deal of work for each frame.</li>

<li>
First we look at the general matrix form of our transformations:</li>

<pre><font size="+2">(15)&nbsp;&nbsp;&nbsp; P' = M1<sup>.</sup>P + M2</font></pre>

<li>
where positions P and P' are represented as column vectors.</li>

<li>
Matrix M1 is a 2 by 2 array containing multiplicitive factors and M2 is
a 2 element column matrix containing translational terms.</li>

<li>
For translation, Matrix M1 is the identity matrix.</li>

<li>
For rotation or scaling, M2 contains the translational terms associated
with the pivot point or scaling fixed point.</li>

<li>
To reproduce a transformation, these equations have to be applied in a
specific sequence to produce the desired effect.</li>

<li>
We must calculate the transformed coordinates one step at a time.</li>

<li>
First coordinate positions are scaled, then these scaled coordinates are
rotated, and finally the scaled coordinates are rotated.</li>

<li>
A more efficient approach would be to combine transformations so that the
final coordinate transformations are obtained directly from the initial
coordinates.</li>

<li>
To do this we need to reformulate 15 to eliminate the matrix addition associated
with the translational terms.</li>

<li>
We can combine the multiplicative and translational terms for two-dimensional
geometric transformations into a single matrix representation by expanding
the 2 by 2 matrix representations to a 3 by 3 matrices.</li>

<li>
We can then express all transformations as matrix multiplication provided
we expand the matrix representations for coordinate positions.</li>

<li>
The coordinate position (x,y) will be replaced with the homogeneous coordinate
triple <i>(xh,yh,h)</i>, where:</li>

<pre><font size="+2">(16)&nbsp;&nbsp;&nbsp; x = xh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = yh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h</font></pre>

<li>
This representation can also be written as <i>(h.x,h.y,h)</i>.</li>

<li>
For two-dimensional geometric transformations we can choose any value for
h thus giving an infinite number of representations for coordinate point
<i>(x,y)</i></li>

<li>
An obvious choice is to pick h=1 and our coordinates reduce to <i>(x,y,1)</i>.</li>

<li>
Using homogenous representations of coordinates allows us to represent
equations containing x and y as homogeneous equations using x,y, and h.</li>

<li>
This simply means that if each of the three parameters is replaced by any
value v times that parameter, the value v can be factored out of the equations.</li>

<li>
This frees us to reduce all transformations to matrix multiplication.</li>

<li>
Coordinates are represented as a three element column vector and transformation
operations as 3 by 3 matrices.</li>

<li>
For translation we have:</li>

<pre><font size="+2">(17)&nbsp;&nbsp;&nbsp; | x' |&nbsp;&nbsp; | 1&nbsp; 0&nbsp; tx |&nbsp;&nbsp; | x |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y' | = | 0&nbsp; 1&nbsp; ty | . | y |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp; |&nbsp;&nbsp; | 0&nbsp; 0&nbsp;&nbsp; 1 |&nbsp;&nbsp; | 1 |</font></pre>

<li>
which can be expressed as:</li>

<pre><font size="+2">(18)&nbsp;&nbsp;&nbsp; P' = T(tx,ty)<sup>.</sup>P</font></pre>

<li>
where T(tx,ty) is the 3 by 3 translation matrix in 17.The inverse is obtained
by replacing tx and ty with -tx and -ty.</li>

<li>
The rotation transformation equations about the coordinate origin can be
expressed</li>

<pre><font size="+2">(19)&nbsp;&nbsp;&nbsp; | x' |&nbsp;&nbsp; | cos(@) -sin(@) 0 |&nbsp;&nbsp; | x |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y' | = | sin(@)&nbsp; cos(@) 0 | . | y |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp; |&nbsp;&nbsp; |&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp; | 1 |</font></pre>

<li>
or as</li>

<pre><font size="+2">(20)&nbsp;&nbsp;&nbsp; P' = R(@)<sup>.</sup>P</font></pre>

<li>
where R(@) is the 3 by 3 translation matrix in 17. The inverse rotations
is obtained by using -@</li>

<li>
Finally the scaling transformation relative to the coordinate origin is:</li>

<pre><font size="+2">(21)&nbsp;&nbsp;&nbsp; | x' |&nbsp;&nbsp; | sx&nbsp; 0&nbsp; 0 |&nbsp;&nbsp; | x |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y' | = | 0&nbsp; sy&nbsp; 0 | . | y |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp; |&nbsp;&nbsp; | 0&nbsp;&nbsp; 0&nbsp; 1 |&nbsp;&nbsp; | 1 |</font></pre>

<li>
or</li>

<pre><font size="+2">(22)&nbsp;&nbsp;&nbsp; P' = S(sx,sy)<sup>.</sup>P</font></pre>

<li>
where S(sx,sy) is the 3 by 3 matrix in 21. Replacind sx and sy with 1/sx
and 1/sy produces the inverse scaling matrix.</li>

<li>
Matrix representations are standard methods for implementing transformaitons
in graphics systems.</li>

<li>
Some APIs provide these functions which only produce transformations about
the coordinate origin.</li>

<li>
We are then forced to translate our objects to the coordinate origin ,
sclale, rotate, and then transform back to the final position.</li>

<li>
Alternately we would like to specify our fixed and pivot point coordinates
to our transforms to minimize operations.</li>
</ul>

<h3>
Composite Transformations:</h3>

<ul>
<li>
Composite transformations allow us to combine succesive transforms by calculating
the matrix product of the individual transformations.</li>

<li>
forming products of transformation matrices is often refered to as a <b>concatenation</b>,
or <b>composition</b>, of matrices.</li>

<li>
For column matrix representaions of coordinate positions we form these
composite transformations by multiplying matrices in order from right to
left.</li>

<li>
Each successive transformation matrix premultiplies the product of the
preceding transformaiton matrices.</li>

<br>&nbsp;
<li>
<b>Translations</b>:</li>

<ul>
<li>
If two successive translation vectors (tx1,ty1) and (tx2,ty2) are applied
to position P, P' is calculated as:</li>

<pre><font size="+2">(23)&nbsp;&nbsp;&nbsp; P' = T(tx2,ty2).{T(tx1,ty1).P}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = {T(tx2,ty2).T(tx1,ty1)}.P</font></pre>

<li>
where P and P' homogenous coordinate column vectors.</li>

<br>&nbsp;</ul>

<li>
<b>Rotations</b>:</li>

<ul>
<li>
Two succesive rotations applied to point P produce the transformed position:</li>

<pre><font size="+2">(26)&nbsp;&nbsp;&nbsp; P' = R(@2)<sup>.</sup>{R(@1)<sup>.</sup>P}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = {R(@2)<sup>.</sup>R(@1)}<sup>.</sup>P</font></pre>

<li>
By multiplying the the two rotation matrices, we can verify that two succesive
rotations are additive:</li>

<pre><font size="+2">(27)&nbsp;&nbsp;&nbsp; R(@2)<sup>.</sup>R(@1) = R(@1 + @2)</font></pre>

<li>
so the final rotated coordinates can can be calculated with the composite
rotation matrix as</li>

<pre><font size="+2">(28)&nbsp;&nbsp;&nbsp; P' = R(@1 + @2)<sup>.</sup>P</font></pre>
</ul>

<li>
<b>Scalings:</b></li>

<ul>
<li>
Concatenating transformation matrices for two succesive scaling operations
produces the following:</li>

<pre><font size="+2">(30)&nbsp;&nbsp;&nbsp; S(sx2,sy2)<sup>.</sup>S(sx1,sy1) = S(sx1<sup>.</sup>sx2,sy1<sup>.</sup>sy2)</font></pre>

<li>
The resulting matrix indicates that succesive scaling operations are multiplicative.</li>

<li>
That is, if we were to triple the size of an object twice in succesion,
the final object would be nine times the original.</li>

<br>&nbsp;</ul>

<li>
<b>General Pivot-Point Rotation:</b></li>

<ul>
<li>
Again some graphics packages only supply rotations about the coordinate
origin.</li>

<li>
We can generate rotations about pivot points by using the following sequence
of steps:</li>

<ol>
<li>
Translate the object so the pivot point is at the origin.</li>

<li>
Rotate the object about the origin</li>

<li>
Translate the object from the origin to the original pivot point.</li>
</ol>

<li>
This can be expressed as:</li>

<pre><font size="+2">(32)&nbsp;&nbsp;&nbsp; T(xr,tr)<sup>.</sup>R(@)<sup>.</sup>T(-xr,-yr) = R(xr,yr,@)</font></pre>
</ul>

<li>
<b>General Fixed-Point Scaling:</b></li>

<ul>
<li>
Similar to fixed point rotation, we can perform scaling about a fixed point
by following these steps:</li>

<ol>
<li>
Translate the object so the pivot point is at the origin.</li>

<li>
Scale the object about the origin</li>

<li>
Translate the object from the origin to the original pivot point.</li>
</ol>

<li>
Which produces the following sequence:</li>

<pre><font size="+2">(34)&nbsp;&nbsp;&nbsp; T(xf,yf)<sup>.</sup>S(sx,sy)<sup>.</sup>T(-xf,-yf) = S(xf,yf,sx,sy)</font></pre>
</ul>

<li>
<b>Concatenation Properites:</b></li>

<ul>
<li>
Matrix multiplication is associative.</li>

<pre><font size="+2">(36)&nbsp;&nbsp;&nbsp; A<sup>.</sup>B<sup>.</sup>C = (A<sup>.</sup>B)<sup>.</sup>C = A<sup>.</sup>(B<sup>.</sup>C)</font></pre>

<li>
Conversely matrix products are not commutative. A.B is not equal to B.A,
in general.</li>

<li>
This means we need to be careful of the order with which the composite
matrix is evaluated. Some transformations are commutative, for instance
two successive rotations can be performed in either order. The same is
true for scaling.</li>

<li>
Concatenating the matrices also reduces the total number of operations
needed to transform positions.</li>

<li>
Standard matrix dot products requires nine multiplications and six additions.
Our matrix representaion with homogenous coordinates reduces the transform
equations to:</li>

<pre><font size="+2">(39)&nbsp;&nbsp;&nbsp; x' = x<sup>.</sup>rsxx + y<sup>.</sup>rsxy + trsx&nbsp;&nbsp;&nbsp; y' = x<sup>.</sup>rsyx + y<sup>.</sup>rsyy + trsy</font></pre>

<li>
This requires four multiplications and four additions, greatly reducing
our processing requirements.</li>

<li>
This is also the maximum number of computations required for any transformation
sequence, once the individual matrices have been concatenated and the elements
of the compoosite matrix are evaluated. (Kinda cool).</li>

<li>
An implementation would be to formulate transformational matrices, concatentate
any transformation sequence, and calculate transformed coordinates using
39.</li>

<br>&nbsp;</ul>
</ul>

<h3>
Speaking of Implementations</h3>

<ul>
<li>
Great, we have a way to transform points, now how do we apply this?</li>

<li>
The most obvious way is to have a transform associated with each geoemtry
object. This takes care of the individual objects.</li>

<li>
How about the Viewpoint, how do we move that?</li>

<li>
&nbsp;</li>
</ul>

<br>&nbsp;
<p>
</p><hr>
<center>
<p>Copyright © 1999-2000, Thomas D. Citriniti, citrit@rpi.edu
<br>ECSE Dept., Rensselaer Polytechnic Inst., Troy NY, 12180 USA</p></center>








<!--
     FILE ARCHIVED ON 21:47:17 Jan 29, 2003 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:57:25 Aug 21, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</body></html>