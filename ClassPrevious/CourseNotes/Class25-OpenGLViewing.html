<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0100)https://web.archive.org/web/20030912092049/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="./Class25-OpenGLViewing_files/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app10.us.archive.org";archive_analytics.values.server_ms=86;</script>
<link type="text/css" rel="stylesheet" href="./Class25-OpenGLViewing_files/banner-styles.css">


   
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.61C-CCK-MCD Caldera Systems OpenLinux [en] (X11; I; Linux 2.2.10 i586) [Netscape]">
   <title>ECSE 475 Class 25</title>
</head>
<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080"><div id="wm-ipp" lang="en" style="display: block;" class="hi">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./Class25-OpenGLViewing_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20030912092049"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20030626030347/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="26 Jun 2003">JUN</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 9:20:49 Sep 12, 2003">Jun</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20031113163324/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="13 Nov 2003"><strong>NOV</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20030626030347/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="3:03:47 Jun 26, 2003"><img src="./Class25-OpenGLViewing_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 9:20:49 Sep 12, 2003">12</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20031113163324/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="16:33:24 Nov 13, 2003"><img src="./Class25-OpenGLViewing_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20020320165837/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="20 Mar 2002"><strong>2002</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 9:20:49 Sep 12, 2003">1999</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20040917132926/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="17 Sep 2004"><strong>2004</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20030912092049*/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" title="See a list of every capture for this URL">9 captures</a>
           <div class="r" title="Timespan for captures of this URL">8 May 01 - 22 Jan 05</div>
       </td>
       <td class="k">
       <a href="https://web.archive.org/web/19990601000000/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="500" height="27" border="0" src="./Class25-OpenGLViewing_files/graph.jsp">
       <div class="yt" style="display: inline; width: 25px; height: 27px; left: 75px;"></div><div class="mt" style="display: inline; width: 2px; height: 27px; left: 86px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20030912092049/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./Class25-OpenGLViewing_files/disclaim-element.js"></script>
<script type="text/javascript" src="./Class25-OpenGLViewing_files/graph-calc.js"></script>
<script type="text/javascript" src="./Class25-OpenGLViewing_files/jquery.min.js"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/index.html";

var firstYear = 1996;
var imgWidth = 500,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "12";
var displayMonth = "Sep";
var displayYear = "2003";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<center>
<h1>
Rensselaer Polytechnic Institute<br>
ECSE-4750 Computer Graphics, Spring 2000<br>
Class 25</h1></center>

<hr align="LEFT" width="75%">
<h2>
<a name="Viewing"></a>Viewing</h2>

<ul>
<li>
There is a transformation process to produce the desired results when viewing
a geometric model and it is analogous to taking a photo with a camera.
The same steps are required to setup the viewing position using OpenGL
transformations. These steps are:</li>
</ul>

<ol>
<ol>
<li>
Setting the position of the camera (on a tripod) and aiming the camera
at the scene. (viewing transformation)</li>

<li>
Arrange the scene and components in the desired positions and orientation.
(modelling transformation)</li>

<li>
Choose the camera lens and adjust the zoom. (projection transformation)</li>

<li>
Determine the size of the final output. (viewport transformation)</li>
</ol>
</ol>

<ul>
<li>
After these steps are complete the picture can be taken or the geometry
can be rendered to the frame buffer. OpenGL uses transformations based
on the current transformation matrix.</li>

<li>
The Viewing Transformation matrix is manipulated using <b>glTranslatef()</b>
and since this command accumulates transformations, it is important to
clear the matrix using <b>glLoadIndentity().</b> It is important to set
the current transformation matrix by using:</li>
</ul>

<dl>
<dt>
void <b>glMatrixMode</b>(GLenum <i>mode</i>);</dt>

<dd>
Specifies whether the modelview, projection, or texture matrix will be
modified using the GL_MODELVIEW, GL_PROJECTION, or GL_TEXTURE for <i>mode</i>.
Subsequent transformation commands manipulate the specified matrix. Note
that only one matrix can be modified at a time. By default, the modelview
matrix is the one that is modifiable, and all three matrices contain the
identity matrix.</dd>
</dl>

<ul>
<li>
The general purpose transformation commands are <i>glLoadIdentity(), glLoadMatrix*(),
glMultMatrix*(), slTranslate*(), glScale*(), and glRotate*()</i>.</li>
</ul>

<h3>
Perspective View</h3>

<ul>
<li>
The glFrustum() routine creates a matrix for a perspective-view frustum
and multiplies the current matrix by it.</li>
</ul>

<h3>
Orthographic Projection</h3>

<ul>
<li>
An orthographic projection creates a viewing volume that resembles a box.
It is created using:</li>
</ul>

<dl>
<dt>
void <b>glOrtho</b>(GLdouble <i>left</i>, Gldouble <i>right</i>, Gldouble
<i>bottom</i>,
Gldouble <i>top</i>,</dt>

<dt>
Gldouble <i>near</i>, Gldouble <i>far</i>);</dt>

<dd>
Creates a matrix for an orthographic parallel viewing volume and multiplies
the current matrix by it. The near clipping plane is a rectangle with the
lower left corner at (<i>left, bottom, -near</i>) and the upper right corner
at (<i>right, top, -near</i>). The far clipping plane is a rectangle with
corners at (<i>left, bottom, -far</i>) and (<i>right, top, -far</i>). Both
<i>near</i>
and <i>far</i> can be positive or negative.</dd>
</dl>

<h3>
Viewport Transformation</h3>

<ul>
<li>
The viewport transformation corresponds to the stage where the size of
the final image is chosen. It is specified using:</li>
</ul>

<dl>
<dt>
void <b>glViewPort</b>(GLint <i>x</i>, Glint <i>y</i>, Glsizei <i>width</i>,
Glsizei <i>height</i>);</dt>

<dd>
Defines a pixel rectangle in the window into which the final image is mapped.
The (<i>x, y</i>) parameter specifies the lower left corner of the viewport,
and <i>width</i> and <i>height</i> are the size of the viewport rectangle.
By default, the initial viewport values are (<i>0, 0, winWidth, winHeight</i>).</dd>
</dl>

<h3>
Additional Clipping Planes</h3>

<ul>
<li>
In addition to the six clipping planes of the viewing volume you can define
up to six additional clipping planes to further restrict the viewing volume.</li>

<li>
Each plane is defined by the coefficients of its equation: Ax+By+Cz+D=0.
The clipping planes are automatically transformed appropriately by the
modelling and viewing transformations. They are created using:</li>
</ul>

<dl>
<dt>
void <b>glClipPlane</b>(GLenum <i>plane</i>, const Gldouble *<i>equation</i>);</dt>

<dd>
Defines a clipping plane. The <i>equation</i> argument points to the four
coefficients of the plane equation, Ax+By+Cz+D=0.</dd>
</dl>

<hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="Display_Lists"></a>Display Lists</h2>

<ul>
<li>
A display List is a group of OpenGL commands that have been stored for
later execution. When a display list is invoked, the commands in it are
executed in the order they were issued.</li>

<li>
An example of using a display list may be that you need to draw a circle
many times in an OpenGL session. Your options are:</li>
</ul>

<ol>
<ol>
<li>
Create a loop to calculate the circle based on cosines and sines of arc
segments. This requires you to calculate the coordinates of the endpoints
each time the circle is drawn.</li>

<li>
You could store the coordinates of the endpoints of the circle segments
in an array and pull them out as needed. This would incur the overhead
of an extra variable, looping, and the actual test condition of the loop.</li>

<li>
What you would like is to define the circle once to OpenGL and have the
ability to send one command to OpenGL to draw the circle again. We assume
the developers of the library code are optimizing memory and the internal
drawing aspect of the code.</li>
</ol>
</ol>

<ul>
<li>
A display list is created much the way we have defined drawing to OpenGL
in the previous examples. The difference being is you replace glBegin()
with glNewList() and replace glEnd() with glEndList(). These commands are
defined as:</li>
</ul>

<dl>
<dt>
void <b>glNewList</b>(GLuint list, GLenum mode);</dt>

<dd>
Specifies the start of the list. All but a few restricted OpenGL calls
are stored in the list (restricted routines are executed immediately during
the creation of the display list). The list parameter is a unique positive
integer that identifies the display list. The possible values for the mode
parameter are GL_COMPILE and GL_COMPILE_AND_EXECUTE. Use GL_COMPILE if
you don't want the following OpenGL commands to actually display as they
are placed in the display list.</dd>
</dl>

<h3>
What's stored in the display list.</h3>

<ul>
<li>
When you build the display list, only the values for the expressions are
stored in the list. If the values in an array are subsequently changed,
the display list values don't change.</li>
</ul>

<h3>
What 's not stored in the display list:</h3>
Here are the commands that are not stored in the display list:
<dir>
<pre><tt>glDeleteLists()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glIsEnabled()
glFeedbackBuffer()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glIsList()
glFinish()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPixelStore()
glFlush()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glReadPixels()
glGenLists()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRenderMode()
glGet()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glSelectBuffer()</tt></pre>
</dir>

<h3>
Executing Display lists</h3>

<ul>
<li>
After you have created a display list, you can execute it by calling glCallList().
You can execute the same display list as many times as you want and you
an also intermix calls to different display lists to perform immediate
mode graphics.</li>
</ul>

<dl>
<dt>
void <b>glCallList</b>(GLuint list);</dt>

<dd>
This routine executes the display list specified by list. The commands
in the display list are executed in the order they were saved. If list
has not been saved then nothing happens.</dd>
</dl>

<hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="The_Color_Model"></a>The Color Model</h2>

<ul>
<li>
On a computer screen, the hardware causes each pixel on the screen to emit
different amount of red, green, and blue light (these are called the RGB
values). This is referred to as the RGB mode.</li>

<li>
OpenGL also supports a color-index display mode which uses a color map
(or lookup table) which is similar to using a palette to mix paints to
prepare for a paint by the numbers scene. This useful if you are coloring
a scene based on some external scalar value associated with the geometry.</li>

<li>
You should base you decision on which color model you use on the hardware
available and also on your application needs.</li>

<li>
To specify a color to OpenGL in RGB mode use:</li>
</ul>

<dl>
<dt>
void <b>glColor[34]{b s i f d ub us ui}[v](TYPE {r, *v}[,TYPE r, TYPE g,
TYPE b [,TYPE a])</b>;</dt>

<dd>
Sets the current R,G,B, and Alpha values. If you do not specify an Alpha
value it is set to one.</dd>
</dl>

<ul>
<li>
To specify a color in the color-index mode use:</li>
</ul>

<dl>
<dt>
void <b>glIndex{sifd}[v]([const] TYPE [*]c)</b>;</dt>

<dd>
Sets the current color index. The first suffix for this command indicates
the data type for parameters: short, integer, float, or double. The second
option suffix is v, which indicates that the argument is an array of values
of the given data type (the array contains only one value).</dd>
</dl>

<table border="">
<tbody><tr>
<td valign="CENTER">
<center>?</center>
</td>

<td valign="CENTER">What are a few examples of uses of the two modes.</td>
</tr>
</tbody></table>

<h3>
Specifying a Shading Model</h3>

<ul>
<li>
A line or filled polygon can be drawn with a single color (flat shading)
or with many different colors (smooth shading, also called Gouraud Shading).
You specify the desired shading model using:</li>
</ul>

<dl>
<dt>
void <b>glShadeModel</b>(GLenum <i>mode</i>);</dt>

<dd>
Sets the shading model. The <i>mode</i> parameter can be either GL_SMOOTH
(the default) or GL_FLAT.</dd>
</dl>

<ul>
<li>
With flat shading, the color of one vertex of a primitive is duplicated
across the primitives vertices. With smooth shading, the color at each
vertex is treated individually. For a line, the colors along the line segment
are interpolated between the vertex colors. For a polygon, the colors for
the interior of the polygon are interpolated between the vertex colors.
This is the behaviour we want to see when dealing with data visualization.</li>
</ul>

<hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="Lighting"></a>Lighting</h2>

<ul>
<li>
In the real world when we view a surface and its color, we are actually
seeing the distribution of photon energies that arrive at your eye and
trigger your cone cells. Those photons come from various light sources,
some of which are absorbed and some of which are reflected.</li>

<li>
OpenGL approximates light and lighting as if light can be broken into red,
green, and blue components. The color of light sources is characterized
by the amount of red, green, and blue light they emit. The material of
surfaces is characterized by the percentage of the incoming red, green,
and blue components that are reflected in various directions.</li>
</ul>

<h3>
Emitted, Ambient, Diffuse, and Specular Light</h3>

<ul>
<li>
Emitted light is the simplest, it originates from an object and is unaffected
by any light sources.</li>

<li>
The ambient component is the light from that source that's been scattered
so much by the environment that its direction is impossible to determine.
When ambient light strikes a surface it is scattered in all directions.</li>

<li>
Diffuse light comes from one direction, so it is brighter if it comes down
squarely on the surface rather than at an angle. Any light coming from
any direction has a diffuse component.</li>

<li>
Specular light comes from a direction and bounces off a surface in a particular
direction. Shiny metal and plastic have a high specular component and chalk
and carpet have almost none. You can think of specularity as shininess.</li>
</ul>

<h3>
Material Colors</h3>

<ul>
<li>
Material colors control the amount of red, green, and/or blue components
that are reflected off a surface. If only the red component is specified
for a surfaces then when a white light is pointed at that surface, the
red component is reflected and the green and blue component is absorbed.
If a pure red light is used, the surface is still red. If a green or blue
light is used the surface is black because the green and blue components
are absorbed.</li>
</ul>

<h3>
Creating Light Sources</h3>

<ul>
<li>
Light sources are created with a number of different properties to control
their color and source type. to create a light use:</li>
</ul>

<dl>
<dt>
void <b>glLight</b>{if}[v](GLenum <i>light</i>, GLenum <i>pname</i>, TYPE
<i>param</i>);</dt>

<dd>
This creates a light specified by <i>light</i> which can be GL_LIGHT0,
GL_LIGHT1.., or GL_LIGHT7. The characteristic of the light being set is
defined by <i>pname</i> which specifies a named parameter. The param argument
indicates the values to which the <i>pname</i> characteristic is set. It
is a pointer to a group of values if the vector value is used, or the value
itself if the nonvector version is used.</dd>
</dl>

<hr>
<p>
</p><hr align="LEFT" width="75%">
<h2>
<a name="Texture_Mapping"></a>Texture Mapping</h2>

<ul>
<li>
Texture maps are simply bitmaps that are pasted onto a surface. The bitmap
can be any image, like a scanned image of a brick wall or a concrete surface
or maybe a sunset. When you paste a texture on a polygon, the system ensures
that all the transformations applied to the underlying geometry are also
performed to the bitmap. Textures can also be applied to all the other
geometric primitives: points, lines, polygons, bitmaps, and images.</li>

<li>
Textures are simply rectangular arrays of data, the individual values in
a texture array are sometimes called texels.. Our job is to tell OpenGL
how to orient the geometric primitive in the rectangular texture array.</li>
</ul>

<h3>
Specify the Texture</h3>

<ul>
<li>
The texture is a single image and is usually thought of as being two dimensional,
but it can also be one dimensional. The data describing the texture map
ca be one, two, three, or four values per texel, usually representing the
RGBA quadruple for the color.</li>

<li>
Using an advanced method called mipmapping, you can specify a single a
single texture in different resolutions, this allows you to avoid mapping
a full resolution texture map on a wall that is far in the distance. This
is the idea of level of detail based on a distance from an observer, why
not draw the least costly texture that will do the job.</li>
</ul>

<h3>
Indicate how the texture is to be applied to Each Pixel</h3>

<ul>
<li>
There are three different choices you have in applying the texture map
to the geometric primitive. First you ca simply specify the texel value
as the final pixel color, this is the decal mode in which the texture is
painted on the surface. Next you could use the texture to modulate or scale
the fragments color. This technique is useful in combining the effects
of lighting and texturing. Finally you could specify that a constant color
be blended with that of the fragment based on texture value.</li>
</ul>

<h3>
Enabling Texture Mapping</h3>

<ul>
<li>
You need to enable texture mapping before drawing your scene. Texturing
is enabled or disables using glEnable() or glDisable() with the symbolic
constant GL_TEXTURE_1D or GL_TEXTURE_2D for one or two dimensional respectively.</li>
</ul>

<h3>
Draw the Scene Supplying both Texture and Geometric Coordinates</h3>

<ul>
<li>
You need to specify how the texture is to be aligned relative to the geometric
fragments to which it's to be applied before it is glued on. If you want
to paste an image of bricks onto a square, you would probably assign texture
coordinates (0,0), (1,0), (1,1), and (0,1) to the four corners of the wall.
If the wall is large you may want to specify several copies of the texture
to cover the whole wall, in this case the texture should be designed so
that the bricks on the right side of the image blend nicely with the bricks
on the right side of the image and similarly with the top and bottom.</li>
</ul>

<h1>
Creating an OpenGL&nbsp;Window for our rendering class:</h1>

<ul>
<li>
We can easily apply OpenGL and 3D to our class library and create a 3D&nbsp;window
class.</li>

<li>
The shapes only communicate their topology and geometry to the Window class
so encapsulating the OpenGL code is easy.</li>

<li>
First the Header has slight changes: <a href="https://web.archive.org/web/20030912092049/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/cgxoglwindow.h">cgxoglwindow.h</a></li>

<li>
Most of the work is done here: <a href="https://web.archive.org/web/20030912092049/http://www.rpi.edu/dept/ecse/cg-s00/Classes/25/cgxoglwindow.cpp">cgxoglwindow.cpp</a></li>

<li>
</li>
</ul>

<p><br>
</p><hr>
<center>
<p>Copyright © 1999-2000, Thomas D. Citriniti, citrit@rpi.edu
<br>ECSE Dept., Rensselaer Polytechnic Inst., Troy NY, 12180 USA</p></center>








<!--
     FILE ARCHIVED ON 9:20:49 Sep 12, 2003 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:10:00 Aug 21, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</body></html>