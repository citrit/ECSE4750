<html><head>	<title>OOP in JS, Part 2 : Inheritance</title>	<script type="text/javascript" src="syntaxcolor.js"></script>	<link rel="stylesheet" type="text/css" media="all" href="docs.css"></head><body><h1>OOP in JS, Part 2 : Inheritance</h1><div id="pagecontent"><p>In <a href="OOPinJS.html">Part 1</a> we saw how to create classes in JS, including private, privileged, and public properties and methods. This section discusses inheritance in Javascript.</p><h2>Summary</h2><ul>	<li>You cause a class to inherit using <code class="js">ChildClassName.prototype = new ParentClass();</code>.</li>	<li>You need to remember to reset the <code class="js">constructor</code> property for the class using <code class="js">ChildClassName.prototype.constructor=ChildClassName</code>.</li>	<li>You can call ancestor class methods which your child class has overridden using the <code class="js">Function.call()</code> method.</li>	<li>Javascript does not support protected methods.</li></ul><h2>Example</h2><p style="margin-top:0em">To jump right into it, following is a sample showing inheritance between two classes:</p><pre><code class="js">function Mammal(name){	this.name=name;	this.offspring=[];}Mammal.prototype.haveABaby=function(){	var newBaby=new Mammal("Baby "+this.name);	this.offspring.push(newBaby);	return newBaby;}Mammal.prototype.toString=function(){	return '[Mammal "'+this.name+'"]';}Cat.prototype = new Mammal();        // Here's where the inheritance occursCat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammalfunction Cat(name){	this.name=name;}Cat.prototype.toString=function(){	return '[Cat "'+this.name+'"]';}var someAnimal = new Mammal('Mr. Biggles');var myPet = new Cat('Felix');alert('someAnimal is '+someAnimal);   // results in 'someAnimal is [Mammal "Mr. Biggles"]'alert('myPet is '+myPet);             // results in 'myPet is [Cat "Felix"]'myPet.haveABaby();                    // calls a method inherited from Mammalalert(myPet.offspring.length);        // shows that the cat has one baby nowalert(myPet.offspring[0]);            // results in '[Mammal "Baby Felix"]'</code></pre><h2>Using the <code class="js">.constructor</code> property</h2><p>Look at the last line in the above example. The baby of a Cat should be a Cat, right? While the <code class="js">haveABaby()</code> method worked, that method specifically asks to create a <code class="js">new Mammal</code>. While we <em>could</em> make a new <code class="js">haveABaby()</code> method for the <code class="js">Cat</code> subclass like <code class="js">this.offspring.push(new Cat("Baby "+this.name))</code>, it would be better to have the ancestor class make an object of the correct type.</p><p>Every object instance in JS has a property named <code class="js">constructor</code> that points to its parent class. For example, <code class="js">someAnimal.constructor==Mammmal</code> is true. Armed with this knowledge, we can remake the <code class="js">haveABaby()</code> method like this:</p><pre><code class="js">Mammal.prototype.haveABaby=function(){	var newBaby=new this.constructor("Baby "+this.name);	this.offspring.push(newBaby);	return newBaby;}...myPet.haveABaby();                    // Same as before: calls the method inherited from Mammalalert(myPet.offspring[0]);            // Now results in '[Cat "Baby Felix"]'</code></pre><h2>Calling 'super' methods</h2><p>Let's extend the example now so that when baby kittens are created, they 'mew' right after being born. To do this, we want to write our own custom <code class="js">Cat.prototype.haveABaby()</code> method, which is able to call the original <code class="js">Mammal.prototype.haveABaby()</code> method:</p><pre><code class="js">Cat.prototype.haveABaby=function(){	Mammal.prototype.haveABaby.call(this);	alert("mew!");}</code></pre><p>The above may look a little bit bizarre. Javascript does not have any sort of 'super' property, which would point to its parent class. Instead, you use the <code class="js">call()</code> method of a <code class="js">Function</code> object, which allows you to run a function using a different object as context for it. If you needed to pass parameters to this function, they would go after the 'this'. For more information on the <code class="js">Function.call()</code> method, see the <a href="http://msdn.microsoft.com/library/en-us/script56/html/js56jsmthcall.asp" target="external">MSDN docs for <code class="js">call()</code></a>.</p><h2>Making your own 'super' property</h2><p>Rather than having to know that <code class="js">Cat</code> inherits from <code class="js">Mammal</code>, and having to type in <code class="js">Mammal.prototype</code> each time you wanted to call an ancestor method, wouldn't it be nice to have your own property of the cat pointing to its ancestor class? Those familiar with other OOP languages may be tempted to call this property 'super', but JS <a href="http://msdn.microsoft.com/library/en-us/script56/html/js56jsconreserved.asp" target="external">reserves this word</a> for future use. The word 'parent', while used in some DOM items, is free for the JS language itself, so let's call it <code class="js">parent</code> in this example:</p><pre><code class="js">Cat.prototype = new Mammal();Cat.prototype.constructor=Cat;Cat.prototype.parent = Mammal.prototype;...Cat.prototype.haveABaby=function(){	var theKitten = this.parent.haveABaby.call(this);	alert("mew!");	return theKitten;}</code></pre><h2>Spoofing pure virtual classes</h2><p>Some OOP languages have the concept of a pure virtual class...one which cannot be instantiated itself, but only inherited from. For example, you might have a <code class="js">LivingThing</code> class which <code class="js">Mammal</code> inherited from, but you didn't want someone to be able to make a <code class="js">LivingThing</code> without specifying what type of thing it was. You can do this in JS by making the virtual class an object instead of a function.</p><p>The following example shows how this could be used to simulate a pure virtual ancestor:</p><pre><code class="js">LivingThing = {	beBorn : function(){		this.alive=true;	}}...Mammal.prototype = LivingThing;Mammal.prototype.parent = LivingThing;   //Note: not 'LivingThing.prototype'Mammal.prototype.haveABaby=function(){	this.parent.beBorn.call(this);	var newBaby=new this.constructor("Baby "+this.name);	this.offspring.push(newBaby);	return newBaby;}</code></pre><p>With the above, doing something like <code class="js">var spirit = new LivingThing()</code> <em>would</em> result in an error, since <code class="js">LivingThing</code> is not a function, and hence can't be used as a constructor.</p><h2>Convenient Inheritance</h2><p>Rather than writing 3 lines every time you want to inherit one class from another, it's convenient to extend the Function object to do it for you:</p><pre><code class="js">Function.prototype.inheritsFrom = function( parentClassOrObject ){	if ( parentClassOrObject.constructor == Function )	{		//Normal Inheritance		this.prototype = new parentClassOrObject;		this.prototype.constructor = this;		this.prototype.parent = parentClassOrObject.prototype;	}	else	{		//Pure Virtual Inheritance		this.prototype = parentClassOrObject;		this.prototype.constructor = this;		this.prototype.parent = parentClassOrObject;	}	return this;}////LivingThing = {	beBorn : function(){		this.alive = true;	}}////function Mammal(name){	this.name=name;	this.offspring=[];}Mammal.inheritsFrom( LivingThing );Mammal.prototype.haveABaby=function(){	this.parent.beBorn.call(this);	var newBaby = new this.constructor( "Baby " + this.name );	this.offspring.push(newBaby);	return newBaby;}////function Cat( name ){	this.name=name;}Cat.inheritsFrom( Mammal );Cat.prototype.haveABaby=function(){	var theKitten = this.parent.haveABaby.call(this);	alert("mew!");	return theKitten;}Cat.prototype.toString=function(){	return '[Cat "'+this.name+'"]';}////var felix = new Cat( "Felix" );var kitten = felix.haveABaby( ); // mew!alert( kitten );                 // [Cat "Baby Felix"]</code></pre><p>Just make sure you call this method immediately after your constructor, before you extend the prototype for the object.</p><h2>Protected methods?</h2><p>Some OOP languages have the concept of 'protected' methods&mdash;methods that exist in a parent or ancestor class that can only be called by descendants of the object (on each other), but not by external objects. These are not supported in JS. If you need such, you will have to write your own framework, ensuring that each class has a 'parent' or some such property, and walking up the tree to find ancestors and checking whether or not the calling object is the same type. Doable, but not enjoyable.</p></div><p class="byline">This page copyright &copy;2003-2005 by <a href="mailto:!@phrogz.net">Gavin Kistner</a>. Comments, corrections, and criticisms are welcome.</p></body></html>